"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai@4.3.16_react@18.3.1_zod@3.25.51";
exports.ids = ["vendor-chunks/ai@4.3.16_react@18.3.1_zod@3.25.51"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/ai@4.3.16_react@18.3.1_zod@3.25.51/node_modules/ai/react/dist/index.mjs":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ai@4.3.16_react@18.3.1_zod@3.25.51/node_modules/ai/react/dist/index.mjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useObject: () => (/* binding */ experimental_useObject),\n/* harmony export */   useAssistant: () => (/* binding */ useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/react */ \"(ssr)/./node_modules/.pnpm/@ai-sdk+react@1.2.12_react@18.3.1_zod@3.25.51/node_modules/@ai-sdk/react/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ experimental_useObject,useAssistant,useChat,useCompletion auto */ // react/index.ts\n\nvar useChat = _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__.useChat;\nvar useCompletion = _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__.useCompletion;\nvar useAssistant = _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__.useAssistant;\nvar experimental_useObject = _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__.experimental_useObject;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYWlANC4zLjE2X3JlYWN0QDE4LjMuMV96b2RAMy4yNS41MS9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBS087QUFLQSxJQUFNQSxVQUFVQyxrREFBWUE7QUFLNUIsSUFBTUMsZ0JBQWdCQyx3REFBa0JBO0FBS3hDLElBQU1DLGVBQWVDLHVEQUFpQkE7QUFLdEMsSUFBTUMseUJBQXlCQyxpRUFBMkJBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uLi9pbmRleC50cz83MzEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIHVzZUNoYXQgYXMgdXNlQ2hhdFJlYWN0LFxuICB1c2VDb21wbGV0aW9uIGFzIHVzZUNvbXBsZXRpb25SZWFjdCxcbiAgdXNlQXNzaXN0YW50IGFzIHVzZUFzc2lzdGFudFJlYWN0LFxuICBleHBlcmltZW50YWxfdXNlT2JqZWN0IGFzIGV4cGVyaW1lbnRhbF91c2VPYmplY3RSZWFjdCxcbn0gZnJvbSAnQGFpLXNkay9yZWFjdCc7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBAYWktc2RrL3JlYWN0YCBpbnN0ZWFkLlxuICovXG5leHBvcnQgY29uc3QgdXNlQ2hhdCA9IHVzZUNoYXRSZWFjdDtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYEBhaS1zZGsvcmVhY3RgIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBjb25zdCB1c2VDb21wbGV0aW9uID0gdXNlQ29tcGxldGlvblJlYWN0O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBgQGFpLXNkay9yZWFjdGAgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHVzZUFzc2lzdGFudCA9IHVzZUFzc2lzdGFudFJlYWN0O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBgQGFpLXNkay9yZWFjdGAgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGVyaW1lbnRhbF91c2VPYmplY3QgPSBleHBlcmltZW50YWxfdXNlT2JqZWN0UmVhY3Q7XG5cbmV4cG9ydCB0eXBlIHtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgQGFpLXNkay9yZWFjdGAgaW5zdGVhZC5cbiAgICovXG4gIENyZWF0ZU1lc3NhZ2UsXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgQGFpLXNkay9yZWFjdGAgaW5zdGVhZC5cbiAgICovXG4gIE1lc3NhZ2UsXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgQGFpLXNkay9yZWFjdGAgaW5zdGVhZC5cbiAgICovXG4gIFVzZUNoYXRPcHRpb25zLFxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYEBhaS1zZGsvcmVhY3RgIGluc3RlYWQuXG4gICAqL1xuICBVc2VDaGF0SGVscGVycyxcbn0gZnJvbSAnQGFpLXNkay9yZWFjdCc7XG4iXSwibmFtZXMiOlsidXNlQ2hhdCIsInVzZUNoYXRSZWFjdCIsInVzZUNvbXBsZXRpb24iLCJ1c2VDb21wbGV0aW9uUmVhY3QiLCJ1c2VBc3Npc3RhbnQiLCJ1c2VBc3Npc3RhbnRSZWFjdCIsImV4cGVyaW1lbnRhbF91c2VPYmplY3QiLCJleHBlcmltZW50YWxfdXNlT2JqZWN0UmVhY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ai@4.3.16_react@18.3.1_zod@3.25.51/node_modules/ai/react/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/ai@4.3.16_react@18.3.1_zod@3.25.51/node_modules/ai/dist/index.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/ai@4.3.16_react@18.3.1_zod@3.25.51/node_modules/ai/dist/index.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError),\n/* harmony export */   AssistantResponse: () => (/* binding */ AssistantResponse),\n/* harmony export */   DownloadError: () => (/* binding */ DownloadError),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* binding */ InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidResponseDataError),\n/* harmony export */   InvalidStreamPartError: () => (/* binding */ InvalidStreamPartError),\n/* harmony export */   InvalidToolArgumentsError: () => (/* binding */ InvalidToolArgumentsError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError),\n/* harmony export */   LangChainAdapter: () => (/* binding */ langchain_adapter_exports),\n/* harmony export */   LlamaIndexAdapter: () => (/* binding */ llamaindex_adapter_exports),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError),\n/* harmony export */   MCPClientError: () => (/* binding */ MCPClientError),\n/* harmony export */   MessageConversionError: () => (/* binding */ MessageConversionError),\n/* harmony export */   NoContentGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoContentGeneratedError),\n/* harmony export */   NoImageGeneratedError: () => (/* binding */ NoImageGeneratedError),\n/* harmony export */   NoObjectGeneratedError: () => (/* binding */ NoObjectGeneratedError),\n/* harmony export */   NoOutputSpecifiedError: () => (/* binding */ NoOutputSpecifiedError),\n/* harmony export */   NoSuchModelError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* binding */ NoSuchToolError),\n/* harmony export */   Output: () => (/* binding */ output_exports),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   StreamData: () => (/* binding */ StreamData),\n/* harmony export */   ToolCallRepairError: () => (/* binding */ ToolCallRepairError),\n/* harmony export */   ToolExecutionError: () => (/* binding */ ToolExecutionError),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError),\n/* harmony export */   appendClientMessage: () => (/* binding */ appendClientMessage),\n/* harmony export */   appendResponseMessages: () => (/* binding */ appendResponseMessages),\n/* harmony export */   convertToCoreMessages: () => (/* binding */ convertToCoreMessages),\n/* harmony export */   coreAssistantMessageSchema: () => (/* binding */ coreAssistantMessageSchema),\n/* harmony export */   coreMessageSchema: () => (/* binding */ coreMessageSchema),\n/* harmony export */   coreSystemMessageSchema: () => (/* binding */ coreSystemMessageSchema),\n/* harmony export */   coreToolMessageSchema: () => (/* binding */ coreToolMessageSchema),\n/* harmony export */   coreUserMessageSchema: () => (/* binding */ coreUserMessageSchema),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createDataStream: () => (/* binding */ createDataStream),\n/* harmony export */   createDataStreamResponse: () => (/* binding */ createDataStreamResponse),\n/* harmony export */   createIdGenerator: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator),\n/* harmony export */   createProviderRegistry: () => (/* binding */ createProviderRegistry),\n/* harmony export */   customProvider: () => (/* binding */ customProvider),\n/* harmony export */   defaultSettingsMiddleware: () => (/* binding */ defaultSettingsMiddleware),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_createMCPClient: () => (/* binding */ createMCPClient),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_customProvider: () => (/* binding */ experimental_customProvider),\n/* harmony export */   experimental_generateImage: () => (/* binding */ generateImage),\n/* harmony export */   experimental_generateSpeech: () => (/* binding */ generateSpeech),\n/* harmony export */   experimental_transcribe: () => (/* binding */ transcribe),\n/* harmony export */   experimental_wrapLanguageModel: () => (/* binding */ experimental_wrapLanguageModel),\n/* harmony export */   extractReasoningMiddleware: () => (/* binding */ extractReasoningMiddleware),\n/* harmony export */   formatAssistantStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart),\n/* harmony export */   formatDataStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart),\n/* harmony export */   generateId: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   jsonSchema: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.jsonSchema),\n/* harmony export */   parseAssistantStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.parseAssistantStreamPart),\n/* harmony export */   parseDataStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.parseDataStreamPart),\n/* harmony export */   pipeDataStreamToResponse: () => (/* binding */ pipeDataStreamToResponse),\n/* harmony export */   processDataStream: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.processDataStream),\n/* harmony export */   processTextStream: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.processTextStream),\n/* harmony export */   simulateReadableStream: () => (/* binding */ simulateReadableStream),\n/* harmony export */   simulateStreamingMiddleware: () => (/* binding */ simulateStreamingMiddleware),\n/* harmony export */   smoothStream: () => (/* binding */ smoothStream),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   tool: () => (/* binding */ tool),\n/* harmony export */   wrapLanguageModel: () => (/* binding */ wrapLanguageModel),\n/* harmony export */   zodSchema: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.zodSchema)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.51/node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(rsc)/./node_modules/.pnpm/@ai-sdk+ui-utils@1.2.11_zod@3.25.51/node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace-api.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/status.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/.pnpm/zod@3.25.51/node_modules/zod/dist/esm/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name17 in all)\n    __defProp(target, name17, { get: all[name17], enumerable: true });\n};\n\n// core/index.ts\n\n\n\n// core/data-stream/create-data-stream.ts\n\nfunction createDataStream({\n  execute,\n  onError = () => \"An error occurred.\"\n  // mask error messages for safety by default\n}) {\n  let controller;\n  const ongoingStreamPromises = [];\n  const stream = new ReadableStream({\n    start(controllerArg) {\n      controller = controllerArg;\n    }\n  });\n  function safeEnqueue(data) {\n    try {\n      controller.enqueue(data);\n    } catch (error) {\n    }\n  }\n  try {\n    const result = execute({\n      write(data) {\n        safeEnqueue(data);\n      },\n      writeData(data) {\n        safeEnqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"data\", [data]));\n      },\n      writeMessageAnnotation(annotation) {\n        safeEnqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"message_annotations\", [annotation]));\n      },\n      writeSource(source) {\n        safeEnqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"source\", source));\n      },\n      merge(streamArg) {\n        ongoingStreamPromises.push(\n          (async () => {\n            const reader = streamArg.getReader();\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done)\n                break;\n              safeEnqueue(value);\n            }\n          })().catch((error) => {\n            safeEnqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"error\", onError(error)));\n          })\n        );\n      },\n      onError\n    });\n    if (result) {\n      ongoingStreamPromises.push(\n        result.catch((error) => {\n          safeEnqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"error\", onError(error)));\n        })\n      );\n    }\n  } catch (error) {\n    safeEnqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"error\", onError(error)));\n  }\n  const waitForStreams = new Promise(async (resolve) => {\n    while (ongoingStreamPromises.length > 0) {\n      await ongoingStreamPromises.shift();\n    }\n    resolve();\n  });\n  waitForStreams.finally(() => {\n    try {\n      controller.close();\n    } catch (error) {\n    }\n  });\n  return stream;\n}\n\n// core/util/prepare-response-headers.ts\nfunction prepareResponseHeaders(headers, {\n  contentType,\n  dataStreamVersion\n}) {\n  const responseHeaders = new Headers(headers != null ? headers : {});\n  if (!responseHeaders.has(\"Content-Type\")) {\n    responseHeaders.set(\"Content-Type\", contentType);\n  }\n  if (dataStreamVersion !== void 0) {\n    responseHeaders.set(\"X-Vercel-AI-Data-Stream\", dataStreamVersion);\n  }\n  return responseHeaders;\n}\n\n// core/data-stream/create-data-stream-response.ts\nfunction createDataStreamResponse({\n  status,\n  statusText,\n  headers,\n  execute,\n  onError\n}) {\n  return new Response(\n    createDataStream({ execute, onError }).pipeThrough(new TextEncoderStream()),\n    {\n      status,\n      statusText,\n      headers: prepareResponseHeaders(headers, {\n        contentType: \"text/plain; charset=utf-8\",\n        dataStreamVersion: \"v1\"\n      })\n    }\n  );\n}\n\n// core/util/prepare-outgoing-http-headers.ts\nfunction prepareOutgoingHttpHeaders(headers, {\n  contentType,\n  dataStreamVersion\n}) {\n  const outgoingHeaders = {};\n  if (headers != null) {\n    for (const [key, value] of Object.entries(headers)) {\n      outgoingHeaders[key] = value;\n    }\n  }\n  if (outgoingHeaders[\"Content-Type\"] == null) {\n    outgoingHeaders[\"Content-Type\"] = contentType;\n  }\n  if (dataStreamVersion !== void 0) {\n    outgoingHeaders[\"X-Vercel-AI-Data-Stream\"] = dataStreamVersion;\n  }\n  return outgoingHeaders;\n}\n\n// core/util/write-to-server-response.ts\nfunction writeToServerResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream\n}) {\n  response.writeHead(status != null ? status : 200, statusText, headers);\n  const reader = stream.getReader();\n  const read = async () => {\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done)\n          break;\n        response.write(value);\n      }\n    } catch (error) {\n      throw error;\n    } finally {\n      response.end();\n    }\n  };\n  read();\n}\n\n// core/data-stream/pipe-data-stream-to-response.ts\nfunction pipeDataStreamToResponse(response, {\n  status,\n  statusText,\n  headers,\n  execute,\n  onError\n}) {\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: prepareOutgoingHttpHeaders(headers, {\n      contentType: \"text/plain; charset=utf-8\",\n      dataStreamVersion: \"v1\"\n    }),\n    stream: createDataStream({ execute, onError }).pipeThrough(\n      new TextEncoderStream()\n    )\n  });\n}\n\n// errors/invalid-argument-error.ts\n\nvar name = \"AI_InvalidArgumentError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    parameter,\n    value,\n    message\n  }) {\n    super({\n      name,\n      message: `Invalid argument for parameter ${parameter}: ${message}`\n    });\n    this[_a] = true;\n    this.parameter = parameter;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker);\n  }\n};\n_a = symbol;\n\n// util/retry-with-exponential-backoff.ts\n\n\n\n// util/retry-error.ts\n\nvar name2 = \"AI_RetryError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    message,\n    reason,\n    errors\n  }) {\n    super({ name: name2, message });\n    this[_a2] = true;\n    this.reason = reason;\n    this.errors = errors;\n    this.lastError = errors[errors.length - 1];\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker2);\n  }\n};\n_a2 = symbol2;\n\n// util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({\n  maxRetries = 2,\n  initialDelayInMs = 2e3,\n  backoffFactor = 2\n} = {}) => async (f) => _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs: initialDelayInMs,\n  backoffFactor\n});\nasync function _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs,\n  backoffFactor\n}, errors = []) {\n  try {\n    return await f();\n  } catch (error) {\n    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isAbortError)(error)) {\n      throw error;\n    }\n    if (maxRetries === 0) {\n      throw error;\n    }\n    const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: \"maxRetriesExceeded\",\n        errors: newErrors\n      });\n    }\n    if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n      await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay)(delayInMs);\n      return _retryWithExponentialBackoff(\n        f,\n        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },\n        newErrors\n      );\n    }\n    if (tryNumber === 1) {\n      throw error;\n    }\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: \"errorNotRetryable\",\n      errors: newErrors\n    });\n  }\n}\n\n// core/prompt/prepare-retries.ts\nfunction prepareRetries({\n  maxRetries\n}) {\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be an integer\"\n      });\n    }\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be >= 0\"\n      });\n    }\n  }\n  const maxRetriesResult = maxRetries != null ? maxRetries : 2;\n  return {\n    maxRetries: maxRetriesResult,\n    retry: retryWithExponentialBackoff({ maxRetries: maxRetriesResult })\n  };\n}\n\n// core/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({\n  operationId,\n  telemetry\n}) {\n  return {\n    // standardized operation and resource name:\n    \"operation.name\": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`,\n    \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n    // detailed, AI SDK specific data:\n    \"ai.operationId\": operationId,\n    \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId\n  };\n}\n\n// core/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers\n}) {\n  var _a17;\n  return {\n    \"ai.model.provider\": model.provider,\n    \"ai.model.id\": model.modelId,\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      attributes[`ai.settings.${key}`] = value;\n      return attributes;\n    }, {}),\n    // add metadata as attributes:\n    ...Object.entries((_a17 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a17 : {}).reduce(\n      (attributes, [key, value]) => {\n        attributes[`ai.telemetry.metadata.${key}`] = value;\n        return attributes;\n      },\n      {}\n    ),\n    // request headers\n    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {\n      if (value !== void 0) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {})\n  };\n}\n\n// core/telemetry/get-tracer.ts\n\n\n// core/telemetry/noop-tracer.ts\nvar noopTracer = {\n  startSpan() {\n    return noopSpan;\n  },\n  startActiveSpan(name17, arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === \"function\") {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === \"function\") {\n      return arg3(noopSpan);\n    }\n  }\n};\nvar noopSpan = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  }\n};\nvar noopSpanContext = {\n  traceId: \"\",\n  spanId: \"\",\n  traceFlags: 0\n};\n\n// core/telemetry/get-tracer.ts\nfunction getTracer({\n  isEnabled = false,\n  tracer\n} = {}) {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n  if (tracer) {\n    return tracer;\n  }\n  return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__.trace.getTracer(\"ai\");\n}\n\n// core/telemetry/record-span.ts\n\nfunction recordSpan({\n  name: name17,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true\n}) {\n  return tracer.startActiveSpan(name17, { attributes }, async (span) => {\n    try {\n      const result = await fn(span);\n      if (endWhenDone) {\n        span.end();\n      }\n      return result;\n    } catch (error) {\n      try {\n        if (error instanceof Error) {\n          span.recordException({\n            name: error.name,\n            message: error.message,\n            stack: error.stack\n          });\n          span.setStatus({\n            code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.SpanStatusCode.ERROR,\n            message: error.message\n          });\n        } else {\n          span.setStatus({ code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.SpanStatusCode.ERROR });\n        }\n      } finally {\n        span.end();\n      }\n      throw error;\n    }\n  });\n}\n\n// core/telemetry/select-telemetry-attributes.ts\nfunction selectTelemetryAttributes({\n  telemetry,\n  attributes\n}) {\n  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {\n    return {};\n  }\n  return Object.entries(attributes).reduce((attributes2, [key, value]) => {\n    if (value === void 0) {\n      return attributes2;\n    }\n    if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n        return attributes2;\n      }\n      const result = value.input();\n      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };\n    }\n    if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n        return attributes2;\n      }\n      const result = value.output();\n      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };\n    }\n    return { ...attributes2, [key]: value };\n  }, {});\n}\n\n// core/embed/embed.ts\nasync function embed({\n  model,\n  value,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry\n}) {\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.embed\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embed\", telemetry }),\n        ...baseTelemetryAttributes,\n        \"ai.value\": { input: () => JSON.stringify(value) }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const { embedding, usage, rawResponse } = await retry(\n        () => (\n          // nested spans to align with the embedMany telemetry data:\n          recordSpan({\n            name: \"ai.embed.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embed.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": { input: () => [JSON.stringify(value)] }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a17;\n              const modelResponse = await model.doEmbed({\n                values: [value],\n                abortSignal,\n                headers\n              });\n              const embedding2 = modelResponse.embeddings[0];\n              const usage2 = (_a17 = modelResponse.usage) != null ? _a17 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => modelResponse.embeddings.map(\n                        (embedding3) => JSON.stringify(embedding3)\n                      )\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return {\n                embedding: embedding2,\n                usage: usage2,\n                rawResponse: modelResponse.rawResponse\n              };\n            }\n          })\n        )\n      );\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embedding\": { output: () => JSON.stringify(embedding) },\n            \"ai.usage.tokens\": usage.tokens\n          }\n        })\n      );\n      return new DefaultEmbedResult({ value, embedding, usage, rawResponse });\n    }\n  });\n}\nvar DefaultEmbedResult = class {\n  constructor(options) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.usage = options.usage;\n    this.rawResponse = options.rawResponse;\n  }\n};\n\n// core/util/split-array.ts\nfunction splitArray(array, chunkSize) {\n  if (chunkSize <= 0) {\n    throw new Error(\"chunkSize must be greater than 0\");\n  }\n  const result = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n  return result;\n}\n\n// core/embed/embed-many.ts\nasync function embedMany({\n  model,\n  values,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry\n}) {\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.embedMany\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embedMany\", telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.values\": {\n          input: () => values.map((value) => JSON.stringify(value))\n        }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;\n      if (maxEmbeddingsPerCall == null) {\n        const { embeddings: embeddings2, usage } = await retry(() => {\n          return recordSpan({\n            name: \"ai.embedMany.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embedMany.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                  input: () => values.map((value) => JSON.stringify(value))\n                }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a17;\n              const modelResponse = await model.doEmbed({\n                values,\n                abortSignal,\n                headers\n              });\n              const embeddings3 = modelResponse.embeddings;\n              const usage2 = (_a17 = modelResponse.usage) != null ? _a17 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => embeddings3.map((embedding) => JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return { embeddings: embeddings3, usage: usage2 };\n            }\n          });\n        });\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.embeddings\": {\n                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))\n              },\n              \"ai.usage.tokens\": usage.tokens\n            }\n          })\n        );\n        return new DefaultEmbedManyResult({ values, embeddings: embeddings2, usage });\n      }\n      const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n      const embeddings = [];\n      let tokens = 0;\n      for (const chunk of valueChunks) {\n        const { embeddings: responseEmbeddings, usage } = await retry(() => {\n          return recordSpan({\n            name: \"ai.embedMany.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embedMany.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                  input: () => chunk.map((value) => JSON.stringify(value))\n                }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a17;\n              const modelResponse = await model.doEmbed({\n                values: chunk,\n                abortSignal,\n                headers\n              });\n              const embeddings2 = modelResponse.embeddings;\n              const usage2 = (_a17 = modelResponse.usage) != null ? _a17 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => embeddings2.map((embedding) => JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return { embeddings: embeddings2, usage: usage2 };\n            }\n          });\n        });\n        embeddings.push(...responseEmbeddings);\n        tokens += usage.tokens;\n      }\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embeddings\": {\n              output: () => embeddings.map((embedding) => JSON.stringify(embedding))\n            },\n            \"ai.usage.tokens\": tokens\n          }\n        })\n      );\n      return new DefaultEmbedManyResult({\n        values,\n        embeddings,\n        usage: { tokens }\n      });\n    }\n  });\n}\nvar DefaultEmbedManyResult = class {\n  constructor(options) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n    this.usage = options.usage;\n  }\n};\n\n// errors/no-image-generated-error.ts\n\nvar name3 = \"AI_NoImageGeneratedError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar NoImageGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    message = \"No image generated.\",\n    cause,\n    responses\n  }) {\n    super({ name: name3, message, cause });\n    this[_a3] = true;\n    this.responses = responses;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker3);\n  }\n};\n_a3 = symbol3;\n\n// core/generate-text/generated-file.ts\n\nvar DefaultGeneratedFile = class {\n  constructor({\n    data,\n    mimeType\n  }) {\n    const isUint8Array = data instanceof Uint8Array;\n    this.base64Data = isUint8Array ? void 0 : data;\n    this.uint8ArrayData = isUint8Array ? data : void 0;\n    this.mimeType = mimeType;\n  }\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get base64() {\n    if (this.base64Data == null) {\n      this.base64Data = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(this.uint8ArrayData);\n    }\n    return this.base64Data;\n  }\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get uint8Array() {\n    if (this.uint8ArrayData == null) {\n      this.uint8ArrayData = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(this.base64Data);\n    }\n    return this.uint8ArrayData;\n  }\n};\nvar DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {\n  constructor(options) {\n    super(options);\n    this.type = \"file\";\n  }\n};\n\n// core/util/detect-mimetype.ts\n\nvar imageMimeTypeSignatures = [\n  {\n    mimeType: \"image/gif\",\n    bytesPrefix: [71, 73, 70],\n    base64Prefix: \"R0lG\"\n  },\n  {\n    mimeType: \"image/png\",\n    bytesPrefix: [137, 80, 78, 71],\n    base64Prefix: \"iVBORw\"\n  },\n  {\n    mimeType: \"image/jpeg\",\n    bytesPrefix: [255, 216],\n    base64Prefix: \"/9j/\"\n  },\n  {\n    mimeType: \"image/webp\",\n    bytesPrefix: [82, 73, 70, 70],\n    base64Prefix: \"UklGRg\"\n  },\n  {\n    mimeType: \"image/bmp\",\n    bytesPrefix: [66, 77],\n    base64Prefix: \"Qk\"\n  },\n  {\n    mimeType: \"image/tiff\",\n    bytesPrefix: [73, 73, 42, 0],\n    base64Prefix: \"SUkqAA\"\n  },\n  {\n    mimeType: \"image/tiff\",\n    bytesPrefix: [77, 77, 0, 42],\n    base64Prefix: \"TU0AKg\"\n  },\n  {\n    mimeType: \"image/avif\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      32,\n      102,\n      116,\n      121,\n      112,\n      97,\n      118,\n      105,\n      102\n    ],\n    base64Prefix: \"AAAAIGZ0eXBhdmlm\"\n  },\n  {\n    mimeType: \"image/heic\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      32,\n      102,\n      116,\n      121,\n      112,\n      104,\n      101,\n      105,\n      99\n    ],\n    base64Prefix: \"AAAAIGZ0eXBoZWlj\"\n  }\n];\nvar audioMimeTypeSignatures = [\n  {\n    mimeType: \"audio/mpeg\",\n    bytesPrefix: [255, 251],\n    base64Prefix: \"//s=\"\n  },\n  {\n    mimeType: \"audio/wav\",\n    bytesPrefix: [82, 73, 70, 70],\n    base64Prefix: \"UklGR\"\n  },\n  {\n    mimeType: \"audio/ogg\",\n    bytesPrefix: [79, 103, 103, 83],\n    base64Prefix: \"T2dnUw\"\n  },\n  {\n    mimeType: \"audio/flac\",\n    bytesPrefix: [102, 76, 97, 67],\n    base64Prefix: \"ZkxhQw\"\n  },\n  {\n    mimeType: \"audio/aac\",\n    bytesPrefix: [64, 21, 0, 0],\n    base64Prefix: \"QBUA\"\n  },\n  {\n    mimeType: \"audio/mp4\",\n    bytesPrefix: [102, 116, 121, 112],\n    base64Prefix: \"ZnR5cA\"\n  }\n];\nvar stripID3 = (data) => {\n  const bytes = typeof data === \"string\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(data) : data;\n  const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;\n  return bytes.slice(id3Size + 10);\n};\nfunction stripID3TagsIfPresent(data) {\n  const hasId3 = typeof data === \"string\" && data.startsWith(\"SUQz\") || typeof data !== \"string\" && data.length > 10 && data[0] === 73 && // 'I'\n  data[1] === 68 && // 'D'\n  data[2] === 51;\n  return hasId3 ? stripID3(data) : data;\n}\nfunction detectMimeType({\n  data,\n  signatures\n}) {\n  const processedData = stripID3TagsIfPresent(data);\n  for (const signature of signatures) {\n    if (typeof processedData === \"string\" ? processedData.startsWith(signature.base64Prefix) : processedData.length >= signature.bytesPrefix.length && signature.bytesPrefix.every(\n      (byte, index) => processedData[index] === byte\n    )) {\n      return signature.mimeType;\n    }\n  }\n  return void 0;\n}\n\n// core/generate-image/generate-image.ts\nasync function generateImage({\n  model,\n  prompt,\n  n = 1,\n  size,\n  aspectRatio,\n  seed,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  var _a17;\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const maxImagesPerCall = (_a17 = model.maxImagesPerCall) != null ? _a17 : 1;\n  const callCount = Math.ceil(n / maxImagesPerCall);\n  const callImageCounts = Array.from({ length: callCount }, (_, i) => {\n    if (i < callCount - 1) {\n      return maxImagesPerCall;\n    }\n    const remainder = n % maxImagesPerCall;\n    return remainder === 0 ? maxImagesPerCall : remainder;\n  });\n  const results = await Promise.all(\n    callImageCounts.map(\n      async (callImageCount) => retry(\n        () => model.doGenerate({\n          prompt,\n          n: callImageCount,\n          abortSignal,\n          headers,\n          size,\n          aspectRatio,\n          seed,\n          providerOptions: providerOptions != null ? providerOptions : {}\n        })\n      )\n    )\n  );\n  const images = [];\n  const warnings = [];\n  const responses = [];\n  for (const result of results) {\n    images.push(\n      ...result.images.map(\n        (image) => {\n          var _a18;\n          return new DefaultGeneratedFile({\n            data: image,\n            mimeType: (_a18 = detectMimeType({\n              data: image,\n              signatures: imageMimeTypeSignatures\n            })) != null ? _a18 : \"image/png\"\n          });\n        }\n      )\n    );\n    warnings.push(...result.warnings);\n    responses.push(result.response);\n  }\n  if (!images.length) {\n    throw new NoImageGeneratedError({ responses });\n  }\n  return new DefaultGenerateImageResult({ images, warnings, responses });\n}\nvar DefaultGenerateImageResult = class {\n  constructor(options) {\n    this.images = options.images;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n  }\n  get image() {\n    return this.images[0];\n  }\n};\n\n// core/generate-object/generate-object.ts\n\n\n\n// errors/no-object-generated-error.ts\n\nvar name4 = \"AI_NoObjectGeneratedError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar NoObjectGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    message = \"No object generated.\",\n    cause,\n    text: text2,\n    response,\n    usage,\n    finishReason\n  }) {\n    super({ name: name4, message, cause });\n    this[_a4] = true;\n    this.text = text2;\n    this.response = response;\n    this.usage = usage;\n    this.finishReason = finishReason;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\n\n// util/download-error.ts\n\nvar name5 = \"AI_DownloadError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}`\n  }) {\n    super({ name: name5, message, cause });\n    this[_a5] = true;\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker5);\n  }\n};\n_a5 = symbol5;\n\n// util/download.ts\nasync function download({ url }) {\n  var _a17;\n  const urlText = url.toString();\n  try {\n    const response = await fetch(urlText);\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText\n      });\n    }\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mimeType: (_a17 = response.headers.get(\"content-type\")) != null ? _a17 : void 0\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n}\n\n// core/prompt/data-content.ts\n\n\n// core/prompt/invalid-data-content-error.ts\n\nvar name6 = \"AI_InvalidDataContentError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`\n  }) {\n    super({ name: name6, message, cause });\n    this[_a6] = true;\n    this.content = content;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker6);\n  }\n};\n_a6 = symbol6;\n\n// core/prompt/data-content.ts\n\nvar dataContentSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.union([\n  zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n  zod__WEBPACK_IMPORTED_MODULE_5__.z[\"instanceof\"](Uint8Array),\n  zod__WEBPACK_IMPORTED_MODULE_5__.z[\"instanceof\"](ArrayBuffer),\n  zod__WEBPACK_IMPORTED_MODULE_5__.z.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value) => {\n      var _a17, _b;\n      return (_b = (_a17 = globalThis.Buffer) == null ? void 0 : _a17.isBuffer(value)) != null ? _b : false;\n    },\n    { message: \"Must be a Buffer\" }\n  )\n]);\nfunction convertDataContentToBase64String(content) {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  if (content instanceof ArrayBuffer) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(new Uint8Array(content));\n  }\n  return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n  if (typeof content === \"string\") {\n    try {\n      return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message: \"Invalid data content. Content string is not a base64-encoded media.\",\n        content,\n        cause: error\n      });\n    }\n  }\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n  throw new InvalidDataContentError({ content });\n}\nfunction convertUint8ArrayToText(uint8Array) {\n  try {\n    return new TextDecoder().decode(uint8Array);\n  } catch (error) {\n    throw new Error(\"Error decoding Uint8Array to text\");\n  }\n}\n\n// core/prompt/invalid-message-role-error.ts\n\nvar name7 = \"AI_InvalidMessageRoleError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`\n  }) {\n    super({ name: name7, message });\n    this[_a7] = true;\n    this.role = role;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\n\n// core/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n  try {\n    const [header, base64Content] = dataUrl.split(\",\");\n    return {\n      mimeType: header.split(\";\")[0].split(\":\")[1],\n      base64Content\n    };\n  } catch (error) {\n    return {\n      mimeType: void 0,\n      base64Content: void 0\n    };\n  }\n}\n\n// core/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({\n  prompt,\n  modelSupportsImageUrls = true,\n  modelSupportsUrl = () => false,\n  downloadImplementation = download\n}) {\n  const downloadedAssets = await downloadAssets(\n    prompt.messages,\n    downloadImplementation,\n    modelSupportsImageUrls,\n    modelSupportsUrl\n  );\n  return [\n    ...prompt.system != null ? [{ role: \"system\", content: prompt.system }] : [],\n    ...prompt.messages.map(\n      (message) => convertToLanguageModelMessage(message, downloadedAssets)\n    )\n  ];\n}\nfunction convertToLanguageModelMessage(message, downloadedAssets) {\n  var _a17, _b, _c, _d, _e, _f;\n  const role = message.role;\n  switch (role) {\n    case \"system\": {\n      return {\n        role: \"system\",\n        content: message.content,\n        providerMetadata: (_a17 = message.providerOptions) != null ? _a17 : message.experimental_providerMetadata\n      };\n    }\n    case \"user\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"user\",\n          content: [{ type: \"text\", text: message.content }],\n          providerMetadata: (_b = message.providerOptions) != null ? _b : message.experimental_providerMetadata\n        };\n      }\n      return {\n        role: \"user\",\n        content: message.content.map((part) => convertPartToLanguageModelPart(part, downloadedAssets)).filter((part) => part.type !== \"text\" || part.text !== \"\"),\n        providerMetadata: (_c = message.providerOptions) != null ? _c : message.experimental_providerMetadata\n      };\n    }\n    case \"assistant\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"assistant\",\n          content: [{ type: \"text\", text: message.content }],\n          providerMetadata: (_d = message.providerOptions) != null ? _d : message.experimental_providerMetadata\n        };\n      }\n      return {\n        role: \"assistant\",\n        content: message.content.filter(\n          // remove empty text parts:\n          (part) => part.type !== \"text\" || part.text !== \"\"\n        ).map((part) => {\n          var _a18;\n          const providerOptions = (_a18 = part.providerOptions) != null ? _a18 : part.experimental_providerMetadata;\n          switch (part.type) {\n            case \"file\": {\n              return {\n                type: \"file\",\n                data: part.data instanceof URL ? part.data : convertDataContentToBase64String(part.data),\n                filename: part.filename,\n                mimeType: part.mimeType,\n                providerMetadata: providerOptions\n              };\n            }\n            case \"reasoning\": {\n              return {\n                type: \"reasoning\",\n                text: part.text,\n                signature: part.signature,\n                providerMetadata: providerOptions\n              };\n            }\n            case \"redacted-reasoning\": {\n              return {\n                type: \"redacted-reasoning\",\n                data: part.data,\n                providerMetadata: providerOptions\n              };\n            }\n            case \"text\": {\n              return {\n                type: \"text\",\n                text: part.text,\n                providerMetadata: providerOptions\n              };\n            }\n            case \"tool-call\": {\n              return {\n                type: \"tool-call\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                args: part.args,\n                providerMetadata: providerOptions\n              };\n            }\n          }\n        }),\n        providerMetadata: (_e = message.providerOptions) != null ? _e : message.experimental_providerMetadata\n      };\n    }\n    case \"tool\": {\n      return {\n        role: \"tool\",\n        content: message.content.map((part) => {\n          var _a18;\n          return {\n            type: \"tool-result\",\n            toolCallId: part.toolCallId,\n            toolName: part.toolName,\n            result: part.result,\n            content: part.experimental_content,\n            isError: part.isError,\n            providerMetadata: (_a18 = part.providerOptions) != null ? _a18 : part.experimental_providerMetadata\n          };\n        }),\n        providerMetadata: (_f = message.providerOptions) != null ? _f : message.experimental_providerMetadata\n      };\n    }\n    default: {\n      const _exhaustiveCheck = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\nasync function downloadAssets(messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl) {\n  const urls = messages.filter((message) => message.role === \"user\").map((message) => message.content).filter(\n    (content) => Array.isArray(content)\n  ).flat().filter(\n    (part) => part.type === \"image\" || part.type === \"file\"\n  ).filter(\n    (part) => !(part.type === \"image\" && modelSupportsImageUrls === true)\n  ).map((part) => part.type === \"image\" ? part.image : part.data).map(\n    (part) => (\n      // support string urls:\n      typeof part === \"string\" && (part.startsWith(\"http:\") || part.startsWith(\"https:\")) ? new URL(part) : part\n    )\n  ).filter((image) => image instanceof URL).filter((url) => !modelSupportsUrl(url));\n  const downloadedImages = await Promise.all(\n    urls.map(async (url) => ({\n      url,\n      data: await downloadImplementation({ url })\n    }))\n  );\n  return Object.fromEntries(\n    downloadedImages.map(({ url, data }) => [url.toString(), data])\n  );\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n  var _a17, _b, _c, _d;\n  if (part.type === \"text\") {\n    return {\n      type: \"text\",\n      text: part.text,\n      providerMetadata: (_a17 = part.providerOptions) != null ? _a17 : part.experimental_providerMetadata\n    };\n  }\n  let mimeType = part.mimeType;\n  let data;\n  let content;\n  let normalizedData;\n  const type = part.type;\n  switch (type) {\n    case \"image\":\n      data = part.image;\n      break;\n    case \"file\":\n      data = part.data;\n      break;\n    default:\n      throw new Error(`Unsupported part type: ${type}`);\n  }\n  try {\n    content = typeof data === \"string\" ? new URL(data) : data;\n  } catch (error) {\n    content = data;\n  }\n  if (content instanceof URL) {\n    if (content.protocol === \"data:\") {\n      const { mimeType: dataUrlMimeType, base64Content } = splitDataUrl(\n        content.toString()\n      );\n      if (dataUrlMimeType == null || base64Content == null) {\n        throw new Error(`Invalid data URL format in part ${type}`);\n      }\n      mimeType = dataUrlMimeType;\n      normalizedData = convertDataContentToUint8Array(base64Content);\n    } else {\n      const downloadedFile = downloadedAssets[content.toString()];\n      if (downloadedFile) {\n        normalizedData = downloadedFile.data;\n        mimeType != null ? mimeType : mimeType = downloadedFile.mimeType;\n      } else {\n        normalizedData = content;\n      }\n    }\n  } else {\n    normalizedData = convertDataContentToUint8Array(content);\n  }\n  switch (type) {\n    case \"image\": {\n      if (normalizedData instanceof Uint8Array) {\n        mimeType = (_b = detectMimeType({\n          data: normalizedData,\n          signatures: imageMimeTypeSignatures\n        })) != null ? _b : mimeType;\n      }\n      return {\n        type: \"image\",\n        image: normalizedData,\n        mimeType,\n        providerMetadata: (_c = part.providerOptions) != null ? _c : part.experimental_providerMetadata\n      };\n    }\n    case \"file\": {\n      if (mimeType == null) {\n        throw new Error(`Mime type is missing for file part`);\n      }\n      return {\n        type: \"file\",\n        data: normalizedData instanceof Uint8Array ? convertDataContentToBase64String(normalizedData) : normalizedData,\n        filename: part.filename,\n        mimeType,\n        providerMetadata: (_d = part.providerOptions) != null ? _d : part.experimental_providerMetadata\n      };\n    }\n  }\n}\n\n// core/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({\n  maxTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  stopSequences,\n  seed\n}) {\n  if (maxTokens != null) {\n    if (!Number.isInteger(maxTokens)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be an integer\"\n      });\n    }\n    if (maxTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be >= 1\"\n      });\n    }\n  }\n  if (temperature != null) {\n    if (typeof temperature !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"temperature\",\n        value: temperature,\n        message: \"temperature must be a number\"\n      });\n    }\n  }\n  if (topP != null) {\n    if (typeof topP !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topP\",\n        value: topP,\n        message: \"topP must be a number\"\n      });\n    }\n  }\n  if (topK != null) {\n    if (typeof topK !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topK\",\n        value: topK,\n        message: \"topK must be a number\"\n      });\n    }\n  }\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"presencePenalty\",\n        value: presencePenalty,\n        message: \"presencePenalty must be a number\"\n      });\n    }\n  }\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"frequencyPenalty\",\n        value: frequencyPenalty,\n        message: \"frequencyPenalty must be a number\"\n      });\n    }\n  }\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: \"seed\",\n        value: seed,\n        message: \"seed must be an integer\"\n      });\n    }\n  }\n  return {\n    maxTokens,\n    // TODO v5 remove default 0 for temperature\n    temperature: temperature != null ? temperature : 0,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : void 0,\n    seed\n  };\n}\n\n// core/prompt/standardize-prompt.ts\n\n\n\n\n// core/prompt/attachments-to-parts.ts\nfunction attachmentsToParts(attachments) {\n  var _a17, _b, _c;\n  const parts = [];\n  for (const attachment of attachments) {\n    let url;\n    try {\n      url = new URL(attachment.url);\n    } catch (error) {\n      throw new Error(`Invalid URL: ${attachment.url}`);\n    }\n    switch (url.protocol) {\n      case \"http:\":\n      case \"https:\": {\n        if ((_a17 = attachment.contentType) == null ? void 0 : _a17.startsWith(\"image/\")) {\n          parts.push({ type: \"image\", image: url });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error(\n              \"If the attachment is not an image, it must specify a content type\"\n            );\n          }\n          parts.push({\n            type: \"file\",\n            data: url,\n            mimeType: attachment.contentType\n          });\n        }\n        break;\n      }\n      case \"data:\": {\n        let header;\n        let base64Content;\n        let mimeType;\n        try {\n          [header, base64Content] = attachment.url.split(\",\");\n          mimeType = header.split(\";\")[0].split(\":\")[1];\n        } catch (error) {\n          throw new Error(`Error processing data URL: ${attachment.url}`);\n        }\n        if (mimeType == null || base64Content == null) {\n          throw new Error(`Invalid data URL format: ${attachment.url}`);\n        }\n        if ((_b = attachment.contentType) == null ? void 0 : _b.startsWith(\"image/\")) {\n          parts.push({\n            type: \"image\",\n            image: convertDataContentToUint8Array(base64Content)\n          });\n        } else if ((_c = attachment.contentType) == null ? void 0 : _c.startsWith(\"text/\")) {\n          parts.push({\n            type: \"text\",\n            text: convertUint8ArrayToText(\n              convertDataContentToUint8Array(base64Content)\n            )\n          });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error(\n              \"If the attachment is not an image or text, it must specify a content type\"\n            );\n          }\n          parts.push({\n            type: \"file\",\n            data: base64Content,\n            mimeType: attachment.contentType\n          });\n        }\n        break;\n      }\n      default: {\n        throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n      }\n    }\n  }\n  return parts;\n}\n\n// core/prompt/message-conversion-error.ts\n\nvar name8 = \"AI_MessageConversionError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar MessageConversionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    originalMessage,\n    message\n  }) {\n    super({ name: name8, message });\n    this[_a8] = true;\n    this.originalMessage = originalMessage;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker8);\n  }\n};\n_a8 = symbol8;\n\n// core/prompt/convert-to-core-messages.ts\nfunction convertToCoreMessages(messages, options) {\n  var _a17, _b;\n  const tools = (_a17 = options == null ? void 0 : options.tools) != null ? _a17 : {};\n  const coreMessages = [];\n  for (let i = 0; i < messages.length; i++) {\n    const message = messages[i];\n    const isLastMessage = i === messages.length - 1;\n    const { role, content, experimental_attachments } = message;\n    switch (role) {\n      case \"system\": {\n        coreMessages.push({\n          role: \"system\",\n          content\n        });\n        break;\n      }\n      case \"user\": {\n        if (message.parts == null) {\n          coreMessages.push({\n            role: \"user\",\n            content: experimental_attachments ? [\n              { type: \"text\", text: content },\n              ...attachmentsToParts(experimental_attachments)\n            ] : content\n          });\n        } else {\n          const textParts = message.parts.filter((part) => part.type === \"text\").map((part) => ({\n            type: \"text\",\n            text: part.text\n          }));\n          coreMessages.push({\n            role: \"user\",\n            content: experimental_attachments ? [...textParts, ...attachmentsToParts(experimental_attachments)] : textParts\n          });\n        }\n        break;\n      }\n      case \"assistant\": {\n        if (message.parts != null) {\n          let processBlock2 = function() {\n            const content2 = [];\n            for (const part of block) {\n              switch (part.type) {\n                case \"file\":\n                case \"text\": {\n                  content2.push(part);\n                  break;\n                }\n                case \"reasoning\": {\n                  for (const detail of part.details) {\n                    switch (detail.type) {\n                      case \"text\":\n                        content2.push({\n                          type: \"reasoning\",\n                          text: detail.text,\n                          signature: detail.signature\n                        });\n                        break;\n                      case \"redacted\":\n                        content2.push({\n                          type: \"redacted-reasoning\",\n                          data: detail.data\n                        });\n                        break;\n                    }\n                  }\n                  break;\n                }\n                case \"tool-invocation\":\n                  content2.push({\n                    type: \"tool-call\",\n                    toolCallId: part.toolInvocation.toolCallId,\n                    toolName: part.toolInvocation.toolName,\n                    args: part.toolInvocation.args\n                  });\n                  break;\n                default: {\n                  const _exhaustiveCheck = part;\n                  throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n                }\n              }\n            }\n            coreMessages.push({\n              role: \"assistant\",\n              content: content2\n            });\n            const stepInvocations = block.filter(\n              (part) => part.type === \"tool-invocation\"\n            ).map((part) => part.toolInvocation);\n            if (stepInvocations.length > 0) {\n              coreMessages.push({\n                role: \"tool\",\n                content: stepInvocations.map(\n                  (toolInvocation) => {\n                    if (!(\"result\" in toolInvocation)) {\n                      throw new MessageConversionError({\n                        originalMessage: message,\n                        message: \"ToolInvocation must have a result: \" + JSON.stringify(toolInvocation)\n                      });\n                    }\n                    const { toolCallId, toolName, result } = toolInvocation;\n                    const tool2 = tools[toolName];\n                    return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {\n                      type: \"tool-result\",\n                      toolCallId,\n                      toolName,\n                      result: tool2.experimental_toToolResultContent(result),\n                      experimental_content: tool2.experimental_toToolResultContent(result)\n                    } : {\n                      type: \"tool-result\",\n                      toolCallId,\n                      toolName,\n                      result\n                    };\n                  }\n                )\n              });\n            }\n            block = [];\n            blockHasToolInvocations = false;\n            currentStep++;\n          };\n          var processBlock = processBlock2;\n          let currentStep = 0;\n          let blockHasToolInvocations = false;\n          let block = [];\n          for (const part of message.parts) {\n            switch (part.type) {\n              case \"text\": {\n                if (blockHasToolInvocations) {\n                  processBlock2();\n                }\n                block.push(part);\n                break;\n              }\n              case \"file\":\n              case \"reasoning\": {\n                block.push(part);\n                break;\n              }\n              case \"tool-invocation\": {\n                if (((_b = part.toolInvocation.step) != null ? _b : 0) !== currentStep) {\n                  processBlock2();\n                }\n                block.push(part);\n                blockHasToolInvocations = true;\n                break;\n              }\n            }\n          }\n          processBlock2();\n          break;\n        }\n        const toolInvocations = message.toolInvocations;\n        if (toolInvocations == null || toolInvocations.length === 0) {\n          coreMessages.push({ role: \"assistant\", content });\n          break;\n        }\n        const maxStep = toolInvocations.reduce((max, toolInvocation) => {\n          var _a18;\n          return Math.max(max, (_a18 = toolInvocation.step) != null ? _a18 : 0);\n        }, 0);\n        for (let i2 = 0; i2 <= maxStep; i2++) {\n          const stepInvocations = toolInvocations.filter(\n            (toolInvocation) => {\n              var _a18;\n              return ((_a18 = toolInvocation.step) != null ? _a18 : 0) === i2;\n            }\n          );\n          if (stepInvocations.length === 0) {\n            continue;\n          }\n          coreMessages.push({\n            role: \"assistant\",\n            content: [\n              ...isLastMessage && content && i2 === 0 ? [{ type: \"text\", text: content }] : [],\n              ...stepInvocations.map(\n                ({ toolCallId, toolName, args }) => ({\n                  type: \"tool-call\",\n                  toolCallId,\n                  toolName,\n                  args\n                })\n              )\n            ]\n          });\n          coreMessages.push({\n            role: \"tool\",\n            content: stepInvocations.map((toolInvocation) => {\n              if (!(\"result\" in toolInvocation)) {\n                throw new MessageConversionError({\n                  originalMessage: message,\n                  message: \"ToolInvocation must have a result: \" + JSON.stringify(toolInvocation)\n                });\n              }\n              const { toolCallId, toolName, result } = toolInvocation;\n              const tool2 = tools[toolName];\n              return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {\n                type: \"tool-result\",\n                toolCallId,\n                toolName,\n                result: tool2.experimental_toToolResultContent(result),\n                experimental_content: tool2.experimental_toToolResultContent(result)\n              } : {\n                type: \"tool-result\",\n                toolCallId,\n                toolName,\n                result\n              };\n            })\n          });\n        }\n        if (content && !isLastMessage) {\n          coreMessages.push({ role: \"assistant\", content });\n        }\n        break;\n      }\n      case \"data\": {\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = role;\n        throw new MessageConversionError({\n          originalMessage: message,\n          message: `Unsupported role: ${_exhaustiveCheck}`\n        });\n      }\n    }\n  }\n  return coreMessages;\n}\n\n// core/prompt/message.ts\n\n\n// core/types/provider-metadata.ts\n\n\n// core/types/json-value.ts\n\nvar jsonValueSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.lazy(\n  () => zod__WEBPACK_IMPORTED_MODULE_5__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_5__.z[\"null\"](),\n    zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n    zod__WEBPACK_IMPORTED_MODULE_5__.z.number(),\n    zod__WEBPACK_IMPORTED_MODULE_5__.z.boolean(),\n    zod__WEBPACK_IMPORTED_MODULE_5__.z.record(zod__WEBPACK_IMPORTED_MODULE_5__.z.string(), jsonValueSchema),\n    zod__WEBPACK_IMPORTED_MODULE_5__.z.array(jsonValueSchema)\n  ])\n);\n\n// core/types/provider-metadata.ts\nvar providerMetadataSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.record(\n  zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n  zod__WEBPACK_IMPORTED_MODULE_5__.z.record(zod__WEBPACK_IMPORTED_MODULE_5__.z.string(), jsonValueSchema)\n);\n\n// core/prompt/content-part.ts\n\n\n// core/prompt/tool-result-content.ts\n\nvar toolResultContentSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.array(\n  zod__WEBPACK_IMPORTED_MODULE_5__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_5__.z.object({ type: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(\"text\"), text: zod__WEBPACK_IMPORTED_MODULE_5__.z.string() }),\n    zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n      type: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(\"image\"),\n      data: zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n      mimeType: zod__WEBPACK_IMPORTED_MODULE_5__.z.string().optional()\n    })\n  ])\n);\n\n// core/prompt/content-part.ts\nvar textPartSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(\"text\"),\n  text: zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(\"image\"),\n  image: zod__WEBPACK_IMPORTED_MODULE_5__.z.union([dataContentSchema, zod__WEBPACK_IMPORTED_MODULE_5__.z[\"instanceof\"](URL)]),\n  mimeType: zod__WEBPACK_IMPORTED_MODULE_5__.z.string().optional(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar filePartSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(\"file\"),\n  data: zod__WEBPACK_IMPORTED_MODULE_5__.z.union([dataContentSchema, zod__WEBPACK_IMPORTED_MODULE_5__.z[\"instanceof\"](URL)]),\n  filename: zod__WEBPACK_IMPORTED_MODULE_5__.z.string().optional(),\n  mimeType: zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar reasoningPartSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(\"reasoning\"),\n  text: zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar redactedReasoningPartSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(\"redacted-reasoning\"),\n  data: zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(\"tool-call\"),\n  toolCallId: zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n  toolName: zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n  args: zod__WEBPACK_IMPORTED_MODULE_5__.z.unknown(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar toolResultPartSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(\"tool-result\"),\n  toolCallId: zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n  toolName: zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n  result: zod__WEBPACK_IMPORTED_MODULE_5__.z.unknown(),\n  content: toolResultContentSchema.optional(),\n  isError: zod__WEBPACK_IMPORTED_MODULE_5__.z.boolean().optional(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\n\n// core/prompt/message.ts\nvar coreSystemMessageSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(\"system\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreUserMessageSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(\"user\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_5__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n    zod__WEBPACK_IMPORTED_MODULE_5__.z.array(zod__WEBPACK_IMPORTED_MODULE_5__.z.union([textPartSchema, imagePartSchema, filePartSchema]))\n  ]),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreAssistantMessageSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(\"assistant\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_5__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n    zod__WEBPACK_IMPORTED_MODULE_5__.z.array(\n      zod__WEBPACK_IMPORTED_MODULE_5__.z.union([\n        textPartSchema,\n        filePartSchema,\n        reasoningPartSchema,\n        redactedReasoningPartSchema,\n        toolCallPartSchema\n      ])\n    )\n  ]),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreToolMessageSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(\"tool\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_5__.z.array(toolResultPartSchema),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreMessageSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.union([\n  coreSystemMessageSchema,\n  coreUserMessageSchema,\n  coreAssistantMessageSchema,\n  coreToolMessageSchema\n]);\n\n// core/prompt/standardize-prompt.ts\nfunction standardizePrompt({\n  prompt,\n  tools\n}) {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: \"prompt and messages cannot be defined at the same time\"\n    });\n  }\n  if (prompt.system != null && typeof prompt.system !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: \"system must be a string\"\n    });\n  }\n  if (prompt.prompt != null) {\n    if (typeof prompt.prompt !== \"string\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n        prompt,\n        message: \"prompt must be a string\"\n      });\n    }\n    return {\n      type: \"prompt\",\n      system: prompt.system,\n      messages: [\n        {\n          role: \"user\",\n          content: prompt.prompt\n        }\n      ]\n    };\n  }\n  if (prompt.messages != null) {\n    const promptType = detectPromptType(prompt.messages);\n    const messages = promptType === \"ui-messages\" ? convertToCoreMessages(prompt.messages, {\n      tools\n    }) : prompt.messages;\n    if (messages.length === 0) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n        prompt,\n        message: \"messages must not be empty\"\n      });\n    }\n    const validationResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n      value: messages,\n      schema: zod__WEBPACK_IMPORTED_MODULE_5__.z.array(coreMessageSchema)\n    });\n    if (!validationResult.success) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n        prompt,\n        message: [\n          \"message must be a CoreMessage or a UI message\",\n          `Validation error: ${validationResult.error.message}`\n        ].join(\"\\n\"),\n        cause: validationResult.error\n      });\n    }\n    return {\n      type: \"messages\",\n      messages,\n      system: prompt.system\n    };\n  }\n  throw new Error(\"unreachable\");\n}\nfunction detectPromptType(prompt) {\n  if (!Array.isArray(prompt)) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: [\n        \"messages must be an array of CoreMessage or UIMessage\",\n        `Received non-array value: ${JSON.stringify(prompt)}`\n      ].join(\"\\n\"),\n      cause: prompt\n    });\n  }\n  if (prompt.length === 0) {\n    return \"messages\";\n  }\n  const characteristics = prompt.map(detectSingleMessageCharacteristics);\n  if (characteristics.some((c) => c === \"has-ui-specific-parts\")) {\n    return \"ui-messages\";\n  }\n  const nonMessageIndex = characteristics.findIndex(\n    (c) => c !== \"has-core-specific-parts\" && c !== \"message\"\n  );\n  if (nonMessageIndex === -1) {\n    return \"messages\";\n  }\n  throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n    prompt,\n    message: [\n      \"messages must be an array of CoreMessage or UIMessage\",\n      `Received message of type: \"${characteristics[nonMessageIndex]}\" at index ${nonMessageIndex}`,\n      `messages[${nonMessageIndex}]: ${JSON.stringify(prompt[nonMessageIndex])}`\n    ].join(\"\\n\"),\n    cause: prompt\n  });\n}\nfunction detectSingleMessageCharacteristics(message) {\n  if (typeof message === \"object\" && message !== null && (message.role === \"function\" || // UI-only role\n  message.role === \"data\" || // UI-only role\n  \"toolInvocations\" in message || // UI-specific field\n  \"parts\" in message || // UI-specific field\n  \"experimental_attachments\" in message)) {\n    return \"has-ui-specific-parts\";\n  } else if (typeof message === \"object\" && message !== null && \"content\" in message && (Array.isArray(message.content) || // Core messages can have array content\n  \"experimental_providerMetadata\" in message || \"providerOptions\" in message)) {\n    return \"has-core-specific-parts\";\n  } else if (typeof message === \"object\" && message !== null && \"role\" in message && \"content\" in message && typeof message.content === \"string\" && [\"system\", \"user\", \"assistant\", \"tool\"].includes(message.role)) {\n    return \"message\";\n  } else {\n    return \"other\";\n  }\n}\n\n// core/types/usage.ts\nfunction calculateLanguageModelUsage({\n  promptTokens,\n  completionTokens\n}) {\n  return {\n    promptTokens,\n    completionTokens,\n    totalTokens: promptTokens + completionTokens\n  };\n}\nfunction addLanguageModelUsage(usage1, usage2) {\n  return {\n    promptTokens: usage1.promptTokens + usage2.promptTokens,\n    completionTokens: usage1.completionTokens + usage2.completionTokens,\n    totalTokens: usage1.totalTokens + usage2.totalTokens\n  };\n}\n\n// core/generate-object/inject-json-instruction.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nvar DEFAULT_GENERIC_SUFFIX = \"You MUST answer with JSON.\";\nfunction injectJsonInstruction({\n  prompt,\n  schema,\n  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0,\n  schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX\n}) {\n  return [\n    prompt != null && prompt.length > 0 ? prompt : void 0,\n    prompt != null && prompt.length > 0 ? \"\" : void 0,\n    // add a newline if prompt is not null\n    schemaPrefix,\n    schema != null ? JSON.stringify(schema) : void 0,\n    schemaSuffix\n  ].filter((line) => line != null).join(\"\\n\");\n}\n\n// core/generate-object/output-strategy.ts\n\n\n\n\n// core/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source) {\n  const stream = source.pipeThrough(new TransformStream());\n  stream[Symbol.asyncIterator] = () => {\n    const reader = stream.getReader();\n    return {\n      async next() {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: void 0 } : { done: false, value };\n      }\n    };\n  };\n  return stream;\n}\n\n// core/generate-object/output-strategy.ts\nvar noSchemaOutputStrategy = {\n  type: \"no-schema\",\n  jsonSchema: void 0,\n  validatePartialResult({ value, textDelta }) {\n    return { success: true, value: { partial: value, textDelta } };\n  },\n  validateFinalResult(value, context) {\n    return value === void 0 ? {\n      success: false,\n      error: new NoObjectGeneratedError({\n        message: \"No object generated: response did not match schema.\",\n        text: context.text,\n        response: context.response,\n        usage: context.usage,\n        finishReason: context.finishReason\n      })\n    } : { success: true, value };\n  },\n  createElementStream() {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n      functionality: \"element streams in no-schema mode\"\n    });\n  }\n};\nvar objectOutputStrategy = (schema) => ({\n  type: \"object\",\n  jsonSchema: schema.jsonSchema,\n  validatePartialResult({ value, textDelta }) {\n    return {\n      success: true,\n      value: {\n        // Note: currently no validation of partial results:\n        partial: value,\n        textDelta\n      }\n    };\n  },\n  validateFinalResult(value) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value, schema });\n  },\n  createElementStream() {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n      functionality: \"element streams in object mode\"\n    });\n  }\n});\nvar arrayOutputStrategy = (schema) => {\n  const { $schema, ...itemSchema } = schema.jsonSchema;\n  return {\n    type: \"enum\",\n    // wrap in object that contains array of elements, since most LLMs will not\n    // be able to generate an array directly:\n    // possible future optimization: use arrays directly when model supports grammar-guided generation\n    jsonSchema: {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        elements: { type: \"array\", items: itemSchema }\n      },\n      required: [\"elements\"],\n      additionalProperties: false\n    },\n    validatePartialResult({ value, latestObject, isFirstDelta, isFinalDelta }) {\n      var _a17;\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.isJSONArray)(value.elements)) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      const resultArray = [];\n      for (let i = 0; i < inputArray.length; i++) {\n        const element = inputArray[i];\n        const result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: element, schema });\n        if (i === inputArray.length - 1 && !isFinalDelta) {\n          continue;\n        }\n        if (!result.success) {\n          return result;\n        }\n        resultArray.push(result.value);\n      }\n      const publishedElementCount = (_a17 = latestObject == null ? void 0 : latestObject.length) != null ? _a17 : 0;\n      let textDelta = \"\";\n      if (isFirstDelta) {\n        textDelta += \"[\";\n      }\n      if (publishedElementCount > 0) {\n        textDelta += \",\";\n      }\n      textDelta += resultArray.slice(publishedElementCount).map((element) => JSON.stringify(element)).join(\",\");\n      if (isFinalDelta) {\n        textDelta += \"]\";\n      }\n      return {\n        success: true,\n        value: {\n          partial: resultArray,\n          textDelta\n        }\n      };\n    },\n    validateFinalResult(value) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.isJSONArray)(value.elements)) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      for (const element of inputArray) {\n        const result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: element, schema });\n        if (!result.success) {\n          return result;\n        }\n      }\n      return { success: true, value: inputArray };\n    },\n    createElementStream(originalStream) {\n      let publishedElements = 0;\n      return createAsyncIterableStream(\n        originalStream.pipeThrough(\n          new TransformStream({\n            transform(chunk, controller) {\n              switch (chunk.type) {\n                case \"object\": {\n                  const array = chunk.object;\n                  for (; publishedElements < array.length; publishedElements++) {\n                    controller.enqueue(array[publishedElements]);\n                  }\n                  break;\n                }\n                case \"text-delta\":\n                case \"finish\":\n                case \"error\":\n                  break;\n                default: {\n                  const _exhaustiveCheck = chunk;\n                  throw new Error(\n                    `Unsupported chunk type: ${_exhaustiveCheck}`\n                  );\n                }\n              }\n            }\n          })\n        )\n      );\n    }\n  };\n};\nvar enumOutputStrategy = (enumValues) => {\n  return {\n    type: \"enum\",\n    // wrap in object that contains result, since most LLMs will not\n    // be able to generate an enum value directly:\n    // possible future optimization: use enums directly when model supports top-level enums\n    jsonSchema: {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        result: { type: \"string\", enum: enumValues }\n      },\n      required: [\"result\"],\n      additionalProperties: false\n    },\n    validateFinalResult(value) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.isJSONObject)(value) || typeof value.result !== \"string\") {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError({\n            value,\n            cause: 'value must be an object that contains a string in the \"result\" property.'\n          })\n        };\n      }\n      const result = value.result;\n      return enumValues.includes(result) ? { success: true, value: result } : {\n        success: false,\n        error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError({\n          value,\n          cause: \"value must be a string in the enum\"\n        })\n      };\n    },\n    validatePartialResult() {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n        functionality: \"partial results in enum mode\"\n      });\n    },\n    createElementStream() {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n        functionality: \"element streams in enum mode\"\n      });\n    }\n  };\n};\nfunction getOutputStrategy({\n  output,\n  schema,\n  enumValues\n}) {\n  switch (output) {\n    case \"object\":\n      return objectOutputStrategy((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(schema));\n    case \"array\":\n      return arrayOutputStrategy((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(schema));\n    case \"enum\":\n      return enumOutputStrategy(enumValues);\n    case \"no-schema\":\n      return noSchemaOutputStrategy;\n    default: {\n      const _exhaustiveCheck = output;\n      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n    }\n  }\n}\n\n// core/generate-object/validate-object-generation-input.ts\nfunction validateObjectGenerationInput({\n  output,\n  mode,\n  schema,\n  schemaName,\n  schemaDescription,\n  enumValues\n}) {\n  if (output != null && output !== \"object\" && output !== \"array\" && output !== \"enum\" && output !== \"no-schema\") {\n    throw new InvalidArgumentError({\n      parameter: \"output\",\n      value: output,\n      message: \"Invalid output type.\"\n    });\n  }\n  if (output === \"no-schema\") {\n    if (mode === \"auto\" || mode === \"tool\") {\n      throw new InvalidArgumentError({\n        parameter: \"mode\",\n        value: mode,\n        message: 'Mode must be \"json\" for no-schema output.'\n      });\n    }\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for no-schema output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for no-schema output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for no-schema output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for no-schema output.\"\n      });\n    }\n  }\n  if (output === \"object\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is required for object output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for object output.\"\n      });\n    }\n  }\n  if (output === \"array\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Element schema is required for array output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for array output.\"\n      });\n    }\n  }\n  if (output === \"enum\") {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for enum output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for enum output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for enum output.\"\n      });\n    }\n    if (enumValues == null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are required for enum output.\"\n      });\n    }\n    for (const value of enumValues) {\n      if (typeof value !== \"string\") {\n        throw new InvalidArgumentError({\n          parameter: \"enumValues\",\n          value,\n          message: \"Enum values must be strings.\"\n        });\n      }\n    }\n  }\n}\n\n// core/prompt/stringify-for-telemetry.ts\nfunction stringifyForTelemetry(prompt) {\n  const processedPrompt = prompt.map((message) => {\n    return {\n      ...message,\n      content: typeof message.content === \"string\" ? message.content : message.content.map(processPart)\n    };\n  });\n  return JSON.stringify(processedPrompt);\n}\nfunction processPart(part) {\n  if (part.type === \"image\") {\n    return {\n      ...part,\n      image: part.image instanceof Uint8Array ? convertDataContentToBase64String(part.image) : part.image\n    };\n  }\n  return part;\n}\n\n// core/generate-object/generate-object.ts\nvar originalGenerateId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({ prefix: \"aiobj\", size: 24 });\nasync function generateObject({\n  model,\n  enum: enumValues,\n  // rename bc enum is reserved by typescript\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = \"object\",\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_repairText: repairText,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  _internal: {\n    generateId: generateId3 = originalGenerateId,\n    currentDate = () => /* @__PURE__ */ new Date()\n  } = {},\n  ...settings\n}) {\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues\n  });\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues\n  });\n  if (outputStrategy.type === \"no-schema\" && mode === void 0) {\n    mode = \"json\";\n  }\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.generateObject\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: \"ai.generateObject\",\n          telemetry\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        },\n        \"ai.schema\": outputStrategy.jsonSchema != null ? { input: () => JSON.stringify(outputStrategy.jsonSchema) } : void 0,\n        \"ai.schema.name\": schemaName,\n        \"ai.schema.description\": schemaDescription,\n        \"ai.settings.output\": outputStrategy.type,\n        \"ai.settings.mode\": mode\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      var _a17, _b, _c, _d;\n      if (mode === \"auto\" || mode == null) {\n        mode = model.defaultObjectGenerationMode;\n      }\n      let result;\n      let finishReason;\n      let usage;\n      let warnings;\n      let rawResponse;\n      let response;\n      let request;\n      let logprobs;\n      let resultProviderMetadata;\n      switch (mode) {\n        case \"json\": {\n          const standardizedPrompt = standardizePrompt({\n            prompt: {\n              system: outputStrategy.jsonSchema == null ? injectJsonInstruction({ prompt: system }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({\n                prompt: system,\n                schema: outputStrategy.jsonSchema\n              }),\n              prompt,\n              messages\n            },\n            tools: void 0\n          });\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: (_a17 = model.supportsUrl) == null ? void 0 : _a17.bind(model)\n            // support 'this' context\n          });\n          const generateResult = await retry(\n            () => recordSpan({\n              name: \"ai.generateObject.doGenerate\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: \"ai.generateObject.doGenerate\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  \"ai.prompt.format\": {\n                    input: () => standardizedPrompt.type\n                  },\n                  \"ai.prompt.messages\": {\n                    input: () => JSON.stringify(promptMessages)\n                  },\n                  \"ai.settings.mode\": mode,\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.system\": model.provider,\n                  \"gen_ai.request.model\": model.modelId,\n                  \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                  \"gen_ai.request.max_tokens\": settings.maxTokens,\n                  \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                  \"gen_ai.request.temperature\": settings.temperature,\n                  \"gen_ai.request.top_k\": settings.topK,\n                  \"gen_ai.request.top_p\": settings.topP\n                }\n              }),\n              tracer,\n              fn: async (span2) => {\n                var _a18, _b2, _c2, _d2, _e, _f;\n                const result2 = await model.doGenerate({\n                  mode: {\n                    type: \"object-json\",\n                    schema: outputStrategy.jsonSchema,\n                    name: schemaName,\n                    description: schemaDescription\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat: standardizedPrompt.type,\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers\n                });\n                const responseData = {\n                  id: (_b2 = (_a18 = result2.response) == null ? void 0 : _a18.id) != null ? _b2 : generateId3(),\n                  timestamp: (_d2 = (_c2 = result2.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),\n                  modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId\n                };\n                if (result2.text === void 0) {\n                  throw new NoObjectGeneratedError({\n                    message: \"No object generated: the model did not return a response.\",\n                    response: responseData,\n                    usage: calculateLanguageModelUsage(result2.usage),\n                    finishReason: result2.finishReason\n                  });\n                }\n                span2.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": result2.finishReason,\n                      \"ai.response.object\": { output: () => result2.text },\n                      \"ai.response.id\": responseData.id,\n                      \"ai.response.model\": responseData.modelId,\n                      \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                      \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                      \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [result2.finishReason],\n                      \"gen_ai.response.id\": responseData.id,\n                      \"gen_ai.response.model\": responseData.modelId,\n                      \"gen_ai.usage.prompt_tokens\": result2.usage.promptTokens,\n                      \"gen_ai.usage.completion_tokens\": result2.usage.completionTokens\n                    }\n                  })\n                );\n                return { ...result2, objectText: result2.text, responseData };\n              }\n            })\n          );\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          request = (_b = generateResult.request) != null ? _b : {};\n          response = generateResult.responseData;\n          break;\n        }\n        case \"tool\": {\n          const standardizedPrompt = standardizePrompt({\n            prompt: { system, prompt, messages },\n            tools: void 0\n          });\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: (_c = model.supportsUrl) == null ? void 0 : _c.bind(model)\n            // support 'this' context,\n          });\n          const inputFormat = standardizedPrompt.type;\n          const generateResult = await retry(\n            () => recordSpan({\n              name: \"ai.generateObject.doGenerate\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: \"ai.generateObject.doGenerate\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  \"ai.prompt.format\": {\n                    input: () => inputFormat\n                  },\n                  \"ai.prompt.messages\": {\n                    input: () => stringifyForTelemetry(promptMessages)\n                  },\n                  \"ai.settings.mode\": mode,\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.system\": model.provider,\n                  \"gen_ai.request.model\": model.modelId,\n                  \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                  \"gen_ai.request.max_tokens\": settings.maxTokens,\n                  \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                  \"gen_ai.request.temperature\": settings.temperature,\n                  \"gen_ai.request.top_k\": settings.topK,\n                  \"gen_ai.request.top_p\": settings.topP\n                }\n              }),\n              tracer,\n              fn: async (span2) => {\n                var _a18, _b2, _c2, _d2, _e, _f, _g, _h;\n                const result2 = await model.doGenerate({\n                  mode: {\n                    type: \"object-tool\",\n                    tool: {\n                      type: \"function\",\n                      name: schemaName != null ? schemaName : \"json\",\n                      description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                      parameters: outputStrategy.jsonSchema\n                    }\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat,\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers\n                });\n                const objectText = (_b2 = (_a18 = result2.toolCalls) == null ? void 0 : _a18[0]) == null ? void 0 : _b2.args;\n                const responseData = {\n                  id: (_d2 = (_c2 = result2.response) == null ? void 0 : _c2.id) != null ? _d2 : generateId3(),\n                  timestamp: (_f = (_e = result2.response) == null ? void 0 : _e.timestamp) != null ? _f : currentDate(),\n                  modelId: (_h = (_g = result2.response) == null ? void 0 : _g.modelId) != null ? _h : model.modelId\n                };\n                if (objectText === void 0) {\n                  throw new NoObjectGeneratedError({\n                    message: \"No object generated: the tool was not called.\",\n                    response: responseData,\n                    usage: calculateLanguageModelUsage(result2.usage),\n                    finishReason: result2.finishReason\n                  });\n                }\n                span2.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": result2.finishReason,\n                      \"ai.response.object\": { output: () => objectText },\n                      \"ai.response.id\": responseData.id,\n                      \"ai.response.model\": responseData.modelId,\n                      \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                      \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                      \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [result2.finishReason],\n                      \"gen_ai.response.id\": responseData.id,\n                      \"gen_ai.response.model\": responseData.modelId,\n                      \"gen_ai.usage.input_tokens\": result2.usage.promptTokens,\n                      \"gen_ai.usage.output_tokens\": result2.usage.completionTokens\n                    }\n                  })\n                );\n                return { ...result2, objectText, responseData };\n              }\n            })\n          );\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          request = (_d = generateResult.request) != null ? _d : {};\n          response = generateResult.responseData;\n          break;\n        }\n        case void 0: {\n          throw new Error(\n            \"Model does not have a default object generation mode.\"\n          );\n        }\n        default: {\n          const _exhaustiveCheck = mode;\n          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n        }\n      }\n      function processResult(result2) {\n        const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: result2 });\n        if (!parseResult.success) {\n          throw new NoObjectGeneratedError({\n            message: \"No object generated: could not parse the response.\",\n            cause: parseResult.error,\n            text: result2,\n            response,\n            usage: calculateLanguageModelUsage(usage),\n            finishReason\n          });\n        }\n        const validationResult = outputStrategy.validateFinalResult(\n          parseResult.value,\n          {\n            text: result2,\n            response,\n            usage: calculateLanguageModelUsage(usage)\n          }\n        );\n        if (!validationResult.success) {\n          throw new NoObjectGeneratedError({\n            message: \"No object generated: response did not match schema.\",\n            cause: validationResult.error,\n            text: result2,\n            response,\n            usage: calculateLanguageModelUsage(usage),\n            finishReason\n          });\n        }\n        return validationResult.value;\n      }\n      let object2;\n      try {\n        object2 = processResult(result);\n      } catch (error) {\n        if (repairText != null && NoObjectGeneratedError.isInstance(error) && (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isInstance(error.cause) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.isInstance(error.cause))) {\n          const repairedText = await repairText({\n            text: result,\n            error: error.cause\n          });\n          if (repairedText === null) {\n            throw error;\n          }\n          object2 = processResult(repairedText);\n        } else {\n          throw error;\n        }\n      }\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.response.finishReason\": finishReason,\n            \"ai.response.object\": {\n              output: () => JSON.stringify(object2)\n            },\n            \"ai.usage.promptTokens\": usage.promptTokens,\n            \"ai.usage.completionTokens\": usage.completionTokens\n          }\n        })\n      );\n      return new DefaultGenerateObjectResult({\n        object: object2,\n        finishReason,\n        usage: calculateLanguageModelUsage(usage),\n        warnings,\n        request,\n        response: {\n          ...response,\n          headers: rawResponse == null ? void 0 : rawResponse.headers,\n          body: rawResponse == null ? void 0 : rawResponse.body\n        },\n        logprobs,\n        providerMetadata: resultProviderMetadata\n      });\n    }\n  });\n}\nvar DefaultGenerateObjectResult = class {\n  constructor(options) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.experimental_providerMetadata = options.providerMetadata;\n    this.response = options.response;\n    this.request = options.request;\n    this.logprobs = options.logprobs;\n  }\n  toJsonResponse(init) {\n    var _a17;\n    return new Response(JSON.stringify(this.object), {\n      status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,\n      headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {\n        contentType: \"application/json; charset=utf-8\"\n      })\n    });\n  }\n};\n\n// core/generate-object/stream-object.ts\n\n\n\n// util/delayed-promise.ts\nvar DelayedPromise = class {\n  constructor() {\n    this.status = { type: \"pending\" };\n    this._resolve = void 0;\n    this._reject = void 0;\n  }\n  get value() {\n    if (this.promise) {\n      return this.promise;\n    }\n    this.promise = new Promise((resolve, reject) => {\n      if (this.status.type === \"resolved\") {\n        resolve(this.status.value);\n      } else if (this.status.type === \"rejected\") {\n        reject(this.status.error);\n      }\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n    return this.promise;\n  }\n  resolve(value) {\n    var _a17;\n    this.status = { type: \"resolved\", value };\n    if (this.promise) {\n      (_a17 = this._resolve) == null ? void 0 : _a17.call(this, value);\n    }\n  }\n  reject(error) {\n    var _a17;\n    this.status = { type: \"rejected\", error };\n    if (this.promise) {\n      (_a17 = this._reject) == null ? void 0 : _a17.call(this, error);\n    }\n  }\n};\n\n// util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return {\n    promise,\n    resolve,\n    reject\n  };\n}\n\n// core/util/create-stitchable-stream.ts\nfunction createStitchableStream() {\n  let innerStreamReaders = [];\n  let controller = null;\n  let isClosed = false;\n  let waitForNewStream = createResolvablePromise();\n  const processPull = async () => {\n    if (isClosed && innerStreamReaders.length === 0) {\n      controller == null ? void 0 : controller.close();\n      return;\n    }\n    if (innerStreamReaders.length === 0) {\n      waitForNewStream = createResolvablePromise();\n      await waitForNewStream.promise;\n      return processPull();\n    }\n    try {\n      const { value, done } = await innerStreamReaders[0].read();\n      if (done) {\n        innerStreamReaders.shift();\n        if (innerStreamReaders.length > 0) {\n          await processPull();\n        } else if (isClosed) {\n          controller == null ? void 0 : controller.close();\n        }\n      } else {\n        controller == null ? void 0 : controller.enqueue(value);\n      }\n    } catch (error) {\n      controller == null ? void 0 : controller.error(error);\n      innerStreamReaders.shift();\n      if (isClosed && innerStreamReaders.length === 0) {\n        controller == null ? void 0 : controller.close();\n      }\n    }\n  };\n  return {\n    stream: new ReadableStream({\n      start(controllerParam) {\n        controller = controllerParam;\n      },\n      pull: processPull,\n      async cancel() {\n        for (const reader of innerStreamReaders) {\n          await reader.cancel();\n        }\n        innerStreamReaders = [];\n        isClosed = true;\n      }\n    }),\n    addStream: (innerStream) => {\n      if (isClosed) {\n        throw new Error(\"Cannot add inner stream: outer stream is closed\");\n      }\n      innerStreamReaders.push(innerStream.getReader());\n      waitForNewStream.resolve();\n    },\n    /**\n     * Gracefully close the outer stream. This will let the inner streams\n     * finish processing and then close the outer stream.\n     */\n    close: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n      if (innerStreamReaders.length === 0) {\n        controller == null ? void 0 : controller.close();\n      }\n    },\n    /**\n     * Immediately close the outer stream. This will cancel all inner streams\n     * and close the outer stream.\n     */\n    terminate: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n      innerStreamReaders.forEach((reader) => reader.cancel());\n      innerStreamReaders = [];\n      controller == null ? void 0 : controller.close();\n    }\n  };\n}\n\n// core/util/now.ts\nfunction now() {\n  var _a17, _b;\n  return (_b = (_a17 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a17.now()) != null ? _b : Date.now();\n}\n\n// core/generate-object/stream-object.ts\nvar originalGenerateId2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({ prefix: \"aiobj\", size: 24 });\nfunction streamObject({\n  model,\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = \"object\",\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  onError,\n  onFinish,\n  _internal: {\n    generateId: generateId3 = originalGenerateId2,\n    currentDate = () => /* @__PURE__ */ new Date(),\n    now: now2 = now\n  } = {},\n  ...settings\n}) {\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription\n  });\n  const outputStrategy = getOutputStrategy({ output, schema: inputSchema });\n  if (outputStrategy.type === \"no-schema\" && mode === void 0) {\n    mode = \"json\";\n  }\n  return new DefaultStreamObjectResult({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    mode,\n    onError,\n    onFinish,\n    generateId: generateId3,\n    currentDate,\n    now: now2\n  });\n}\nvar DefaultStreamObjectResult = class {\n  constructor({\n    model,\n    headers,\n    telemetry,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    mode,\n    onError,\n    onFinish,\n    generateId: generateId3,\n    currentDate,\n    now: now2\n  }) {\n    this.objectPromise = new DelayedPromise();\n    this.usagePromise = new DelayedPromise();\n    this.providerMetadataPromise = new DelayedPromise();\n    this.warningsPromise = new DelayedPromise();\n    this.requestPromise = new DelayedPromise();\n    this.responsePromise = new DelayedPromise();\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg\n    });\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...settings, maxRetries }\n    });\n    const tracer = getTracer(telemetry);\n    const self = this;\n    const stitchableStream = createStitchableStream();\n    const eventProcessor = new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n        if (chunk.type === \"error\") {\n          onError == null ? void 0 : onError({ error: chunk.error });\n        }\n      }\n    });\n    this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);\n    recordSpan({\n      name: \"ai.streamObject\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.streamObject\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          },\n          \"ai.schema\": outputStrategy.jsonSchema != null ? { input: () => JSON.stringify(outputStrategy.jsonSchema) } : void 0,\n          \"ai.schema.name\": schemaName,\n          \"ai.schema.description\": schemaDescription,\n          \"ai.settings.output\": outputStrategy.type,\n          \"ai.settings.mode\": mode\n        }\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async (rootSpan) => {\n        var _a17, _b;\n        if (mode === \"auto\" || mode == null) {\n          mode = model.defaultObjectGenerationMode;\n        }\n        let callOptions;\n        let transformer;\n        switch (mode) {\n          case \"json\": {\n            const standardizedPrompt = standardizePrompt({\n              prompt: {\n                system: outputStrategy.jsonSchema == null ? injectJsonInstruction({ prompt: system }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({\n                  prompt: system,\n                  schema: outputStrategy.jsonSchema\n                }),\n                prompt,\n                messages\n              },\n              tools: void 0\n            });\n            callOptions = {\n              mode: {\n                type: \"object-json\",\n                schema: outputStrategy.jsonSchema,\n                name: schemaName,\n                description: schemaDescription\n              },\n              ...prepareCallSettings(settings),\n              inputFormat: standardizedPrompt.type,\n              prompt: await convertToLanguageModelPrompt({\n                prompt: standardizedPrompt,\n                modelSupportsImageUrls: model.supportsImageUrls,\n                modelSupportsUrl: (_a17 = model.supportsUrl) == null ? void 0 : _a17.bind(model)\n                // support 'this' context\n              }),\n              providerMetadata: providerOptions,\n              abortSignal,\n              headers\n            };\n            transformer = {\n              transform: (chunk, controller) => {\n                switch (chunk.type) {\n                  case \"text-delta\":\n                    controller.enqueue(chunk.textDelta);\n                    break;\n                  case \"response-metadata\":\n                  case \"finish\":\n                  case \"error\":\n                    controller.enqueue(chunk);\n                    break;\n                }\n              }\n            };\n            break;\n          }\n          case \"tool\": {\n            const standardizedPrompt = standardizePrompt({\n              prompt: { system, prompt, messages },\n              tools: void 0\n            });\n            callOptions = {\n              mode: {\n                type: \"object-tool\",\n                tool: {\n                  type: \"function\",\n                  name: schemaName != null ? schemaName : \"json\",\n                  description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                  parameters: outputStrategy.jsonSchema\n                }\n              },\n              ...prepareCallSettings(settings),\n              inputFormat: standardizedPrompt.type,\n              prompt: await convertToLanguageModelPrompt({\n                prompt: standardizedPrompt,\n                modelSupportsImageUrls: model.supportsImageUrls,\n                modelSupportsUrl: (_b = model.supportsUrl) == null ? void 0 : _b.bind(model)\n                // support 'this' context,\n              }),\n              providerMetadata: providerOptions,\n              abortSignal,\n              headers\n            };\n            transformer = {\n              transform(chunk, controller) {\n                switch (chunk.type) {\n                  case \"tool-call-delta\":\n                    controller.enqueue(chunk.argsTextDelta);\n                    break;\n                  case \"response-metadata\":\n                  case \"finish\":\n                  case \"error\":\n                    controller.enqueue(chunk);\n                    break;\n                }\n              }\n            };\n            break;\n          }\n          case void 0: {\n            throw new Error(\n              \"Model does not have a default object generation mode.\"\n            );\n          }\n          default: {\n            const _exhaustiveCheck = mode;\n            throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n          }\n        }\n        const {\n          result: { stream, warnings, rawResponse, request },\n          doStreamSpan,\n          startTimestampMs\n        } = await retry(\n          () => recordSpan({\n            name: \"ai.streamObject.doStream\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.streamObject.doStream\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.format\": {\n                  input: () => callOptions.inputFormat\n                },\n                \"ai.prompt.messages\": {\n                  input: () => stringifyForTelemetry(callOptions.prompt)\n                },\n                \"ai.settings.mode\": mode,\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                \"gen_ai.request.temperature\": settings.temperature,\n                \"gen_ai.request.top_k\": settings.topK,\n                \"gen_ai.request.top_p\": settings.topP\n              }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async (doStreamSpan2) => ({\n              startTimestampMs: now2(),\n              doStreamSpan: doStreamSpan2,\n              result: await model.doStream(callOptions)\n            })\n          })\n        );\n        self.requestPromise.resolve(request != null ? request : {});\n        let usage;\n        let finishReason;\n        let providerMetadata;\n        let object2;\n        let error;\n        let accumulatedText = \"\";\n        let textDelta = \"\";\n        let response = {\n          id: generateId3(),\n          timestamp: currentDate(),\n          modelId: model.modelId\n        };\n        let latestObjectJson = void 0;\n        let latestObject = void 0;\n        let isFirstChunk = true;\n        let isFirstDelta = true;\n        const transformedStream = stream.pipeThrough(new TransformStream(transformer)).pipeThrough(\n          new TransformStream({\n            async transform(chunk, controller) {\n              var _a18, _b2, _c;\n              if (isFirstChunk) {\n                const msToFirstChunk = now2() - startTimestampMs;\n                isFirstChunk = false;\n                doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n                doStreamSpan.setAttributes({\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n              }\n              if (typeof chunk === \"string\") {\n                accumulatedText += chunk;\n                textDelta += chunk;\n                const { value: currentObjectJson, state: parseState } = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.parsePartialJson)(accumulatedText);\n                if (currentObjectJson !== void 0 && !(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.isDeepEqualData)(latestObjectJson, currentObjectJson)) {\n                  const validationResult = outputStrategy.validatePartialResult({\n                    value: currentObjectJson,\n                    textDelta,\n                    latestObject,\n                    isFirstDelta,\n                    isFinalDelta: parseState === \"successful-parse\"\n                  });\n                  if (validationResult.success && !(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.isDeepEqualData)(\n                    latestObject,\n                    validationResult.value.partial\n                  )) {\n                    latestObjectJson = currentObjectJson;\n                    latestObject = validationResult.value.partial;\n                    controller.enqueue({\n                      type: \"object\",\n                      object: latestObject\n                    });\n                    controller.enqueue({\n                      type: \"text-delta\",\n                      textDelta: validationResult.value.textDelta\n                    });\n                    textDelta = \"\";\n                    isFirstDelta = false;\n                  }\n                }\n                return;\n              }\n              switch (chunk.type) {\n                case \"response-metadata\": {\n                  response = {\n                    id: (_a18 = chunk.id) != null ? _a18 : response.id,\n                    timestamp: (_b2 = chunk.timestamp) != null ? _b2 : response.timestamp,\n                    modelId: (_c = chunk.modelId) != null ? _c : response.modelId\n                  };\n                  break;\n                }\n                case \"finish\": {\n                  if (textDelta !== \"\") {\n                    controller.enqueue({ type: \"text-delta\", textDelta });\n                  }\n                  finishReason = chunk.finishReason;\n                  usage = calculateLanguageModelUsage(chunk.usage);\n                  providerMetadata = chunk.providerMetadata;\n                  controller.enqueue({ ...chunk, usage, response });\n                  self.usagePromise.resolve(usage);\n                  self.providerMetadataPromise.resolve(providerMetadata);\n                  self.responsePromise.resolve({\n                    ...response,\n                    headers: rawResponse == null ? void 0 : rawResponse.headers\n                  });\n                  const validationResult = outputStrategy.validateFinalResult(\n                    latestObjectJson,\n                    {\n                      text: accumulatedText,\n                      response,\n                      usage\n                    }\n                  );\n                  if (validationResult.success) {\n                    object2 = validationResult.value;\n                    self.objectPromise.resolve(object2);\n                  } else {\n                    error = new NoObjectGeneratedError({\n                      message: \"No object generated: response did not match schema.\",\n                      cause: validationResult.error,\n                      text: accumulatedText,\n                      response,\n                      usage,\n                      finishReason\n                    });\n                    self.objectPromise.reject(error);\n                  }\n                  break;\n                }\n                default: {\n                  controller.enqueue(chunk);\n                  break;\n                }\n              }\n            },\n            // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n            async flush(controller) {\n              try {\n                const finalUsage = usage != null ? usage : {\n                  promptTokens: NaN,\n                  completionTokens: NaN,\n                  totalTokens: NaN\n                };\n                doStreamSpan.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": finishReason,\n                      \"ai.response.object\": {\n                        output: () => JSON.stringify(object2)\n                      },\n                      \"ai.response.id\": response.id,\n                      \"ai.response.model\": response.modelId,\n                      \"ai.response.timestamp\": response.timestamp.toISOString(),\n                      \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                      \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [finishReason],\n                      \"gen_ai.response.id\": response.id,\n                      \"gen_ai.response.model\": response.modelId,\n                      \"gen_ai.usage.input_tokens\": finalUsage.promptTokens,\n                      \"gen_ai.usage.output_tokens\": finalUsage.completionTokens\n                    }\n                  })\n                );\n                doStreamSpan.end();\n                rootSpan.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                      \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                      \"ai.response.object\": {\n                        output: () => JSON.stringify(object2)\n                      }\n                    }\n                  })\n                );\n                await (onFinish == null ? void 0 : onFinish({\n                  usage: finalUsage,\n                  object: object2,\n                  error,\n                  response: {\n                    ...response,\n                    headers: rawResponse == null ? void 0 : rawResponse.headers\n                  },\n                  warnings,\n                  providerMetadata,\n                  experimental_providerMetadata: providerMetadata\n                }));\n              } catch (error2) {\n                controller.enqueue({ type: \"error\", error: error2 });\n              } finally {\n                rootSpan.end();\n              }\n            }\n          })\n        );\n        stitchableStream.addStream(transformedStream);\n      }\n    }).catch((error) => {\n      stitchableStream.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: \"error\", error });\n            controller.close();\n          }\n        })\n      );\n    }).finally(() => {\n      stitchableStream.close();\n    });\n    this.outputStrategy = outputStrategy;\n  }\n  get object() {\n    return this.objectPromise.value;\n  }\n  get usage() {\n    return this.usagePromise.value;\n  }\n  get experimental_providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n  get providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n  get warnings() {\n    return this.warningsPromise.value;\n  }\n  get request() {\n    return this.requestPromise.value;\n  }\n  get response() {\n    return this.responsePromise.value;\n  }\n  get partialObjectStream() {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case \"object\":\n                controller.enqueue(chunk.object);\n                break;\n              case \"text-delta\":\n              case \"finish\":\n              case \"error\":\n                break;\n              default: {\n                const _exhaustiveCheck = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          }\n        })\n      )\n    );\n  }\n  get elementStream() {\n    return this.outputStrategy.createElementStream(this.baseStream);\n  }\n  get textStream() {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case \"text-delta\":\n                controller.enqueue(chunk.textDelta);\n                break;\n              case \"object\":\n              case \"finish\":\n              case \"error\":\n                break;\n              default: {\n                const _exhaustiveCheck = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          }\n        })\n      )\n    );\n  }\n  get fullStream() {\n    return createAsyncIterableStream(this.baseStream);\n  }\n  pipeTextStreamToResponse(response, init) {\n    writeToServerResponse({\n      response,\n      status: init == null ? void 0 : init.status,\n      statusText: init == null ? void 0 : init.statusText,\n      headers: prepareOutgoingHttpHeaders(init == null ? void 0 : init.headers, {\n        contentType: \"text/plain; charset=utf-8\"\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream())\n    });\n  }\n  toTextStreamResponse(init) {\n    var _a17;\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,\n      headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {\n        contentType: \"text/plain; charset=utf-8\"\n      })\n    });\n  }\n};\n\n// core/generate-text/generate-text.ts\n\n\n// errors/no-output-specified-error.ts\n\nvar name9 = \"AI_NoOutputSpecifiedError\";\nvar marker9 = `vercel.ai.error.${name9}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar NoOutputSpecifiedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  // used in isInstance\n  constructor({ message = \"No output specified.\" } = {}) {\n    super({ name: name9, message });\n    this[_a9] = true;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker9);\n  }\n};\n_a9 = symbol9;\n\n// errors/tool-execution-error.ts\n\nvar name10 = \"AI_ToolExecutionError\";\nvar marker10 = `vercel.ai.error.${name10}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar ToolExecutionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    toolArgs,\n    toolName,\n    toolCallId,\n    cause,\n    message = `Error executing tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(cause)}`\n  }) {\n    super({ name: name10, message, cause });\n    this[_a10] = true;\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n    this.toolCallId = toolCallId;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker10);\n  }\n};\n_a10 = symbol10;\n\n// core/prompt/prepare-tools-and-tool-choice.ts\n\n\n// core/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object2) {\n  return object2 != null && Object.keys(object2).length > 0;\n}\n\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({\n  tools,\n  toolChoice,\n  activeTools\n}) {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: void 0,\n      toolChoice: void 0\n    };\n  }\n  const filteredTools = activeTools != null ? Object.entries(tools).filter(\n    ([name17]) => activeTools.includes(name17)\n  ) : Object.entries(tools);\n  return {\n    tools: filteredTools.map(([name17, tool2]) => {\n      const toolType = tool2.type;\n      switch (toolType) {\n        case void 0:\n        case \"function\":\n          return {\n            type: \"function\",\n            name: name17,\n            description: tool2.description,\n            parameters: (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(tool2.parameters).jsonSchema\n          };\n        case \"provider-defined\":\n          return {\n            type: \"provider-defined\",\n            name: name17,\n            id: tool2.id,\n            args: tool2.args\n          };\n        default: {\n          const exhaustiveCheck = toolType;\n          throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n        }\n      }\n    }),\n    toolChoice: toolChoice == null ? { type: \"auto\" } : typeof toolChoice === \"string\" ? { type: toolChoice } : { type: \"tool\", toolName: toolChoice.toolName }\n  };\n}\n\n// core/util/split-on-last-whitespace.ts\nvar lastWhitespaceRegexp = /^([\\s\\S]*?)(\\s+)(\\S*)$/;\nfunction splitOnLastWhitespace(text2) {\n  const match = text2.match(lastWhitespaceRegexp);\n  return match ? { prefix: match[1], whitespace: match[2], suffix: match[3] } : void 0;\n}\n\n// core/util/remove-text-after-last-whitespace.ts\nfunction removeTextAfterLastWhitespace(text2) {\n  const match = splitOnLastWhitespace(text2);\n  return match ? match.prefix + match.whitespace : text2;\n}\n\n// core/generate-text/parse-tool-call.ts\n\n\n\n// errors/invalid-tool-arguments-error.ts\n\nvar name11 = \"AI_InvalidToolArgumentsError\";\nvar marker11 = `vercel.ai.error.${name11}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar InvalidToolArgumentsError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    toolArgs,\n    toolName,\n    cause,\n    message = `Invalid arguments for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(\n      cause\n    )}`\n  }) {\n    super({ name: name11, message, cause });\n    this[_a11] = true;\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker11);\n  }\n};\n_a11 = symbol11;\n\n// errors/no-such-tool-error.ts\n\nvar name12 = \"AI_NoSuchToolError\";\nvar marker12 = `vercel.ai.error.${name12}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    toolName,\n    availableTools = void 0,\n    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}`\n  }) {\n    super({ name: name12, message });\n    this[_a12] = true;\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker12);\n  }\n};\n_a12 = symbol12;\n\n// errors/tool-call-repair-error.ts\n\nvar name13 = \"AI_ToolCallRepairError\";\nvar marker13 = `vercel.ai.error.${name13}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar ToolCallRepairError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    cause,\n    originalError,\n    message = `Error repairing tool call: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(cause)}`\n  }) {\n    super({ name: name13, message, cause });\n    this[_a13] = true;\n    this.originalError = originalError;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker13);\n  }\n};\n_a13 = symbol13;\n\n// core/generate-text/parse-tool-call.ts\nasync function parseToolCall({\n  toolCall,\n  tools,\n  repairToolCall,\n  system,\n  messages\n}) {\n  if (tools == null) {\n    throw new NoSuchToolError({ toolName: toolCall.toolName });\n  }\n  try {\n    return await doParseToolCall({ toolCall, tools });\n  } catch (error) {\n    if (repairToolCall == null || !(NoSuchToolError.isInstance(error) || InvalidToolArgumentsError.isInstance(error))) {\n      throw error;\n    }\n    let repairedToolCall = null;\n    try {\n      repairedToolCall = await repairToolCall({\n        toolCall,\n        tools,\n        parameterSchema: ({ toolName }) => (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(tools[toolName].parameters).jsonSchema,\n        system,\n        messages,\n        error\n      });\n    } catch (repairError) {\n      throw new ToolCallRepairError({\n        cause: repairError,\n        originalError: error\n      });\n    }\n    if (repairedToolCall == null) {\n      throw error;\n    }\n    return await doParseToolCall({ toolCall: repairedToolCall, tools });\n  }\n}\nasync function doParseToolCall({\n  toolCall,\n  tools\n}) {\n  const toolName = toolCall.toolName;\n  const tool2 = tools[toolName];\n  if (tool2 == null) {\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools)\n    });\n  }\n  const schema = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(tool2.parameters);\n  const parseResult = toolCall.args.trim() === \"\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: {}, schema }) : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: toolCall.args, schema });\n  if (parseResult.success === false) {\n    throw new InvalidToolArgumentsError({\n      toolName,\n      toolArgs: toolCall.args,\n      cause: parseResult.error\n    });\n  }\n  return {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    args: parseResult.value\n  };\n}\n\n// core/generate-text/reasoning-detail.ts\nfunction asReasoningText(reasoning) {\n  const reasoningText = reasoning.filter((part) => part.type === \"text\").map((part) => part.text).join(\"\");\n  return reasoningText.length > 0 ? reasoningText : void 0;\n}\n\n// core/generate-text/to-response-messages.ts\nfunction toResponseMessages({\n  text: text2 = \"\",\n  files,\n  reasoning,\n  tools,\n  toolCalls,\n  toolResults,\n  messageId,\n  generateMessageId\n}) {\n  const responseMessages = [];\n  const content = [];\n  if (reasoning.length > 0) {\n    content.push(\n      ...reasoning.map(\n        (part) => part.type === \"text\" ? { ...part, type: \"reasoning\" } : { ...part, type: \"redacted-reasoning\" }\n      )\n    );\n  }\n  if (files.length > 0) {\n    content.push(\n      ...files.map((file) => ({\n        type: \"file\",\n        data: file.base64,\n        mimeType: file.mimeType\n      }))\n    );\n  }\n  if (text2.length > 0) {\n    content.push({ type: \"text\", text: text2 });\n  }\n  if (toolCalls.length > 0) {\n    content.push(...toolCalls);\n  }\n  if (content.length > 0) {\n    responseMessages.push({\n      role: \"assistant\",\n      content,\n      id: messageId\n    });\n  }\n  if (toolResults.length > 0) {\n    responseMessages.push({\n      role: \"tool\",\n      id: generateMessageId(),\n      content: toolResults.map((toolResult) => {\n        const tool2 = tools[toolResult.toolName];\n        return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {\n          type: \"tool-result\",\n          toolCallId: toolResult.toolCallId,\n          toolName: toolResult.toolName,\n          result: tool2.experimental_toToolResultContent(toolResult.result),\n          experimental_content: tool2.experimental_toToolResultContent(\n            toolResult.result\n          )\n        } : {\n          type: \"tool-result\",\n          toolCallId: toolResult.toolCallId,\n          toolName: toolResult.toolName,\n          result: toolResult.result\n        };\n      })\n    });\n  }\n  return responseMessages;\n}\n\n// core/generate-text/generate-text.ts\nvar originalGenerateId3 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n  prefix: \"aitxt\",\n  size: 24\n});\nvar originalGenerateMessageId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n  prefix: \"msg\",\n  size: 24\n});\nasync function generateText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  maxSteps = 1,\n  experimental_generateMessageId: generateMessageId = originalGenerateMessageId,\n  experimental_output: output,\n  experimental_continueSteps: continueSteps = false,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  experimental_activeTools: activeTools,\n  experimental_prepareStep: prepareStep,\n  experimental_repairToolCall: repairToolCall,\n  _internal: {\n    generateId: generateId3 = originalGenerateId3,\n    currentDate = () => /* @__PURE__ */ new Date()\n  } = {},\n  onStepFinish,\n  ...settings\n}) {\n  var _a17;\n  if (maxSteps < 1) {\n    throw new InvalidArgumentError({\n      parameter: \"maxSteps\",\n      value: maxSteps,\n      message: \"maxSteps must be at least 1\"\n    });\n  }\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries }\n  });\n  const initialPrompt = standardizePrompt({\n    prompt: {\n      system: (_a17 = output == null ? void 0 : output.injectIntoSystemPrompt({ system, model })) != null ? _a17 : system,\n      prompt,\n      messages\n    },\n    tools\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.generateText\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: \"ai.generateText\",\n          telemetry\n        }),\n        ...baseTelemetryAttributes,\n        // model:\n        \"ai.model.provider\": model.provider,\n        \"ai.model.id\": model.modelId,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        },\n        \"ai.settings.maxSteps\": maxSteps\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      var _a18, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;\n      const callSettings = prepareCallSettings(settings);\n      let currentModelResponse;\n      let currentToolCalls = [];\n      let currentToolResults = [];\n      let currentReasoningDetails = [];\n      let stepCount = 0;\n      const responseMessages = [];\n      let text2 = \"\";\n      const sources = [];\n      const steps = [];\n      let usage = {\n        completionTokens: 0,\n        promptTokens: 0,\n        totalTokens: 0\n      };\n      let stepType = \"initial\";\n      do {\n        const promptFormat = stepCount === 0 ? initialPrompt.type : \"messages\";\n        const stepInputMessages = [\n          ...initialPrompt.messages,\n          ...responseMessages\n        ];\n        const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n          model,\n          steps,\n          maxSteps,\n          stepNumber: stepCount\n        }));\n        const stepToolChoice = (_a18 = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _a18 : toolChoice;\n        const stepActiveTools = (_b = prepareStepResult == null ? void 0 : prepareStepResult.experimental_activeTools) != null ? _b : activeTools;\n        const stepModel = (_c = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _c : model;\n        const promptMessages = await convertToLanguageModelPrompt({\n          prompt: {\n            type: promptFormat,\n            system: initialPrompt.system,\n            messages: stepInputMessages\n          },\n          modelSupportsImageUrls: stepModel.supportsImageUrls,\n          modelSupportsUrl: (_d = stepModel.supportsUrl) == null ? void 0 : _d.bind(stepModel)\n          // support 'this' context\n        });\n        const mode = {\n          type: \"regular\",\n          ...prepareToolsAndToolChoice({\n            tools,\n            toolChoice: stepToolChoice,\n            activeTools: stepActiveTools\n          })\n        };\n        currentModelResponse = await retry(\n          () => recordSpan({\n            name: \"ai.generateText.doGenerate\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.generateText.doGenerate\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // model:\n                \"ai.model.provider\": stepModel.provider,\n                \"ai.model.id\": stepModel.modelId,\n                // prompt:\n                \"ai.prompt.format\": { input: () => promptFormat },\n                \"ai.prompt.messages\": {\n                  input: () => stringifyForTelemetry(promptMessages)\n                },\n                \"ai.prompt.tools\": {\n                  // convert the language model level tools:\n                  input: () => {\n                    var _a19;\n                    return (_a19 = mode.tools) == null ? void 0 : _a19.map((tool2) => JSON.stringify(tool2));\n                  }\n                },\n                \"ai.prompt.toolChoice\": {\n                  input: () => mode.toolChoice != null ? JSON.stringify(mode.toolChoice) : void 0\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": stepModel.provider,\n                \"gen_ai.request.model\": stepModel.modelId,\n                \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                \"gen_ai.request.temperature\": settings.temperature,\n                \"gen_ai.request.top_k\": settings.topK,\n                \"gen_ai.request.top_p\": settings.topP\n              }\n            }),\n            tracer,\n            fn: async (span2) => {\n              var _a19, _b2, _c2, _d2, _e2, _f2;\n              const result = await stepModel.doGenerate({\n                mode,\n                ...callSettings,\n                inputFormat: promptFormat,\n                responseFormat: output == null ? void 0 : output.responseFormat({ model }),\n                prompt: promptMessages,\n                providerMetadata: providerOptions,\n                abortSignal,\n                headers\n              });\n              const responseData = {\n                id: (_b2 = (_a19 = result.response) == null ? void 0 : _a19.id) != null ? _b2 : generateId3(),\n                timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),\n                modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : stepModel.modelId\n              };\n              span2.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.response.finishReason\": result.finishReason,\n                    \"ai.response.text\": {\n                      output: () => result.text\n                    },\n                    \"ai.response.toolCalls\": {\n                      output: () => JSON.stringify(result.toolCalls)\n                    },\n                    \"ai.response.id\": responseData.id,\n                    \"ai.response.model\": responseData.modelId,\n                    \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                    \"ai.usage.promptTokens\": result.usage.promptTokens,\n                    \"ai.usage.completionTokens\": result.usage.completionTokens,\n                    // standardized gen-ai llm span attributes:\n                    \"gen_ai.response.finish_reasons\": [result.finishReason],\n                    \"gen_ai.response.id\": responseData.id,\n                    \"gen_ai.response.model\": responseData.modelId,\n                    \"gen_ai.usage.input_tokens\": result.usage.promptTokens,\n                    \"gen_ai.usage.output_tokens\": result.usage.completionTokens\n                  }\n                })\n              );\n              return { ...result, response: responseData };\n            }\n          })\n        );\n        currentToolCalls = await Promise.all(\n          ((_e = currentModelResponse.toolCalls) != null ? _e : []).map(\n            (toolCall) => parseToolCall({\n              toolCall,\n              tools,\n              repairToolCall,\n              system,\n              messages: stepInputMessages\n            })\n          )\n        );\n        currentToolResults = tools == null ? [] : await executeTools({\n          toolCalls: currentToolCalls,\n          tools,\n          tracer,\n          telemetry,\n          messages: stepInputMessages,\n          abortSignal\n        });\n        const currentUsage = calculateLanguageModelUsage(\n          currentModelResponse.usage\n        );\n        usage = addLanguageModelUsage(usage, currentUsage);\n        let nextStepType = \"done\";\n        if (++stepCount < maxSteps) {\n          if (continueSteps && currentModelResponse.finishReason === \"length\" && // only use continue when there are no tool calls:\n          currentToolCalls.length === 0) {\n            nextStepType = \"continue\";\n          } else if (\n            // there are tool calls:\n            currentToolCalls.length > 0 && // all current tool calls have results:\n            currentToolResults.length === currentToolCalls.length\n          ) {\n            nextStepType = \"tool-result\";\n          }\n        }\n        const originalText = (_f = currentModelResponse.text) != null ? _f : \"\";\n        const stepTextLeadingWhitespaceTrimmed = stepType === \"continue\" && // only for continue steps\n        text2.trimEnd() !== text2 ? originalText.trimStart() : originalText;\n        const stepText = nextStepType === \"continue\" ? removeTextAfterLastWhitespace(stepTextLeadingWhitespaceTrimmed) : stepTextLeadingWhitespaceTrimmed;\n        text2 = nextStepType === \"continue\" || stepType === \"continue\" ? text2 + stepText : stepText;\n        currentReasoningDetails = asReasoningDetails(\n          currentModelResponse.reasoning\n        );\n        sources.push(...(_g = currentModelResponse.sources) != null ? _g : []);\n        if (stepType === \"continue\") {\n          const lastMessage = responseMessages[responseMessages.length - 1];\n          if (typeof lastMessage.content === \"string\") {\n            lastMessage.content += stepText;\n          } else {\n            lastMessage.content.push({\n              text: stepText,\n              type: \"text\"\n            });\n          }\n        } else {\n          responseMessages.push(\n            ...toResponseMessages({\n              text: text2,\n              files: asFiles(currentModelResponse.files),\n              reasoning: asReasoningDetails(currentModelResponse.reasoning),\n              tools: tools != null ? tools : {},\n              toolCalls: currentToolCalls,\n              toolResults: currentToolResults,\n              messageId: generateMessageId(),\n              generateMessageId\n            })\n          );\n        }\n        const currentStepResult = {\n          stepType,\n          text: stepText,\n          // TODO v5: rename reasoning to reasoningText (and use reasoning for composite array)\n          reasoning: asReasoningText(currentReasoningDetails),\n          reasoningDetails: currentReasoningDetails,\n          files: asFiles(currentModelResponse.files),\n          sources: (_h = currentModelResponse.sources) != null ? _h : [],\n          toolCalls: currentToolCalls,\n          toolResults: currentToolResults,\n          finishReason: currentModelResponse.finishReason,\n          usage: currentUsage,\n          warnings: currentModelResponse.warnings,\n          logprobs: currentModelResponse.logprobs,\n          request: (_i = currentModelResponse.request) != null ? _i : {},\n          response: {\n            ...currentModelResponse.response,\n            headers: (_j = currentModelResponse.rawResponse) == null ? void 0 : _j.headers,\n            body: (_k = currentModelResponse.rawResponse) == null ? void 0 : _k.body,\n            // deep clone msgs to avoid mutating past messages in multi-step:\n            messages: structuredClone(responseMessages)\n          },\n          providerMetadata: currentModelResponse.providerMetadata,\n          experimental_providerMetadata: currentModelResponse.providerMetadata,\n          isContinued: nextStepType === \"continue\"\n        };\n        steps.push(currentStepResult);\n        await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n        stepType = nextStepType;\n      } while (stepType !== \"done\");\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.response.finishReason\": currentModelResponse.finishReason,\n            \"ai.response.text\": {\n              output: () => currentModelResponse.text\n            },\n            \"ai.response.toolCalls\": {\n              output: () => JSON.stringify(currentModelResponse.toolCalls)\n            },\n            \"ai.usage.promptTokens\": currentModelResponse.usage.promptTokens,\n            \"ai.usage.completionTokens\": currentModelResponse.usage.completionTokens\n          }\n        })\n      );\n      return new DefaultGenerateTextResult({\n        text: text2,\n        files: asFiles(currentModelResponse.files),\n        reasoning: asReasoningText(currentReasoningDetails),\n        reasoningDetails: currentReasoningDetails,\n        sources,\n        outputResolver: () => {\n          if (output == null) {\n            throw new NoOutputSpecifiedError();\n          }\n          return output.parseOutput(\n            { text: text2 },\n            {\n              response: currentModelResponse.response,\n              usage,\n              finishReason: currentModelResponse.finishReason\n            }\n          );\n        },\n        toolCalls: currentToolCalls,\n        toolResults: currentToolResults,\n        finishReason: currentModelResponse.finishReason,\n        usage,\n        warnings: currentModelResponse.warnings,\n        request: (_l = currentModelResponse.request) != null ? _l : {},\n        response: {\n          ...currentModelResponse.response,\n          headers: (_m = currentModelResponse.rawResponse) == null ? void 0 : _m.headers,\n          body: (_n = currentModelResponse.rawResponse) == null ? void 0 : _n.body,\n          messages: responseMessages\n        },\n        logprobs: currentModelResponse.logprobs,\n        steps,\n        providerMetadata: currentModelResponse.providerMetadata\n      });\n    }\n  });\n}\nasync function executeTools({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry,\n  messages,\n  abortSignal\n}) {\n  const toolResults = await Promise.all(\n    toolCalls.map(async ({ toolCallId, toolName, args }) => {\n      const tool2 = tools[toolName];\n      if ((tool2 == null ? void 0 : tool2.execute) == null) {\n        return void 0;\n      }\n      const result = await recordSpan({\n        name: \"ai.toolCall\",\n        attributes: selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            ...assembleOperationName({\n              operationId: \"ai.toolCall\",\n              telemetry\n            }),\n            \"ai.toolCall.name\": toolName,\n            \"ai.toolCall.id\": toolCallId,\n            \"ai.toolCall.args\": {\n              output: () => JSON.stringify(args)\n            }\n          }\n        }),\n        tracer,\n        fn: async (span) => {\n          try {\n            const result2 = await tool2.execute(args, {\n              toolCallId,\n              messages,\n              abortSignal\n            });\n            try {\n              span.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.toolCall.result\": {\n                      output: () => JSON.stringify(result2)\n                    }\n                  }\n                })\n              );\n            } catch (ignored) {\n            }\n            return result2;\n          } catch (error) {\n            throw new ToolExecutionError({\n              toolCallId,\n              toolName,\n              toolArgs: args,\n              cause: error\n            });\n          }\n        }\n      });\n      return {\n        type: \"tool-result\",\n        toolCallId,\n        toolName,\n        args,\n        result\n      };\n    })\n  );\n  return toolResults.filter(\n    (result) => result != null\n  );\n}\nvar DefaultGenerateTextResult = class {\n  constructor(options) {\n    this.text = options.text;\n    this.files = options.files;\n    this.reasoning = options.reasoning;\n    this.reasoningDetails = options.reasoningDetails;\n    this.toolCalls = options.toolCalls;\n    this.toolResults = options.toolResults;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.request = options.request;\n    this.response = options.response;\n    this.steps = options.steps;\n    this.experimental_providerMetadata = options.providerMetadata;\n    this.providerMetadata = options.providerMetadata;\n    this.logprobs = options.logprobs;\n    this.outputResolver = options.outputResolver;\n    this.sources = options.sources;\n  }\n  get experimental_output() {\n    return this.outputResolver();\n  }\n};\nfunction asReasoningDetails(reasoning) {\n  if (reasoning == null) {\n    return [];\n  }\n  if (typeof reasoning === \"string\") {\n    return [{ type: \"text\", text: reasoning }];\n  }\n  return reasoning;\n}\nfunction asFiles(files) {\n  var _a17;\n  return (_a17 = files == null ? void 0 : files.map((file) => new DefaultGeneratedFile(file))) != null ? _a17 : [];\n}\n\n// core/generate-text/output.ts\nvar output_exports = {};\n__export(output_exports, {\n  object: () => object,\n  text: () => text\n});\n\n\n\n// errors/index.ts\n\n\n// errors/invalid-stream-part-error.ts\n\nvar name14 = \"AI_InvalidStreamPartError\";\nvar marker14 = `vercel.ai.error.${name14}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar InvalidStreamPartError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    chunk,\n    message\n  }) {\n    super({ name: name14, message });\n    this[_a14] = true;\n    this.chunk = chunk;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker14);\n  }\n};\n_a14 = symbol14;\n\n// errors/mcp-client-error.ts\n\nvar name15 = \"AI_MCPClientError\";\nvar marker15 = `vercel.ai.error.${name15}`;\nvar symbol15 = Symbol.for(marker15);\nvar _a15;\nvar MCPClientError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    name: name17 = \"MCPClientError\",\n    message,\n    cause\n  }) {\n    super({ name: name17, message, cause });\n    this[_a15] = true;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker15);\n  }\n};\n_a15 = symbol15;\n\n// core/generate-text/output.ts\nvar text = () => ({\n  type: \"text\",\n  responseFormat: () => ({ type: \"text\" }),\n  injectIntoSystemPrompt({ system }) {\n    return system;\n  },\n  parsePartial({ text: text2 }) {\n    return { partial: text2 };\n  },\n  parseOutput({ text: text2 }) {\n    return text2;\n  }\n});\nvar object = ({\n  schema: inputSchema\n}) => {\n  const schema = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(inputSchema);\n  return {\n    type: \"object\",\n    responseFormat: ({ model }) => ({\n      type: \"json\",\n      schema: model.supportsStructuredOutputs ? schema.jsonSchema : void 0\n    }),\n    injectIntoSystemPrompt({ system, model }) {\n      return model.supportsStructuredOutputs ? system : injectJsonInstruction({\n        prompt: system,\n        schema: schema.jsonSchema\n      });\n    },\n    parsePartial({ text: text2 }) {\n      const result = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.parsePartialJson)(text2);\n      switch (result.state) {\n        case \"failed-parse\":\n        case \"undefined-input\":\n          return void 0;\n        case \"repaired-parse\":\n        case \"successful-parse\":\n          return {\n            // Note: currently no validation of partial results:\n            partial: result.value\n          };\n        default: {\n          const _exhaustiveCheck = result.state;\n          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    parseOutput({ text: text2 }, context) {\n      const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: text2 });\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: could not parse the response.\",\n          cause: parseResult.error,\n          text: text2,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason\n        });\n      }\n      const validationResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n        value: parseResult.value,\n        schema\n      });\n      if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: response did not match schema.\",\n          cause: validationResult.error,\n          text: text2,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason\n        });\n      }\n      return validationResult.value;\n    }\n  };\n};\n\n// core/generate-text/smooth-stream.ts\n\n\nvar CHUNKING_REGEXPS = {\n  word: /\\S+\\s+/m,\n  line: /\\n+/m\n};\nfunction smoothStream({\n  delayInMs = 10,\n  chunking = \"word\",\n  _internal: { delay: delay2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay } = {}\n} = {}) {\n  let detectChunk;\n  if (typeof chunking === \"function\") {\n    detectChunk = (buffer) => {\n      const match = chunking(buffer);\n      if (match == null) {\n        return null;\n      }\n      if (!match.length) {\n        throw new Error(`Chunking function must return a non-empty string.`);\n      }\n      if (!buffer.startsWith(match)) {\n        throw new Error(\n          `Chunking function must return a match that is a prefix of the buffer. Received: \"${match}\" expected to start with \"${buffer}\"`\n        );\n      }\n      return match;\n    };\n  } else {\n    const chunkingRegex = typeof chunking === \"string\" ? CHUNKING_REGEXPS[chunking] : chunking;\n    if (chunkingRegex == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        argument: \"chunking\",\n        message: `Chunking must be \"word\" or \"line\" or a RegExp. Received: ${chunking}`\n      });\n    }\n    detectChunk = (buffer) => {\n      const match = chunkingRegex.exec(buffer);\n      if (!match) {\n        return null;\n      }\n      return buffer.slice(0, match.index) + (match == null ? void 0 : match[0]);\n    };\n  }\n  return () => {\n    let buffer = \"\";\n    return new TransformStream({\n      async transform(chunk, controller) {\n        if (chunk.type !== \"text-delta\") {\n          if (buffer.length > 0) {\n            controller.enqueue({ type: \"text-delta\", textDelta: buffer });\n            buffer = \"\";\n          }\n          controller.enqueue(chunk);\n          return;\n        }\n        buffer += chunk.textDelta;\n        let match;\n        while ((match = detectChunk(buffer)) != null) {\n          controller.enqueue({ type: \"text-delta\", textDelta: match });\n          buffer = buffer.slice(match.length);\n          await delay2(delayInMs);\n        }\n      }\n    });\n  };\n}\n\n// core/generate-text/stream-text.ts\n\n\n\n\n// util/as-array.ts\nfunction asArray(value) {\n  return value === void 0 ? [] : Array.isArray(value) ? value : [value];\n}\n\n// util/consume-stream.ts\nasync function consumeStream({\n  stream,\n  onError\n}) {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { done } = await reader.read();\n      if (done)\n        break;\n    }\n  } catch (error) {\n    onError == null ? void 0 : onError(error);\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// core/util/merge-streams.ts\nfunction mergeStreams(stream1, stream2) {\n  const reader1 = stream1.getReader();\n  const reader2 = stream2.getReader();\n  let lastRead1 = void 0;\n  let lastRead2 = void 0;\n  let stream1Done = false;\n  let stream2Done = false;\n  async function readStream1(controller) {\n    try {\n      if (lastRead1 == null) {\n        lastRead1 = reader1.read();\n      }\n      const result = await lastRead1;\n      lastRead1 = void 0;\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n  async function readStream2(controller) {\n    try {\n      if (lastRead2 == null) {\n        lastRead2 = reader2.read();\n      }\n      const result = await lastRead2;\n      lastRead2 = void 0;\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        if (stream1Done) {\n          await readStream2(controller);\n          return;\n        }\n        if (stream2Done) {\n          await readStream1(controller);\n          return;\n        }\n        if (lastRead1 == null) {\n          lastRead1 = reader1.read();\n        }\n        if (lastRead2 == null) {\n          lastRead2 = reader2.read();\n        }\n        const { result, reader } = await Promise.race([\n          lastRead1.then((result2) => ({ result: result2, reader: reader1 })),\n          lastRead2.then((result2) => ({ result: result2, reader: reader2 }))\n        ]);\n        if (!result.done) {\n          controller.enqueue(result.value);\n        }\n        if (reader === reader1) {\n          lastRead1 = void 0;\n          if (result.done) {\n            await readStream2(controller);\n            stream1Done = true;\n          }\n        } else {\n          lastRead2 = void 0;\n          if (result.done) {\n            stream2Done = true;\n            await readStream1(controller);\n          }\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    cancel() {\n      reader1.cancel();\n      reader2.cancel();\n    }\n  });\n}\n\n// core/generate-text/run-tools-transformation.ts\n\nfunction runToolsTransformation({\n  tools,\n  generatorStream,\n  toolCallStreaming,\n  tracer,\n  telemetry,\n  system,\n  messages,\n  abortSignal,\n  repairToolCall\n}) {\n  let toolResultsStreamController = null;\n  const toolResultsStream = new ReadableStream({\n    start(controller) {\n      toolResultsStreamController = controller;\n    }\n  });\n  const activeToolCalls = {};\n  const outstandingToolResults = /* @__PURE__ */ new Set();\n  let canClose = false;\n  let finishChunk = void 0;\n  function attemptClose() {\n    if (canClose && outstandingToolResults.size === 0) {\n      if (finishChunk != null) {\n        toolResultsStreamController.enqueue(finishChunk);\n      }\n      toolResultsStreamController.close();\n    }\n  }\n  const forwardStream = new TransformStream({\n    async transform(chunk, controller) {\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"text-delta\":\n        case \"reasoning\":\n        case \"reasoning-signature\":\n        case \"redacted-reasoning\":\n        case \"source\":\n        case \"response-metadata\":\n        case \"error\": {\n          controller.enqueue(chunk);\n          break;\n        }\n        case \"file\": {\n          controller.enqueue(\n            new DefaultGeneratedFileWithType({\n              data: chunk.data,\n              mimeType: chunk.mimeType\n            })\n          );\n          break;\n        }\n        case \"tool-call-delta\": {\n          if (toolCallStreaming) {\n            if (!activeToolCalls[chunk.toolCallId]) {\n              controller.enqueue({\n                type: \"tool-call-streaming-start\",\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName\n              });\n              activeToolCalls[chunk.toolCallId] = true;\n            }\n            controller.enqueue({\n              type: \"tool-call-delta\",\n              toolCallId: chunk.toolCallId,\n              toolName: chunk.toolName,\n              argsTextDelta: chunk.argsTextDelta\n            });\n          }\n          break;\n        }\n        case \"tool-call\": {\n          try {\n            const toolCall = await parseToolCall({\n              toolCall: chunk,\n              tools,\n              repairToolCall,\n              system,\n              messages\n            });\n            controller.enqueue(toolCall);\n            const tool2 = tools[toolCall.toolName];\n            if (tool2.execute != null) {\n              const toolExecutionId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId)();\n              outstandingToolResults.add(toolExecutionId);\n              recordSpan({\n                name: \"ai.toolCall\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.toolCall\",\n                      telemetry\n                    }),\n                    \"ai.toolCall.name\": toolCall.toolName,\n                    \"ai.toolCall.id\": toolCall.toolCallId,\n                    \"ai.toolCall.args\": {\n                      output: () => JSON.stringify(toolCall.args)\n                    }\n                  }\n                }),\n                tracer,\n                fn: async (span) => tool2.execute(toolCall.args, {\n                  toolCallId: toolCall.toolCallId,\n                  messages,\n                  abortSignal\n                }).then(\n                  (result) => {\n                    toolResultsStreamController.enqueue({\n                      ...toolCall,\n                      type: \"tool-result\",\n                      result\n                    });\n                    outstandingToolResults.delete(toolExecutionId);\n                    attemptClose();\n                    try {\n                      span.setAttributes(\n                        selectTelemetryAttributes({\n                          telemetry,\n                          attributes: {\n                            \"ai.toolCall.result\": {\n                              output: () => JSON.stringify(result)\n                            }\n                          }\n                        })\n                      );\n                    } catch (ignored) {\n                    }\n                  },\n                  (error) => {\n                    toolResultsStreamController.enqueue({\n                      type: \"error\",\n                      error: new ToolExecutionError({\n                        toolCallId: toolCall.toolCallId,\n                        toolName: toolCall.toolName,\n                        toolArgs: toolCall.args,\n                        cause: error\n                      })\n                    });\n                    outstandingToolResults.delete(toolExecutionId);\n                    attemptClose();\n                  }\n                )\n              });\n            }\n          } catch (error) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error\n            });\n          }\n          break;\n        }\n        case \"finish\": {\n          finishChunk = {\n            type: \"finish\",\n            finishReason: chunk.finishReason,\n            logprobs: chunk.logprobs,\n            usage: calculateLanguageModelUsage(chunk.usage),\n            experimental_providerMetadata: chunk.providerMetadata\n          };\n          break;\n        }\n        default: {\n          const _exhaustiveCheck = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    flush() {\n      canClose = true;\n      attemptClose();\n    }\n  });\n  return new ReadableStream({\n    async start(controller) {\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n            }\n          })\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            }\n          })\n        )\n      ]);\n    }\n  });\n}\n\n// core/generate-text/stream-text.ts\nvar originalGenerateId4 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n  prefix: \"aitxt\",\n  size: 24\n});\nvar originalGenerateMessageId2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n  prefix: \"msg\",\n  size: 24\n});\nfunction streamText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  maxSteps = 1,\n  experimental_generateMessageId: generateMessageId = originalGenerateMessageId2,\n  experimental_output: output,\n  experimental_continueSteps: continueSteps = false,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  experimental_toolCallStreaming = false,\n  toolCallStreaming = experimental_toolCallStreaming,\n  experimental_activeTools: activeTools,\n  experimental_repairToolCall: repairToolCall,\n  experimental_transform: transform,\n  onChunk,\n  onError,\n  onFinish,\n  onStepFinish,\n  _internal: {\n    now: now2 = now,\n    generateId: generateId3 = originalGenerateId4,\n    currentDate = () => /* @__PURE__ */ new Date()\n  } = {},\n  ...settings\n}) {\n  return new DefaultStreamTextResult({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    toolCallStreaming,\n    transforms: asArray(transform),\n    activeTools,\n    repairToolCall,\n    maxSteps,\n    output,\n    continueSteps,\n    providerOptions,\n    onChunk,\n    onError,\n    onFinish,\n    onStepFinish,\n    now: now2,\n    currentDate,\n    generateId: generateId3,\n    generateMessageId\n  });\n}\nfunction createOutputTransformStream(output) {\n  if (!output) {\n    return new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n      }\n    });\n  }\n  let text2 = \"\";\n  let textChunk = \"\";\n  let lastPublishedJson = \"\";\n  function publishTextChunk({\n    controller,\n    partialOutput = void 0\n  }) {\n    controller.enqueue({\n      part: { type: \"text-delta\", textDelta: textChunk },\n      partialOutput\n    });\n    textChunk = \"\";\n  }\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (chunk.type === \"step-finish\") {\n        publishTextChunk({ controller });\n      }\n      if (chunk.type !== \"text-delta\") {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      text2 += chunk.textDelta;\n      textChunk += chunk.textDelta;\n      const result = output.parsePartial({ text: text2 });\n      if (result != null) {\n        const currentJson = JSON.stringify(result.partial);\n        if (currentJson !== lastPublishedJson) {\n          publishTextChunk({ controller, partialOutput: result.partial });\n          lastPublishedJson = currentJson;\n        }\n      }\n    },\n    flush(controller) {\n      if (textChunk.length > 0) {\n        publishTextChunk({ controller });\n      }\n    }\n  });\n}\nvar DefaultStreamTextResult = class {\n  constructor({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    toolCallStreaming,\n    transforms,\n    activeTools,\n    repairToolCall,\n    maxSteps,\n    output,\n    continueSteps,\n    providerOptions,\n    now: now2,\n    currentDate,\n    generateId: generateId3,\n    generateMessageId,\n    onChunk,\n    onError,\n    onFinish,\n    onStepFinish\n  }) {\n    this.warningsPromise = new DelayedPromise();\n    this.usagePromise = new DelayedPromise();\n    this.finishReasonPromise = new DelayedPromise();\n    this.providerMetadataPromise = new DelayedPromise();\n    this.textPromise = new DelayedPromise();\n    this.reasoningPromise = new DelayedPromise();\n    this.reasoningDetailsPromise = new DelayedPromise();\n    this.sourcesPromise = new DelayedPromise();\n    this.filesPromise = new DelayedPromise();\n    this.toolCallsPromise = new DelayedPromise();\n    this.toolResultsPromise = new DelayedPromise();\n    this.requestPromise = new DelayedPromise();\n    this.responsePromise = new DelayedPromise();\n    this.stepsPromise = new DelayedPromise();\n    var _a17;\n    if (maxSteps < 1) {\n      throw new InvalidArgumentError({\n        parameter: \"maxSteps\",\n        value: maxSteps,\n        message: \"maxSteps must be at least 1\"\n      });\n    }\n    this.output = output;\n    let recordedStepText = \"\";\n    let recordedContinuationText = \"\";\n    let recordedFullText = \"\";\n    let stepReasoning = [];\n    let stepFiles = [];\n    let activeReasoningText = void 0;\n    let recordedStepSources = [];\n    const recordedSources = [];\n    const recordedResponse = {\n      id: generateId3(),\n      timestamp: currentDate(),\n      modelId: model.modelId,\n      messages: []\n    };\n    let recordedToolCalls = [];\n    let recordedToolResults = [];\n    let recordedFinishReason = void 0;\n    let recordedUsage = void 0;\n    let stepType = \"initial\";\n    const recordedSteps = [];\n    let rootSpan;\n    const eventProcessor = new TransformStream({\n      async transform(chunk, controller) {\n        controller.enqueue(chunk);\n        const { part } = chunk;\n        if (part.type === \"text-delta\" || part.type === \"reasoning\" || part.type === \"source\" || part.type === \"tool-call\" || part.type === \"tool-result\" || part.type === \"tool-call-streaming-start\" || part.type === \"tool-call-delta\") {\n          await (onChunk == null ? void 0 : onChunk({ chunk: part }));\n        }\n        if (part.type === \"error\") {\n          await (onError == null ? void 0 : onError({ error: part.error }));\n        }\n        if (part.type === \"text-delta\") {\n          recordedStepText += part.textDelta;\n          recordedContinuationText += part.textDelta;\n          recordedFullText += part.textDelta;\n        }\n        if (part.type === \"reasoning\") {\n          if (activeReasoningText == null) {\n            activeReasoningText = { type: \"text\", text: part.textDelta };\n            stepReasoning.push(activeReasoningText);\n          } else {\n            activeReasoningText.text += part.textDelta;\n          }\n        }\n        if (part.type === \"reasoning-signature\") {\n          if (activeReasoningText == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError({\n              name: \"InvalidStreamPart\",\n              message: \"reasoning-signature without reasoning\"\n            });\n          }\n          activeReasoningText.signature = part.signature;\n          activeReasoningText = void 0;\n        }\n        if (part.type === \"redacted-reasoning\") {\n          stepReasoning.push({ type: \"redacted\", data: part.data });\n        }\n        if (part.type === \"file\") {\n          stepFiles.push(part);\n        }\n        if (part.type === \"source\") {\n          recordedSources.push(part.source);\n          recordedStepSources.push(part.source);\n        }\n        if (part.type === \"tool-call\") {\n          recordedToolCalls.push(part);\n        }\n        if (part.type === \"tool-result\") {\n          recordedToolResults.push(part);\n        }\n        if (part.type === \"step-finish\") {\n          const stepMessages = toResponseMessages({\n            text: recordedContinuationText,\n            files: stepFiles,\n            reasoning: stepReasoning,\n            tools: tools != null ? tools : {},\n            toolCalls: recordedToolCalls,\n            toolResults: recordedToolResults,\n            messageId: part.messageId,\n            generateMessageId\n          });\n          const currentStep = recordedSteps.length;\n          let nextStepType = \"done\";\n          if (currentStep + 1 < maxSteps) {\n            if (continueSteps && part.finishReason === \"length\" && // only use continue when there are no tool calls:\n            recordedToolCalls.length === 0) {\n              nextStepType = \"continue\";\n            } else if (\n              // there are tool calls:\n              recordedToolCalls.length > 0 && // all current tool calls have results:\n              recordedToolResults.length === recordedToolCalls.length\n            ) {\n              nextStepType = \"tool-result\";\n            }\n          }\n          const currentStepResult = {\n            stepType,\n            text: recordedStepText,\n            reasoning: asReasoningText(stepReasoning),\n            reasoningDetails: stepReasoning,\n            files: stepFiles,\n            sources: recordedStepSources,\n            toolCalls: recordedToolCalls,\n            toolResults: recordedToolResults,\n            finishReason: part.finishReason,\n            usage: part.usage,\n            warnings: part.warnings,\n            logprobs: part.logprobs,\n            request: part.request,\n            response: {\n              ...part.response,\n              messages: [...recordedResponse.messages, ...stepMessages]\n            },\n            providerMetadata: part.experimental_providerMetadata,\n            experimental_providerMetadata: part.experimental_providerMetadata,\n            isContinued: part.isContinued\n          };\n          await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n          recordedSteps.push(currentStepResult);\n          recordedToolCalls = [];\n          recordedToolResults = [];\n          recordedStepText = \"\";\n          recordedStepSources = [];\n          stepReasoning = [];\n          stepFiles = [];\n          activeReasoningText = void 0;\n          if (nextStepType !== \"done\") {\n            stepType = nextStepType;\n          }\n          if (nextStepType !== \"continue\") {\n            recordedResponse.messages.push(...stepMessages);\n            recordedContinuationText = \"\";\n          }\n        }\n        if (part.type === \"finish\") {\n          recordedResponse.id = part.response.id;\n          recordedResponse.timestamp = part.response.timestamp;\n          recordedResponse.modelId = part.response.modelId;\n          recordedResponse.headers = part.response.headers;\n          recordedUsage = part.usage;\n          recordedFinishReason = part.finishReason;\n        }\n      },\n      async flush(controller) {\n        var _a18;\n        try {\n          if (recordedSteps.length === 0) {\n            return;\n          }\n          const lastStep = recordedSteps[recordedSteps.length - 1];\n          self.warningsPromise.resolve(lastStep.warnings);\n          self.requestPromise.resolve(lastStep.request);\n          self.responsePromise.resolve(lastStep.response);\n          self.toolCallsPromise.resolve(lastStep.toolCalls);\n          self.toolResultsPromise.resolve(lastStep.toolResults);\n          self.providerMetadataPromise.resolve(\n            lastStep.experimental_providerMetadata\n          );\n          self.reasoningPromise.resolve(lastStep.reasoning);\n          self.reasoningDetailsPromise.resolve(lastStep.reasoningDetails);\n          const finishReason = recordedFinishReason != null ? recordedFinishReason : \"unknown\";\n          const usage = recordedUsage != null ? recordedUsage : {\n            completionTokens: NaN,\n            promptTokens: NaN,\n            totalTokens: NaN\n          };\n          self.finishReasonPromise.resolve(finishReason);\n          self.usagePromise.resolve(usage);\n          self.textPromise.resolve(recordedFullText);\n          self.sourcesPromise.resolve(recordedSources);\n          self.filesPromise.resolve(lastStep.files);\n          self.stepsPromise.resolve(recordedSteps);\n          await (onFinish == null ? void 0 : onFinish({\n            finishReason,\n            logprobs: void 0,\n            usage,\n            text: recordedFullText,\n            reasoning: lastStep.reasoning,\n            reasoningDetails: lastStep.reasoningDetails,\n            files: lastStep.files,\n            sources: lastStep.sources,\n            toolCalls: lastStep.toolCalls,\n            toolResults: lastStep.toolResults,\n            request: (_a18 = lastStep.request) != null ? _a18 : {},\n            response: lastStep.response,\n            warnings: lastStep.warnings,\n            providerMetadata: lastStep.providerMetadata,\n            experimental_providerMetadata: lastStep.experimental_providerMetadata,\n            steps: recordedSteps\n          }));\n          rootSpan.setAttributes(\n            selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                \"ai.response.finishReason\": finishReason,\n                \"ai.response.text\": { output: () => recordedFullText },\n                \"ai.response.toolCalls\": {\n                  output: () => {\n                    var _a19;\n                    return ((_a19 = lastStep.toolCalls) == null ? void 0 : _a19.length) ? JSON.stringify(lastStep.toolCalls) : void 0;\n                  }\n                },\n                \"ai.usage.promptTokens\": usage.promptTokens,\n                \"ai.usage.completionTokens\": usage.completionTokens\n              }\n            })\n          );\n        } catch (error) {\n          controller.error(error);\n        } finally {\n          rootSpan.end();\n        }\n      }\n    });\n    const stitchableStream = createStitchableStream();\n    this.addStream = stitchableStream.addStream;\n    this.closeStream = stitchableStream.close;\n    let stream = stitchableStream.stream;\n    for (const transform of transforms) {\n      stream = stream.pipeThrough(\n        transform({\n          tools,\n          stopStream() {\n            stitchableStream.terminate();\n          }\n        })\n      );\n    }\n    this.baseStream = stream.pipeThrough(createOutputTransformStream(output)).pipeThrough(eventProcessor);\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg\n    });\n    const tracer = getTracer(telemetry);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...settings, maxRetries }\n    });\n    const initialPrompt = standardizePrompt({\n      prompt: {\n        system: (_a17 = output == null ? void 0 : output.injectIntoSystemPrompt({ system, model })) != null ? _a17 : system,\n        prompt,\n        messages\n      },\n      tools\n    });\n    const self = this;\n    recordSpan({\n      name: \"ai.streamText\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({ operationId: \"ai.streamText\", telemetry }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          },\n          \"ai.settings.maxSteps\": maxSteps\n        }\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async (rootSpanArg) => {\n        rootSpan = rootSpanArg;\n        async function streamStep({\n          currentStep,\n          responseMessages,\n          usage,\n          stepType: stepType2,\n          previousStepText,\n          hasLeadingWhitespace,\n          messageId\n        }) {\n          var _a18;\n          const promptFormat = responseMessages.length === 0 ? initialPrompt.type : \"messages\";\n          const stepInputMessages = [\n            ...initialPrompt.messages,\n            ...responseMessages\n          ];\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: {\n              type: promptFormat,\n              system: initialPrompt.system,\n              messages: stepInputMessages\n            },\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: (_a18 = model.supportsUrl) == null ? void 0 : _a18.bind(model)\n            // support 'this' context\n          });\n          const mode = {\n            type: \"regular\",\n            ...prepareToolsAndToolChoice({ tools, toolChoice, activeTools })\n          };\n          const {\n            result: { stream: stream2, warnings, rawResponse, request },\n            doStreamSpan,\n            startTimestampMs\n          } = await retry(\n            () => recordSpan({\n              name: \"ai.streamText.doStream\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: \"ai.streamText.doStream\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  \"ai.prompt.format\": {\n                    input: () => promptFormat\n                  },\n                  \"ai.prompt.messages\": {\n                    input: () => stringifyForTelemetry(promptMessages)\n                  },\n                  \"ai.prompt.tools\": {\n                    // convert the language model level tools:\n                    input: () => {\n                      var _a19;\n                      return (_a19 = mode.tools) == null ? void 0 : _a19.map((tool2) => JSON.stringify(tool2));\n                    }\n                  },\n                  \"ai.prompt.toolChoice\": {\n                    input: () => mode.toolChoice != null ? JSON.stringify(mode.toolChoice) : void 0\n                  },\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.system\": model.provider,\n                  \"gen_ai.request.model\": model.modelId,\n                  \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                  \"gen_ai.request.max_tokens\": settings.maxTokens,\n                  \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                  \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                  \"gen_ai.request.temperature\": settings.temperature,\n                  \"gen_ai.request.top_k\": settings.topK,\n                  \"gen_ai.request.top_p\": settings.topP\n                }\n              }),\n              tracer,\n              endWhenDone: false,\n              fn: async (doStreamSpan2) => ({\n                startTimestampMs: now2(),\n                // get before the call\n                doStreamSpan: doStreamSpan2,\n                result: await model.doStream({\n                  mode,\n                  ...prepareCallSettings(settings),\n                  inputFormat: promptFormat,\n                  responseFormat: output == null ? void 0 : output.responseFormat({ model }),\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers\n                })\n              })\n            })\n          );\n          const transformedStream = runToolsTransformation({\n            tools,\n            generatorStream: stream2,\n            toolCallStreaming,\n            tracer,\n            telemetry,\n            system,\n            messages: stepInputMessages,\n            repairToolCall,\n            abortSignal\n          });\n          const stepRequest = request != null ? request : {};\n          const stepToolCalls = [];\n          const stepToolResults = [];\n          const stepReasoning2 = [];\n          const stepFiles2 = [];\n          let activeReasoningText2 = void 0;\n          let stepFinishReason = \"unknown\";\n          let stepUsage = {\n            promptTokens: 0,\n            completionTokens: 0,\n            totalTokens: 0\n          };\n          let stepProviderMetadata;\n          let stepFirstChunk = true;\n          let stepText = \"\";\n          let fullStepText = stepType2 === \"continue\" ? previousStepText : \"\";\n          let stepLogProbs;\n          let stepResponse = {\n            id: generateId3(),\n            timestamp: currentDate(),\n            modelId: model.modelId\n          };\n          let chunkBuffer = \"\";\n          let chunkTextPublished = false;\n          let inWhitespacePrefix = true;\n          let hasWhitespaceSuffix = false;\n          async function publishTextChunk({\n            controller,\n            chunk\n          }) {\n            controller.enqueue(chunk);\n            stepText += chunk.textDelta;\n            fullStepText += chunk.textDelta;\n            chunkTextPublished = true;\n            hasWhitespaceSuffix = chunk.textDelta.trimEnd() !== chunk.textDelta;\n          }\n          self.addStream(\n            transformedStream.pipeThrough(\n              new TransformStream({\n                async transform(chunk, controller) {\n                  var _a19, _b, _c;\n                  if (stepFirstChunk) {\n                    const msToFirstChunk = now2() - startTimestampMs;\n                    stepFirstChunk = false;\n                    doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                      \"ai.response.msToFirstChunk\": msToFirstChunk\n                    });\n                    doStreamSpan.setAttributes({\n                      \"ai.response.msToFirstChunk\": msToFirstChunk\n                    });\n                    controller.enqueue({\n                      type: \"step-start\",\n                      messageId,\n                      request: stepRequest,\n                      warnings: warnings != null ? warnings : []\n                    });\n                  }\n                  if (chunk.type === \"text-delta\" && chunk.textDelta.length === 0) {\n                    return;\n                  }\n                  const chunkType = chunk.type;\n                  switch (chunkType) {\n                    case \"text-delta\": {\n                      if (continueSteps) {\n                        const trimmedChunkText = inWhitespacePrefix && hasLeadingWhitespace ? chunk.textDelta.trimStart() : chunk.textDelta;\n                        if (trimmedChunkText.length === 0) {\n                          break;\n                        }\n                        inWhitespacePrefix = false;\n                        chunkBuffer += trimmedChunkText;\n                        const split = splitOnLastWhitespace(chunkBuffer);\n                        if (split != null) {\n                          chunkBuffer = split.suffix;\n                          await publishTextChunk({\n                            controller,\n                            chunk: {\n                              type: \"text-delta\",\n                              textDelta: split.prefix + split.whitespace\n                            }\n                          });\n                        }\n                      } else {\n                        await publishTextChunk({ controller, chunk });\n                      }\n                      break;\n                    }\n                    case \"reasoning\": {\n                      controller.enqueue(chunk);\n                      if (activeReasoningText2 == null) {\n                        activeReasoningText2 = {\n                          type: \"text\",\n                          text: chunk.textDelta\n                        };\n                        stepReasoning2.push(activeReasoningText2);\n                      } else {\n                        activeReasoningText2.text += chunk.textDelta;\n                      }\n                      break;\n                    }\n                    case \"reasoning-signature\": {\n                      controller.enqueue(chunk);\n                      if (activeReasoningText2 == null) {\n                        throw new InvalidStreamPartError({\n                          chunk,\n                          message: \"reasoning-signature without reasoning\"\n                        });\n                      }\n                      activeReasoningText2.signature = chunk.signature;\n                      activeReasoningText2 = void 0;\n                      break;\n                    }\n                    case \"redacted-reasoning\": {\n                      controller.enqueue(chunk);\n                      stepReasoning2.push({\n                        type: \"redacted\",\n                        data: chunk.data\n                      });\n                      break;\n                    }\n                    case \"tool-call\": {\n                      controller.enqueue(chunk);\n                      stepToolCalls.push(chunk);\n                      break;\n                    }\n                    case \"tool-result\": {\n                      controller.enqueue(chunk);\n                      stepToolResults.push(chunk);\n                      break;\n                    }\n                    case \"response-metadata\": {\n                      stepResponse = {\n                        id: (_a19 = chunk.id) != null ? _a19 : stepResponse.id,\n                        timestamp: (_b = chunk.timestamp) != null ? _b : stepResponse.timestamp,\n                        modelId: (_c = chunk.modelId) != null ? _c : stepResponse.modelId\n                      };\n                      break;\n                    }\n                    case \"finish\": {\n                      stepUsage = chunk.usage;\n                      stepFinishReason = chunk.finishReason;\n                      stepProviderMetadata = chunk.experimental_providerMetadata;\n                      stepLogProbs = chunk.logprobs;\n                      const msToFinish = now2() - startTimestampMs;\n                      doStreamSpan.addEvent(\"ai.stream.finish\");\n                      doStreamSpan.setAttributes({\n                        \"ai.response.msToFinish\": msToFinish,\n                        \"ai.response.avgCompletionTokensPerSecond\": 1e3 * stepUsage.completionTokens / msToFinish\n                      });\n                      break;\n                    }\n                    case \"file\": {\n                      stepFiles2.push(chunk);\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"source\":\n                    case \"tool-call-streaming-start\":\n                    case \"tool-call-delta\": {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"error\": {\n                      controller.enqueue(chunk);\n                      stepFinishReason = \"error\";\n                      break;\n                    }\n                    default: {\n                      const exhaustiveCheck = chunkType;\n                      throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                    }\n                  }\n                },\n                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                async flush(controller) {\n                  const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;\n                  let nextStepType = \"done\";\n                  if (currentStep + 1 < maxSteps) {\n                    if (continueSteps && stepFinishReason === \"length\" && // only use continue when there are no tool calls:\n                    stepToolCalls.length === 0) {\n                      nextStepType = \"continue\";\n                    } else if (\n                      // there are tool calls:\n                      stepToolCalls.length > 0 && // all current tool calls have results:\n                      stepToolResults.length === stepToolCalls.length\n                    ) {\n                      nextStepType = \"tool-result\";\n                    }\n                  }\n                  if (continueSteps && chunkBuffer.length > 0 && (nextStepType !== \"continue\" || // when the next step is a regular step, publish the buffer\n                  stepType2 === \"continue\" && !chunkTextPublished)) {\n                    await publishTextChunk({\n                      controller,\n                      chunk: {\n                        type: \"text-delta\",\n                        textDelta: chunkBuffer\n                      }\n                    });\n                    chunkBuffer = \"\";\n                  }\n                  try {\n                    doStreamSpan.setAttributes(\n                      selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                          \"ai.response.finishReason\": stepFinishReason,\n                          \"ai.response.text\": { output: () => stepText },\n                          \"ai.response.toolCalls\": {\n                            output: () => stepToolCallsJson\n                          },\n                          \"ai.response.id\": stepResponse.id,\n                          \"ai.response.model\": stepResponse.modelId,\n                          \"ai.response.timestamp\": stepResponse.timestamp.toISOString(),\n                          \"ai.usage.promptTokens\": stepUsage.promptTokens,\n                          \"ai.usage.completionTokens\": stepUsage.completionTokens,\n                          // standardized gen-ai llm span attributes:\n                          \"gen_ai.response.finish_reasons\": [stepFinishReason],\n                          \"gen_ai.response.id\": stepResponse.id,\n                          \"gen_ai.response.model\": stepResponse.modelId,\n                          \"gen_ai.usage.input_tokens\": stepUsage.promptTokens,\n                          \"gen_ai.usage.output_tokens\": stepUsage.completionTokens\n                        }\n                      })\n                    );\n                  } catch (error) {\n                  } finally {\n                    doStreamSpan.end();\n                  }\n                  controller.enqueue({\n                    type: \"step-finish\",\n                    finishReason: stepFinishReason,\n                    usage: stepUsage,\n                    providerMetadata: stepProviderMetadata,\n                    experimental_providerMetadata: stepProviderMetadata,\n                    logprobs: stepLogProbs,\n                    request: stepRequest,\n                    response: {\n                      ...stepResponse,\n                      headers: rawResponse == null ? void 0 : rawResponse.headers\n                    },\n                    warnings,\n                    isContinued: nextStepType === \"continue\",\n                    messageId\n                  });\n                  const combinedUsage = addLanguageModelUsage(usage, stepUsage);\n                  if (nextStepType === \"done\") {\n                    controller.enqueue({\n                      type: \"finish\",\n                      finishReason: stepFinishReason,\n                      usage: combinedUsage,\n                      providerMetadata: stepProviderMetadata,\n                      experimental_providerMetadata: stepProviderMetadata,\n                      logprobs: stepLogProbs,\n                      response: {\n                        ...stepResponse,\n                        headers: rawResponse == null ? void 0 : rawResponse.headers\n                      }\n                    });\n                    self.closeStream();\n                  } else {\n                    if (stepType2 === \"continue\") {\n                      const lastMessage = responseMessages[responseMessages.length - 1];\n                      if (typeof lastMessage.content === \"string\") {\n                        lastMessage.content += stepText;\n                      } else {\n                        lastMessage.content.push({\n                          text: stepText,\n                          type: \"text\"\n                        });\n                      }\n                    } else {\n                      responseMessages.push(\n                        ...toResponseMessages({\n                          text: stepText,\n                          files: stepFiles2,\n                          reasoning: stepReasoning2,\n                          tools: tools != null ? tools : {},\n                          toolCalls: stepToolCalls,\n                          toolResults: stepToolResults,\n                          messageId,\n                          generateMessageId\n                        })\n                      );\n                    }\n                    await streamStep({\n                      currentStep: currentStep + 1,\n                      responseMessages,\n                      usage: combinedUsage,\n                      stepType: nextStepType,\n                      previousStepText: fullStepText,\n                      hasLeadingWhitespace: hasWhitespaceSuffix,\n                      messageId: (\n                        // keep the same id when continuing a step:\n                        nextStepType === \"continue\" ? messageId : generateMessageId()\n                      )\n                    });\n                  }\n                }\n              })\n            )\n          );\n        }\n        await streamStep({\n          currentStep: 0,\n          responseMessages: [],\n          usage: {\n            promptTokens: 0,\n            completionTokens: 0,\n            totalTokens: 0\n          },\n          previousStepText: \"\",\n          stepType: \"initial\",\n          hasLeadingWhitespace: false,\n          messageId: generateMessageId()\n        });\n      }\n    }).catch((error) => {\n      self.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: \"error\", error });\n            controller.close();\n          }\n        })\n      );\n      self.closeStream();\n    });\n  }\n  get warnings() {\n    return this.warningsPromise.value;\n  }\n  get usage() {\n    return this.usagePromise.value;\n  }\n  get finishReason() {\n    return this.finishReasonPromise.value;\n  }\n  get experimental_providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n  get providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n  get text() {\n    return this.textPromise.value;\n  }\n  get reasoning() {\n    return this.reasoningPromise.value;\n  }\n  get reasoningDetails() {\n    return this.reasoningDetailsPromise.value;\n  }\n  get sources() {\n    return this.sourcesPromise.value;\n  }\n  get files() {\n    return this.filesPromise.value;\n  }\n  get toolCalls() {\n    return this.toolCallsPromise.value;\n  }\n  get toolResults() {\n    return this.toolResultsPromise.value;\n  }\n  get request() {\n    return this.requestPromise.value;\n  }\n  get response() {\n    return this.responsePromise.value;\n  }\n  get steps() {\n    return this.stepsPromise.value;\n  }\n  /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */\n  teeStream() {\n    const [stream1, stream2] = this.baseStream.tee();\n    this.baseStream = stream2;\n    return stream1;\n  }\n  get textStream() {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ part }, controller) {\n            if (part.type === \"text-delta\") {\n              controller.enqueue(part.textDelta);\n            }\n          }\n        })\n      )\n    );\n  }\n  get fullStream() {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ part }, controller) {\n            controller.enqueue(part);\n          }\n        })\n      )\n    );\n  }\n  async consumeStream(options) {\n    var _a17;\n    try {\n      await consumeStream({\n        stream: this.fullStream,\n        onError: options == null ? void 0 : options.onError\n      });\n    } catch (error) {\n      (_a17 = options == null ? void 0 : options.onError) == null ? void 0 : _a17.call(options, error);\n    }\n  }\n  get experimental_partialOutputStream() {\n    if (this.output == null) {\n      throw new NoOutputSpecifiedError();\n    }\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ partialOutput }, controller) {\n            if (partialOutput != null) {\n              controller.enqueue(partialOutput);\n            }\n          }\n        })\n      )\n    );\n  }\n  toDataStreamInternal({\n    getErrorMessage: getErrorMessage5 = () => \"An error occurred.\",\n    // mask error messages for safety by default\n    sendUsage = true,\n    sendReasoning = false,\n    sendSources = false,\n    experimental_sendFinish = true\n  }) {\n    return this.fullStream.pipeThrough(\n      new TransformStream({\n        transform: async (chunk, controller) => {\n          const chunkType = chunk.type;\n          switch (chunkType) {\n            case \"text-delta\": {\n              controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"text\", chunk.textDelta));\n              break;\n            }\n            case \"reasoning\": {\n              if (sendReasoning) {\n                controller.enqueue(\n                  (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"reasoning\", chunk.textDelta)\n                );\n              }\n              break;\n            }\n            case \"redacted-reasoning\": {\n              if (sendReasoning) {\n                controller.enqueue(\n                  (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"redacted_reasoning\", {\n                    data: chunk.data\n                  })\n                );\n              }\n              break;\n            }\n            case \"reasoning-signature\": {\n              if (sendReasoning) {\n                controller.enqueue(\n                  (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"reasoning_signature\", {\n                    signature: chunk.signature\n                  })\n                );\n              }\n              break;\n            }\n            case \"file\": {\n              controller.enqueue(\n                (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"file\", {\n                  mimeType: chunk.mimeType,\n                  data: chunk.base64\n                })\n              );\n              break;\n            }\n            case \"source\": {\n              if (sendSources) {\n                controller.enqueue(\n                  (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"source\", chunk.source)\n                );\n              }\n              break;\n            }\n            case \"tool-call-streaming-start\": {\n              controller.enqueue(\n                (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"tool_call_streaming_start\", {\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName\n                })\n              );\n              break;\n            }\n            case \"tool-call-delta\": {\n              controller.enqueue(\n                (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"tool_call_delta\", {\n                  toolCallId: chunk.toolCallId,\n                  argsTextDelta: chunk.argsTextDelta\n                })\n              );\n              break;\n            }\n            case \"tool-call\": {\n              controller.enqueue(\n                (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"tool_call\", {\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  args: chunk.args\n                })\n              );\n              break;\n            }\n            case \"tool-result\": {\n              controller.enqueue(\n                (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"tool_result\", {\n                  toolCallId: chunk.toolCallId,\n                  result: chunk.result\n                })\n              );\n              break;\n            }\n            case \"error\": {\n              controller.enqueue(\n                (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"error\", getErrorMessage5(chunk.error))\n              );\n              break;\n            }\n            case \"step-start\": {\n              controller.enqueue(\n                (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"start_step\", {\n                  messageId: chunk.messageId\n                })\n              );\n              break;\n            }\n            case \"step-finish\": {\n              controller.enqueue(\n                (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"finish_step\", {\n                  finishReason: chunk.finishReason,\n                  usage: sendUsage ? {\n                    promptTokens: chunk.usage.promptTokens,\n                    completionTokens: chunk.usage.completionTokens\n                  } : void 0,\n                  isContinued: chunk.isContinued\n                })\n              );\n              break;\n            }\n            case \"finish\": {\n              if (experimental_sendFinish) {\n                controller.enqueue(\n                  (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"finish_message\", {\n                    finishReason: chunk.finishReason,\n                    usage: sendUsage ? {\n                      promptTokens: chunk.usage.promptTokens,\n                      completionTokens: chunk.usage.completionTokens\n                    } : void 0\n                  })\n                );\n              }\n              break;\n            }\n            default: {\n              const exhaustiveCheck = chunkType;\n              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n            }\n          }\n        }\n      })\n    );\n  }\n  pipeDataStreamToResponse(response, {\n    status,\n    statusText,\n    headers,\n    data,\n    getErrorMessage: getErrorMessage5,\n    sendUsage,\n    sendReasoning,\n    sendSources,\n    experimental_sendFinish\n  } = {}) {\n    writeToServerResponse({\n      response,\n      status,\n      statusText,\n      headers: prepareOutgoingHttpHeaders(headers, {\n        contentType: \"text/plain; charset=utf-8\",\n        dataStreamVersion: \"v1\"\n      }),\n      stream: this.toDataStream({\n        data,\n        getErrorMessage: getErrorMessage5,\n        sendUsage,\n        sendReasoning,\n        sendSources,\n        experimental_sendFinish\n      })\n    });\n  }\n  pipeTextStreamToResponse(response, init) {\n    writeToServerResponse({\n      response,\n      status: init == null ? void 0 : init.status,\n      statusText: init == null ? void 0 : init.statusText,\n      headers: prepareOutgoingHttpHeaders(init == null ? void 0 : init.headers, {\n        contentType: \"text/plain; charset=utf-8\"\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream())\n    });\n  }\n  // TODO breaking change 5.0: remove pipeThrough(new TextEncoderStream())\n  toDataStream(options) {\n    const stream = this.toDataStreamInternal({\n      getErrorMessage: options == null ? void 0 : options.getErrorMessage,\n      sendUsage: options == null ? void 0 : options.sendUsage,\n      sendReasoning: options == null ? void 0 : options.sendReasoning,\n      sendSources: options == null ? void 0 : options.sendSources,\n      experimental_sendFinish: options == null ? void 0 : options.experimental_sendFinish\n    }).pipeThrough(new TextEncoderStream());\n    return (options == null ? void 0 : options.data) ? mergeStreams(options == null ? void 0 : options.data.stream, stream) : stream;\n  }\n  mergeIntoDataStream(writer, options) {\n    writer.merge(\n      this.toDataStreamInternal({\n        getErrorMessage: writer.onError,\n        sendUsage: options == null ? void 0 : options.sendUsage,\n        sendReasoning: options == null ? void 0 : options.sendReasoning,\n        sendSources: options == null ? void 0 : options.sendSources,\n        experimental_sendFinish: options == null ? void 0 : options.experimental_sendFinish\n      })\n    );\n  }\n  toDataStreamResponse({\n    headers,\n    status,\n    statusText,\n    data,\n    getErrorMessage: getErrorMessage5,\n    sendUsage,\n    sendReasoning,\n    sendSources,\n    experimental_sendFinish\n  } = {}) {\n    return new Response(\n      this.toDataStream({\n        data,\n        getErrorMessage: getErrorMessage5,\n        sendUsage,\n        sendReasoning,\n        sendSources,\n        experimental_sendFinish\n      }),\n      {\n        status,\n        statusText,\n        headers: prepareResponseHeaders(headers, {\n          contentType: \"text/plain; charset=utf-8\",\n          dataStreamVersion: \"v1\"\n        })\n      }\n    );\n  }\n  toTextStreamResponse(init) {\n    var _a17;\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,\n      headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {\n        contentType: \"text/plain; charset=utf-8\"\n      })\n    });\n  }\n};\n\n// errors/no-speech-generated-error.ts\n\nvar NoSpeechGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor(options) {\n    super({\n      name: \"AI_NoSpeechGeneratedError\",\n      message: \"No speech audio generated.\"\n    });\n    this.responses = options.responses;\n  }\n};\n\n// core/generate-speech/generated-audio-file.ts\nvar DefaultGeneratedAudioFile = class extends DefaultGeneratedFile {\n  constructor({\n    data,\n    mimeType\n  }) {\n    super({ data, mimeType });\n    let format = \"mp3\";\n    if (mimeType) {\n      const mimeTypeParts = mimeType.split(\"/\");\n      if (mimeTypeParts.length === 2) {\n        if (mimeType !== \"audio/mpeg\") {\n          format = mimeTypeParts[1];\n        }\n      }\n    }\n    if (!format) {\n      throw new Error(\n        \"Audio format must be provided or determinable from mimeType\"\n      );\n    }\n    this.format = format;\n  }\n};\n\n// core/generate-speech/generate-speech.ts\nasync function generateSpeech({\n  model,\n  text: text2,\n  voice,\n  outputFormat,\n  instructions,\n  speed,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  var _a17;\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const result = await retry(\n    () => model.doGenerate({\n      text: text2,\n      voice,\n      outputFormat,\n      instructions,\n      speed,\n      abortSignal,\n      headers,\n      providerOptions\n    })\n  );\n  if (!result.audio || result.audio.length === 0) {\n    throw new NoSpeechGeneratedError({ responses: [result.response] });\n  }\n  return new DefaultSpeechResult({\n    audio: new DefaultGeneratedAudioFile({\n      data: result.audio,\n      mimeType: (_a17 = detectMimeType({\n        data: result.audio,\n        signatures: audioMimeTypeSignatures\n      })) != null ? _a17 : \"audio/mp3\"\n    }),\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata\n  });\n}\nvar DefaultSpeechResult = class {\n  constructor(options) {\n    var _a17;\n    this.audio = options.audio;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = (_a17 = options.providerMetadata) != null ? _a17 : {};\n  }\n};\n\n// errors/no-transcript-generated-error.ts\n\nvar NoTranscriptGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor(options) {\n    super({\n      name: \"AI_NoTranscriptGeneratedError\",\n      message: \"No transcript generated.\"\n    });\n    this.responses = options.responses;\n  }\n};\n\n// core/transcribe/transcribe.ts\nasync function transcribe({\n  model,\n  audio,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const audioData = audio instanceof URL ? (await download({ url: audio })).data : convertDataContentToUint8Array(audio);\n  const result = await retry(\n    () => {\n      var _a17;\n      return model.doGenerate({\n        audio: audioData,\n        abortSignal,\n        headers,\n        providerOptions,\n        mediaType: (_a17 = detectMimeType({\n          data: audioData,\n          signatures: audioMimeTypeSignatures\n        })) != null ? _a17 : \"audio/wav\"\n      });\n    }\n  );\n  if (!result.text) {\n    throw new NoTranscriptGeneratedError({ responses: [result.response] });\n  }\n  return new DefaultTranscriptionResult({\n    text: result.text,\n    segments: result.segments,\n    language: result.language,\n    durationInSeconds: result.durationInSeconds,\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata\n  });\n}\nvar DefaultTranscriptionResult = class {\n  constructor(options) {\n    var _a17;\n    this.text = options.text;\n    this.segments = options.segments;\n    this.language = options.language;\n    this.durationInSeconds = options.durationInSeconds;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = (_a17 = options.providerMetadata) != null ? _a17 : {};\n  }\n};\n\n// core/util/merge-objects.ts\nfunction mergeObjects(target, source) {\n  if (target === void 0 && source === void 0) {\n    return void 0;\n  }\n  if (target === void 0) {\n    return source;\n  }\n  if (source === void 0) {\n    return target;\n  }\n  const result = { ...target };\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      const sourceValue = source[key];\n      if (sourceValue === void 0)\n        continue;\n      const targetValue = key in target ? target[key] : void 0;\n      const isSourceObject = sourceValue !== null && typeof sourceValue === \"object\" && !Array.isArray(sourceValue) && !(sourceValue instanceof Date) && !(sourceValue instanceof RegExp);\n      const isTargetObject = targetValue !== null && targetValue !== void 0 && typeof targetValue === \"object\" && !Array.isArray(targetValue) && !(targetValue instanceof Date) && !(targetValue instanceof RegExp);\n      if (isSourceObject && isTargetObject) {\n        result[key] = mergeObjects(\n          targetValue,\n          sourceValue\n        );\n      } else {\n        result[key] = sourceValue;\n      }\n    }\n  }\n  return result;\n}\n\n// core/middleware/default-settings-middleware.ts\nfunction defaultSettingsMiddleware({\n  settings\n}) {\n  return {\n    middlewareVersion: \"v1\",\n    transformParams: async ({ params }) => {\n      var _a17;\n      return {\n        ...settings,\n        ...params,\n        providerMetadata: mergeObjects(\n          settings.providerMetadata,\n          params.providerMetadata\n        ),\n        // special case for temperature 0\n        // TODO remove when temperature defaults to undefined\n        temperature: params.temperature === 0 || params.temperature == null ? (_a17 = settings.temperature) != null ? _a17 : 0 : params.temperature\n      };\n    }\n  };\n}\n\n// core/util/get-potential-start-index.ts\nfunction getPotentialStartIndex(text2, searchedText) {\n  if (searchedText.length === 0) {\n    return null;\n  }\n  const directIndex = text2.indexOf(searchedText);\n  if (directIndex !== -1) {\n    return directIndex;\n  }\n  for (let i = text2.length - 1; i >= 0; i--) {\n    const suffix = text2.substring(i);\n    if (searchedText.startsWith(suffix)) {\n      return i;\n    }\n  }\n  return null;\n}\n\n// core/middleware/extract-reasoning-middleware.ts\nfunction extractReasoningMiddleware({\n  tagName,\n  separator = \"\\n\",\n  startWithReasoning = false\n}) {\n  const openingTag = `<${tagName}>`;\n  const closingTag = `</${tagName}>`;\n  return {\n    middlewareVersion: \"v1\",\n    wrapGenerate: async ({ doGenerate }) => {\n      const { text: rawText, ...rest } = await doGenerate();\n      if (rawText == null) {\n        return { text: rawText, ...rest };\n      }\n      const text2 = startWithReasoning ? openingTag + rawText : rawText;\n      const regexp = new RegExp(`${openingTag}(.*?)${closingTag}`, \"gs\");\n      const matches = Array.from(text2.matchAll(regexp));\n      if (!matches.length) {\n        return { text: text2, ...rest };\n      }\n      const reasoning = matches.map((match) => match[1]).join(separator);\n      let textWithoutReasoning = text2;\n      for (let i = matches.length - 1; i >= 0; i--) {\n        const match = matches[i];\n        const beforeMatch = textWithoutReasoning.slice(0, match.index);\n        const afterMatch = textWithoutReasoning.slice(\n          match.index + match[0].length\n        );\n        textWithoutReasoning = beforeMatch + (beforeMatch.length > 0 && afterMatch.length > 0 ? separator : \"\") + afterMatch;\n      }\n      return { ...rest, text: textWithoutReasoning, reasoning };\n    },\n    wrapStream: async ({ doStream }) => {\n      const { stream, ...rest } = await doStream();\n      let isFirstReasoning = true;\n      let isFirstText = true;\n      let afterSwitch = false;\n      let isReasoning = startWithReasoning;\n      let buffer = \"\";\n      return {\n        stream: stream.pipeThrough(\n          new TransformStream({\n            transform: (chunk, controller) => {\n              if (chunk.type !== \"text-delta\") {\n                controller.enqueue(chunk);\n                return;\n              }\n              buffer += chunk.textDelta;\n              function publish(text2) {\n                if (text2.length > 0) {\n                  const prefix = afterSwitch && (isReasoning ? !isFirstReasoning : !isFirstText) ? separator : \"\";\n                  controller.enqueue({\n                    type: isReasoning ? \"reasoning\" : \"text-delta\",\n                    textDelta: prefix + text2\n                  });\n                  afterSwitch = false;\n                  if (isReasoning) {\n                    isFirstReasoning = false;\n                  } else {\n                    isFirstText = false;\n                  }\n                }\n              }\n              do {\n                const nextTag = isReasoning ? closingTag : openingTag;\n                const startIndex = getPotentialStartIndex(buffer, nextTag);\n                if (startIndex == null) {\n                  publish(buffer);\n                  buffer = \"\";\n                  break;\n                }\n                publish(buffer.slice(0, startIndex));\n                const foundFullMatch = startIndex + nextTag.length <= buffer.length;\n                if (foundFullMatch) {\n                  buffer = buffer.slice(startIndex + nextTag.length);\n                  isReasoning = !isReasoning;\n                  afterSwitch = true;\n                } else {\n                  buffer = buffer.slice(startIndex);\n                  break;\n                }\n              } while (true);\n            }\n          })\n        ),\n        ...rest\n      };\n    }\n  };\n}\n\n// core/middleware/simulate-streaming-middleware.ts\nfunction simulateStreamingMiddleware() {\n  return {\n    middlewareVersion: \"v1\",\n    wrapStream: async ({ doGenerate }) => {\n      const result = await doGenerate();\n      const simulatedStream = new ReadableStream({\n        start(controller) {\n          controller.enqueue({ type: \"response-metadata\", ...result.response });\n          if (result.reasoning) {\n            if (typeof result.reasoning === \"string\") {\n              controller.enqueue({\n                type: \"reasoning\",\n                textDelta: result.reasoning\n              });\n            } else {\n              for (const reasoning of result.reasoning) {\n                switch (reasoning.type) {\n                  case \"text\": {\n                    controller.enqueue({\n                      type: \"reasoning\",\n                      textDelta: reasoning.text\n                    });\n                    if (reasoning.signature != null) {\n                      controller.enqueue({\n                        type: \"reasoning-signature\",\n                        signature: reasoning.signature\n                      });\n                    }\n                    break;\n                  }\n                  case \"redacted\": {\n                    controller.enqueue({\n                      type: \"redacted-reasoning\",\n                      data: reasoning.data\n                    });\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          if (result.text) {\n            controller.enqueue({\n              type: \"text-delta\",\n              textDelta: result.text\n            });\n          }\n          if (result.toolCalls) {\n            for (const toolCall of result.toolCalls) {\n              controller.enqueue({\n                type: \"tool-call-delta\",\n                toolCallType: \"function\",\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                argsTextDelta: toolCall.args\n              });\n              controller.enqueue({\n                type: \"tool-call\",\n                ...toolCall\n              });\n            }\n          }\n          controller.enqueue({\n            type: \"finish\",\n            finishReason: result.finishReason,\n            usage: result.usage,\n            logprobs: result.logprobs,\n            providerMetadata: result.providerMetadata\n          });\n          controller.close();\n        }\n      });\n      return {\n        stream: simulatedStream,\n        rawCall: result.rawCall,\n        rawResponse: result.rawResponse,\n        warnings: result.warnings\n      };\n    }\n  };\n}\n\n// core/middleware/wrap-language-model.ts\nvar wrapLanguageModel = ({\n  model,\n  middleware: middlewareArg,\n  modelId,\n  providerId\n}) => {\n  return asArray(middlewareArg).reverse().reduce((wrappedModel, middleware) => {\n    return doWrap({ model: wrappedModel, middleware, modelId, providerId });\n  }, model);\n};\nvar doWrap = ({\n  model,\n  middleware: { transformParams, wrapGenerate, wrapStream },\n  modelId,\n  providerId\n}) => {\n  var _a17;\n  async function doTransform({\n    params,\n    type\n  }) {\n    return transformParams ? await transformParams({ params, type }) : params;\n  }\n  return {\n    specificationVersion: \"v1\",\n    provider: providerId != null ? providerId : model.provider,\n    modelId: modelId != null ? modelId : model.modelId,\n    defaultObjectGenerationMode: model.defaultObjectGenerationMode,\n    supportsImageUrls: model.supportsImageUrls,\n    supportsUrl: (_a17 = model.supportsUrl) == null ? void 0 : _a17.bind(model),\n    supportsStructuredOutputs: model.supportsStructuredOutputs,\n    async doGenerate(params) {\n      const transformedParams = await doTransform({ params, type: \"generate\" });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapGenerate ? wrapGenerate({\n        doGenerate,\n        doStream,\n        params: transformedParams,\n        model\n      }) : doGenerate();\n    },\n    async doStream(params) {\n      const transformedParams = await doTransform({ params, type: \"stream\" });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapStream ? wrapStream({ doGenerate, doStream, params: transformedParams, model }) : doStream();\n    }\n  };\n};\nvar experimental_wrapLanguageModel = wrapLanguageModel;\n\n// core/prompt/append-client-message.ts\nfunction appendClientMessage({\n  messages,\n  message\n}) {\n  return [\n    ...messages.length > 0 && messages[messages.length - 1].id === message.id ? messages.slice(0, -1) : messages,\n    message\n  ];\n}\n\n// core/prompt/append-response-messages.ts\n\n\nfunction appendResponseMessages({\n  messages,\n  responseMessages,\n  _internal: { currentDate = () => /* @__PURE__ */ new Date() } = {}\n}) {\n  var _a17, _b, _c, _d;\n  const clonedMessages = structuredClone(messages);\n  for (const message of responseMessages) {\n    const role = message.role;\n    const lastMessage = clonedMessages[clonedMessages.length - 1];\n    const isLastMessageAssistant = lastMessage.role === \"assistant\";\n    switch (role) {\n      case \"assistant\": {\n        let getToolInvocations2 = function(step) {\n          return (typeof message.content === \"string\" ? [] : message.content.filter((part) => part.type === \"tool-call\")).map((call) => ({\n            state: \"call\",\n            step,\n            args: call.args,\n            toolCallId: call.toolCallId,\n            toolName: call.toolName\n          }));\n        };\n        var getToolInvocations = getToolInvocations2;\n        const parts = [{ type: \"step-start\" }];\n        let textContent = \"\";\n        let reasoningTextContent = void 0;\n        if (typeof message.content === \"string\") {\n          textContent = message.content;\n          parts.push({\n            type: \"text\",\n            text: message.content\n          });\n        } else {\n          let reasoningPart = void 0;\n          for (const part of message.content) {\n            switch (part.type) {\n              case \"text\": {\n                reasoningPart = void 0;\n                textContent += part.text;\n                parts.push({\n                  type: \"text\",\n                  text: part.text\n                });\n                break;\n              }\n              case \"reasoning\": {\n                if (reasoningPart == null) {\n                  reasoningPart = {\n                    type: \"reasoning\",\n                    reasoning: \"\",\n                    details: []\n                  };\n                  parts.push(reasoningPart);\n                }\n                reasoningTextContent = (reasoningTextContent != null ? reasoningTextContent : \"\") + part.text;\n                reasoningPart.reasoning += part.text;\n                reasoningPart.details.push({\n                  type: \"text\",\n                  text: part.text,\n                  signature: part.signature\n                });\n                break;\n              }\n              case \"redacted-reasoning\": {\n                if (reasoningPart == null) {\n                  reasoningPart = {\n                    type: \"reasoning\",\n                    reasoning: \"\",\n                    details: []\n                  };\n                  parts.push(reasoningPart);\n                }\n                reasoningPart.details.push({\n                  type: \"redacted\",\n                  data: part.data\n                });\n                break;\n              }\n              case \"tool-call\":\n                break;\n              case \"file\":\n                if (part.data instanceof URL) {\n                  throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError({\n                    name: \"InvalidAssistantFileData\",\n                    message: \"File data cannot be a URL\"\n                  });\n                }\n                parts.push({\n                  type: \"file\",\n                  mimeType: part.mimeType,\n                  data: convertDataContentToBase64String(part.data)\n                });\n                break;\n            }\n          }\n        }\n        if (isLastMessageAssistant) {\n          const maxStep = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.extractMaxToolInvocationStep)(\n            lastMessage.toolInvocations\n          );\n          (_a17 = lastMessage.parts) != null ? _a17 : lastMessage.parts = [];\n          lastMessage.content = textContent;\n          lastMessage.reasoning = reasoningTextContent;\n          lastMessage.parts.push(...parts);\n          lastMessage.toolInvocations = [\n            ...(_b = lastMessage.toolInvocations) != null ? _b : [],\n            ...getToolInvocations2(maxStep === void 0 ? 0 : maxStep + 1)\n          ];\n          getToolInvocations2(maxStep === void 0 ? 0 : maxStep + 1).map((call) => ({\n            type: \"tool-invocation\",\n            toolInvocation: call\n          })).forEach((part) => {\n            lastMessage.parts.push(part);\n          });\n        } else {\n          clonedMessages.push({\n            role: \"assistant\",\n            id: message.id,\n            createdAt: currentDate(),\n            // generate a createdAt date for the message, will be overridden by the client\n            content: textContent,\n            reasoning: reasoningTextContent,\n            toolInvocations: getToolInvocations2(0),\n            parts: [\n              ...parts,\n              ...getToolInvocations2(0).map((call) => ({\n                type: \"tool-invocation\",\n                toolInvocation: call\n              }))\n            ]\n          });\n        }\n        break;\n      }\n      case \"tool\": {\n        (_c = lastMessage.toolInvocations) != null ? _c : lastMessage.toolInvocations = [];\n        if (lastMessage.role !== \"assistant\") {\n          throw new Error(\n            `Tool result must follow an assistant message: ${lastMessage.role}`\n          );\n        }\n        (_d = lastMessage.parts) != null ? _d : lastMessage.parts = [];\n        for (const contentPart of message.content) {\n          const toolCall = lastMessage.toolInvocations.find(\n            (call) => call.toolCallId === contentPart.toolCallId\n          );\n          const toolCallPart = lastMessage.parts.find(\n            (part) => part.type === \"tool-invocation\" && part.toolInvocation.toolCallId === contentPart.toolCallId\n          );\n          if (!toolCall) {\n            throw new Error(\"Tool call not found in previous message\");\n          }\n          toolCall.state = \"result\";\n          const toolResult = toolCall;\n          toolResult.result = contentPart.result;\n          if (toolCallPart) {\n            toolCallPart.toolInvocation = toolResult;\n          } else {\n            lastMessage.parts.push({\n              type: \"tool-invocation\",\n              toolInvocation: toolResult\n            });\n          }\n        }\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = role;\n        throw new Error(`Unsupported message role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  return clonedMessages;\n}\n\n// core/registry/custom-provider.ts\n\nfunction customProvider({\n  languageModels,\n  textEmbeddingModels,\n  imageModels,\n  fallbackProvider\n}) {\n  return {\n    languageModel(modelId) {\n      if (languageModels != null && modelId in languageModels) {\n        return languageModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.languageModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({ modelId, modelType: \"languageModel\" });\n    },\n    textEmbeddingModel(modelId) {\n      if (textEmbeddingModels != null && modelId in textEmbeddingModels) {\n        return textEmbeddingModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.textEmbeddingModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({ modelId, modelType: \"textEmbeddingModel\" });\n    },\n    imageModel(modelId) {\n      if (imageModels != null && modelId in imageModels) {\n        return imageModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.imageModel) {\n        return fallbackProvider.imageModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({ modelId, modelType: \"imageModel\" });\n    }\n  };\n}\nvar experimental_customProvider = customProvider;\n\n// core/registry/no-such-provider-error.ts\n\nvar name16 = \"AI_NoSuchProviderError\";\nvar marker16 = `vercel.ai.error.${name16}`;\nvar symbol16 = Symbol.for(marker16);\nvar _a16;\nvar NoSuchProviderError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError {\n  constructor({\n    modelId,\n    modelType,\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`\n  }) {\n    super({ errorName: name16, modelId, modelType, message });\n    this[_a16] = true;\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker16);\n  }\n};\n_a16 = symbol16;\n\n// core/registry/provider-registry.ts\n\nfunction createProviderRegistry(providers, {\n  separator = \":\"\n} = {}) {\n  const registry = new DefaultProviderRegistry({\n    separator\n  });\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider });\n  }\n  return registry;\n}\nvar experimental_createProviderRegistry = createProviderRegistry;\nvar DefaultProviderRegistry = class {\n  constructor({ separator }) {\n    this.providers = {};\n    this.separator = separator;\n  }\n  registerProvider({\n    id,\n    provider\n  }) {\n    this.providers[id] = provider;\n  }\n  getProvider(id) {\n    const provider = this.providers[id];\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        modelId: id,\n        modelType: \"languageModel\",\n        providerId: id,\n        availableProviders: Object.keys(this.providers)\n      });\n    }\n    return provider;\n  }\n  splitId(id, modelType) {\n    const index = id.indexOf(this.separator);\n    if (index === -1) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({\n        modelId: id,\n        modelType,\n        message: `Invalid ${modelType} id for registry: ${id} (must be in the format \"providerId${this.separator}modelId\")`\n      });\n    }\n    return [id.slice(0, index), id.slice(index + this.separator.length)];\n  }\n  languageModel(id) {\n    var _a17, _b;\n    const [providerId, modelId] = this.splitId(id, \"languageModel\");\n    const model = (_b = (_a17 = this.getProvider(providerId)).languageModel) == null ? void 0 : _b.call(_a17, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({ modelId: id, modelType: \"languageModel\" });\n    }\n    return model;\n  }\n  textEmbeddingModel(id) {\n    var _a17;\n    const [providerId, modelId] = this.splitId(id, \"textEmbeddingModel\");\n    const provider = this.getProvider(providerId);\n    const model = (_a17 = provider.textEmbeddingModel) == null ? void 0 : _a17.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({\n        modelId: id,\n        modelType: \"textEmbeddingModel\"\n      });\n    }\n    return model;\n  }\n  imageModel(id) {\n    var _a17;\n    const [providerId, modelId] = this.splitId(id, \"imageModel\");\n    const provider = this.getProvider(providerId);\n    const model = (_a17 = provider.imageModel) == null ? void 0 : _a17.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({ modelId: id, modelType: \"imageModel\" });\n    }\n    return model;\n  }\n};\n\n// core/tool/mcp/mcp-client.ts\n\n\n// core/tool/tool.ts\nfunction tool(tool2) {\n  return tool2;\n}\n\n// core/tool/mcp/mcp-sse-transport.ts\n\n\n// core/tool/mcp/json-rpc-message.ts\n\n\n// core/tool/mcp/types.ts\n\nvar LATEST_PROTOCOL_VERSION = \"2024-11-05\";\nvar SUPPORTED_PROTOCOL_VERSIONS = [\n  LATEST_PROTOCOL_VERSION,\n  \"2024-10-07\"\n];\nvar ClientOrServerImplementationSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  name: zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n  version: zod__WEBPACK_IMPORTED_MODULE_5__.z.string()\n}).passthrough();\nvar BaseParamsSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  _meta: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(zod__WEBPACK_IMPORTED_MODULE_5__.z.object({}).passthrough())\n}).passthrough();\nvar ResultSchema = BaseParamsSchema;\nvar RequestSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  method: zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n  params: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(BaseParamsSchema)\n});\nvar ServerCapabilitiesSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  experimental: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(zod__WEBPACK_IMPORTED_MODULE_5__.z.object({}).passthrough()),\n  logging: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(zod__WEBPACK_IMPORTED_MODULE_5__.z.object({}).passthrough()),\n  prompts: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(\n    zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n      listChanged: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(zod__WEBPACK_IMPORTED_MODULE_5__.z.boolean())\n    }).passthrough()\n  ),\n  resources: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(\n    zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n      subscribe: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(zod__WEBPACK_IMPORTED_MODULE_5__.z.boolean()),\n      listChanged: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(zod__WEBPACK_IMPORTED_MODULE_5__.z.boolean())\n    }).passthrough()\n  ),\n  tools: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(\n    zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n      listChanged: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(zod__WEBPACK_IMPORTED_MODULE_5__.z.boolean())\n    }).passthrough()\n  )\n}).passthrough();\nvar InitializeResultSchema = ResultSchema.extend({\n  protocolVersion: zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n  capabilities: ServerCapabilitiesSchema,\n  serverInfo: ClientOrServerImplementationSchema,\n  instructions: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(zod__WEBPACK_IMPORTED_MODULE_5__.z.string())\n});\nvar PaginatedResultSchema = ResultSchema.extend({\n  nextCursor: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(zod__WEBPACK_IMPORTED_MODULE_5__.z.string())\n});\nvar ToolSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  name: zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n  description: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(zod__WEBPACK_IMPORTED_MODULE_5__.z.string()),\n  inputSchema: zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(\"object\"),\n    properties: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(zod__WEBPACK_IMPORTED_MODULE_5__.z.object({}).passthrough())\n  }).passthrough()\n}).passthrough();\nvar ListToolsResultSchema = PaginatedResultSchema.extend({\n  tools: zod__WEBPACK_IMPORTED_MODULE_5__.z.array(ToolSchema)\n});\nvar TextContentSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(\"text\"),\n  text: zod__WEBPACK_IMPORTED_MODULE_5__.z.string()\n}).passthrough();\nvar ImageContentSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(\"image\"),\n  data: zod__WEBPACK_IMPORTED_MODULE_5__.z.string().base64(),\n  mimeType: zod__WEBPACK_IMPORTED_MODULE_5__.z.string()\n}).passthrough();\nvar ResourceContentsSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  /**\n   * The URI of this resource.\n   */\n  uri: zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n  /**\n   * The MIME type of this resource, if known.\n   */\n  mimeType: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(zod__WEBPACK_IMPORTED_MODULE_5__.z.string())\n}).passthrough();\nvar TextResourceContentsSchema = ResourceContentsSchema.extend({\n  text: zod__WEBPACK_IMPORTED_MODULE_5__.z.string()\n});\nvar BlobResourceContentsSchema = ResourceContentsSchema.extend({\n  blob: zod__WEBPACK_IMPORTED_MODULE_5__.z.string().base64()\n});\nvar EmbeddedResourceSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(\"resource\"),\n  resource: zod__WEBPACK_IMPORTED_MODULE_5__.z.union([TextResourceContentsSchema, BlobResourceContentsSchema])\n}).passthrough();\nvar CallToolResultSchema = ResultSchema.extend({\n  content: zod__WEBPACK_IMPORTED_MODULE_5__.z.array(\n    zod__WEBPACK_IMPORTED_MODULE_5__.z.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema])\n  ),\n  isError: zod__WEBPACK_IMPORTED_MODULE_5__.z.boolean().default(false).optional()\n}).or(\n  ResultSchema.extend({\n    toolResult: zod__WEBPACK_IMPORTED_MODULE_5__.z.unknown()\n  })\n);\n\n// core/tool/mcp/json-rpc-message.ts\nvar JSONRPC_VERSION = \"2.0\";\nvar JSONRPCRequestSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  jsonrpc: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(JSONRPC_VERSION),\n  id: zod__WEBPACK_IMPORTED_MODULE_5__.z.union([zod__WEBPACK_IMPORTED_MODULE_5__.z.string(), zod__WEBPACK_IMPORTED_MODULE_5__.z.number().int()])\n}).merge(RequestSchema).strict();\nvar JSONRPCResponseSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  jsonrpc: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(JSONRPC_VERSION),\n  id: zod__WEBPACK_IMPORTED_MODULE_5__.z.union([zod__WEBPACK_IMPORTED_MODULE_5__.z.string(), zod__WEBPACK_IMPORTED_MODULE_5__.z.number().int()]),\n  result: ResultSchema\n}).strict();\nvar JSONRPCErrorSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  jsonrpc: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(JSONRPC_VERSION),\n  id: zod__WEBPACK_IMPORTED_MODULE_5__.z.union([zod__WEBPACK_IMPORTED_MODULE_5__.z.string(), zod__WEBPACK_IMPORTED_MODULE_5__.z.number().int()]),\n  error: zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n    code: zod__WEBPACK_IMPORTED_MODULE_5__.z.number().int(),\n    message: zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n    data: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(zod__WEBPACK_IMPORTED_MODULE_5__.z.unknown())\n  })\n}).strict();\nvar JSONRPCNotificationSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n  jsonrpc: zod__WEBPACK_IMPORTED_MODULE_5__.z.literal(JSONRPC_VERSION)\n}).merge(\n  zod__WEBPACK_IMPORTED_MODULE_5__.z.object({\n    method: zod__WEBPACK_IMPORTED_MODULE_5__.z.string(),\n    params: zod__WEBPACK_IMPORTED_MODULE_5__.z.optional(BaseParamsSchema)\n  })\n).strict();\nvar JSONRPCMessageSchema = zod__WEBPACK_IMPORTED_MODULE_5__.z.union([\n  JSONRPCRequestSchema,\n  JSONRPCNotificationSchema,\n  JSONRPCResponseSchema,\n  JSONRPCErrorSchema\n]);\n\n// core/tool/mcp/mcp-sse-transport.ts\nvar SseMCPTransport = class {\n  constructor({\n    url,\n    headers\n  }) {\n    this.connected = false;\n    this.url = new URL(url);\n    this.headers = headers;\n  }\n  async start() {\n    return new Promise((resolve, reject) => {\n      if (this.connected) {\n        return resolve();\n      }\n      this.abortController = new AbortController();\n      const establishConnection = async () => {\n        var _a17, _b, _c;\n        try {\n          const headers = new Headers(this.headers);\n          headers.set(\"Accept\", \"text/event-stream\");\n          const response = await fetch(this.url.href, {\n            headers,\n            signal: (_a17 = this.abortController) == null ? void 0 : _a17.signal\n          });\n          if (!response.ok || !response.body) {\n            const error = new MCPClientError({\n              message: `MCP SSE Transport Error: ${response.status} ${response.statusText}`\n            });\n            (_b = this.onerror) == null ? void 0 : _b.call(this, error);\n            return reject(error);\n          }\n          const stream = response.body.pipeThrough(new TextDecoderStream()).pipeThrough((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createEventSourceParserStream)());\n          const reader = stream.getReader();\n          const processEvents = async () => {\n            var _a18, _b2, _c2;\n            try {\n              while (true) {\n                const { done, value } = await reader.read();\n                if (done) {\n                  if (this.connected) {\n                    this.connected = false;\n                    throw new MCPClientError({\n                      message: \"MCP SSE Transport Error: Connection closed unexpectedly\"\n                    });\n                  }\n                  return;\n                }\n                const { event, data } = value;\n                if (event === \"endpoint\") {\n                  this.endpoint = new URL(data, this.url);\n                  if (this.endpoint.origin !== this.url.origin) {\n                    throw new MCPClientError({\n                      message: `MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`\n                    });\n                  }\n                  this.connected = true;\n                  resolve();\n                } else if (event === \"message\") {\n                  try {\n                    const message = JSONRPCMessageSchema.parse(\n                      JSON.parse(data)\n                    );\n                    (_a18 = this.onmessage) == null ? void 0 : _a18.call(this, message);\n                  } catch (error) {\n                    const e = new MCPClientError({\n                      message: \"MCP SSE Transport Error: Failed to parse message\",\n                      cause: error\n                    });\n                    (_b2 = this.onerror) == null ? void 0 : _b2.call(this, e);\n                  }\n                }\n              }\n            } catch (error) {\n              if (error instanceof Error && error.name === \"AbortError\") {\n                return;\n              }\n              (_c2 = this.onerror) == null ? void 0 : _c2.call(this, error);\n              reject(error);\n            }\n          };\n          this.sseConnection = {\n            close: () => reader.cancel()\n          };\n          processEvents();\n        } catch (error) {\n          if (error instanceof Error && error.name === \"AbortError\") {\n            return;\n          }\n          (_c = this.onerror) == null ? void 0 : _c.call(this, error);\n          reject(error);\n        }\n      };\n      establishConnection();\n    });\n  }\n  async close() {\n    var _a17, _b, _c;\n    this.connected = false;\n    (_a17 = this.sseConnection) == null ? void 0 : _a17.close();\n    (_b = this.abortController) == null ? void 0 : _b.abort();\n    (_c = this.onclose) == null ? void 0 : _c.call(this);\n  }\n  async send(message) {\n    var _a17, _b, _c;\n    if (!this.endpoint || !this.connected) {\n      throw new MCPClientError({\n        message: \"MCP SSE Transport Error: Not connected\"\n      });\n    }\n    try {\n      const headers = new Headers(this.headers);\n      headers.set(\"Content-Type\", \"application/json\");\n      const init = {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(message),\n        signal: (_a17 = this.abortController) == null ? void 0 : _a17.signal\n      };\n      const response = await fetch(this.endpoint, init);\n      if (!response.ok) {\n        const text2 = await response.text().catch(() => null);\n        const error = new MCPClientError({\n          message: `MCP SSE Transport Error: POSTing to endpoint (HTTP ${response.status}): ${text2}`\n        });\n        (_b = this.onerror) == null ? void 0 : _b.call(this, error);\n        return;\n      }\n    } catch (error) {\n      (_c = this.onerror) == null ? void 0 : _c.call(this, error);\n      return;\n    }\n  }\n};\n\n// core/tool/mcp/mcp-transport.ts\nfunction createMcpTransport(config) {\n  if (config.type !== \"sse\") {\n    throw new MCPClientError({\n      message: \"Unsupported or invalid transport configuration. If you are using a custom transport, make sure it implements the MCPTransport interface.\"\n    });\n  }\n  return new SseMCPTransport(config);\n}\nfunction isCustomMcpTransport(transport) {\n  return \"start\" in transport && typeof transport.start === \"function\" && \"send\" in transport && typeof transport.send === \"function\" && \"close\" in transport && typeof transport.close === \"function\";\n}\n\n// core/tool/mcp/mcp-client.ts\nvar CLIENT_VERSION = \"1.0.0\";\nasync function createMCPClient(config) {\n  const client = new MCPClient(config);\n  await client.init();\n  return client;\n}\nvar MCPClient = class {\n  constructor({\n    transport: transportConfig,\n    name: name17 = \"ai-sdk-mcp-client\",\n    onUncaughtError\n  }) {\n    this.requestMessageId = 0;\n    this.responseHandlers = /* @__PURE__ */ new Map();\n    this.serverCapabilities = {};\n    this.isClosed = true;\n    this.onUncaughtError = onUncaughtError;\n    if (isCustomMcpTransport(transportConfig)) {\n      this.transport = transportConfig;\n    } else {\n      this.transport = createMcpTransport(transportConfig);\n    }\n    this.transport.onclose = () => this.onClose();\n    this.transport.onerror = (error) => this.onError(error);\n    this.transport.onmessage = (message) => {\n      if (\"method\" in message) {\n        this.onError(\n          new MCPClientError({\n            message: \"Unsupported message type\"\n          })\n        );\n        return;\n      }\n      this.onResponse(message);\n    };\n    this.clientInfo = {\n      name: name17,\n      version: CLIENT_VERSION\n    };\n  }\n  async init() {\n    try {\n      await this.transport.start();\n      this.isClosed = false;\n      const result = await this.request({\n        request: {\n          method: \"initialize\",\n          params: {\n            protocolVersion: LATEST_PROTOCOL_VERSION,\n            capabilities: {},\n            clientInfo: this.clientInfo\n          }\n        },\n        resultSchema: InitializeResultSchema\n      });\n      if (result === void 0) {\n        throw new MCPClientError({\n          message: \"Server sent invalid initialize result\"\n        });\n      }\n      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {\n        throw new MCPClientError({\n          message: `Server's protocol version is not supported: ${result.protocolVersion}`\n        });\n      }\n      this.serverCapabilities = result.capabilities;\n      await this.notification({\n        method: \"notifications/initialized\"\n      });\n      return this;\n    } catch (error) {\n      await this.close();\n      throw error;\n    }\n  }\n  async close() {\n    var _a17;\n    if (this.isClosed)\n      return;\n    await ((_a17 = this.transport) == null ? void 0 : _a17.close());\n    this.onClose();\n  }\n  assertCapability(method) {\n    switch (method) {\n      case \"initialize\":\n        break;\n      case \"tools/list\":\n      case \"tools/call\":\n        if (!this.serverCapabilities.tools) {\n          throw new MCPClientError({\n            message: `Server does not support tools`\n          });\n        }\n        break;\n      default:\n        throw new MCPClientError({\n          message: `Unsupported method: ${method}`\n        });\n    }\n  }\n  async request({\n    request,\n    resultSchema,\n    options\n  }) {\n    return new Promise((resolve, reject) => {\n      if (this.isClosed) {\n        return reject(\n          new MCPClientError({\n            message: \"Attempted to send a request from a closed client\"\n          })\n        );\n      }\n      this.assertCapability(request.method);\n      const signal = options == null ? void 0 : options.signal;\n      signal == null ? void 0 : signal.throwIfAborted();\n      const messageId = this.requestMessageId++;\n      const jsonrpcRequest = {\n        ...request,\n        jsonrpc: \"2.0\",\n        id: messageId\n      };\n      const cleanup = () => {\n        this.responseHandlers.delete(messageId);\n      };\n      this.responseHandlers.set(messageId, (response) => {\n        if (signal == null ? void 0 : signal.aborted) {\n          return reject(\n            new MCPClientError({\n              message: \"Request was aborted\",\n              cause: signal.reason\n            })\n          );\n        }\n        if (response instanceof Error) {\n          return reject(response);\n        }\n        try {\n          const result = resultSchema.parse(response.result);\n          resolve(result);\n        } catch (error) {\n          const parseError = new MCPClientError({\n            message: \"Failed to parse server response\",\n            cause: error\n          });\n          reject(parseError);\n        }\n      });\n      this.transport.send(jsonrpcRequest).catch((error) => {\n        cleanup();\n        reject(error);\n      });\n    });\n  }\n  async listTools({\n    params,\n    options\n  } = {}) {\n    try {\n      return this.request({\n        request: { method: \"tools/list\", params },\n        resultSchema: ListToolsResultSchema,\n        options\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n  async callTool({\n    name: name17,\n    args,\n    options\n  }) {\n    try {\n      return this.request({\n        request: { method: \"tools/call\", params: { name: name17, arguments: args } },\n        resultSchema: CallToolResultSchema,\n        options: {\n          signal: options == null ? void 0 : options.abortSignal\n        }\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n  async notification(notification) {\n    const jsonrpcNotification = {\n      ...notification,\n      jsonrpc: \"2.0\"\n    };\n    await this.transport.send(jsonrpcNotification);\n  }\n  /**\n   * Returns a set of AI SDK tools from the MCP server\n   * @returns A record of tool names to their implementations\n   */\n  async tools({\n    schemas = \"automatic\"\n  } = {}) {\n    var _a17;\n    const tools = {};\n    try {\n      const listToolsResult = await this.listTools();\n      for (const { name: name17, description, inputSchema } of listToolsResult.tools) {\n        if (schemas !== \"automatic\" && !(name17 in schemas)) {\n          continue;\n        }\n        const parameters = schemas === \"automatic\" ? (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.jsonSchema)({\n          ...inputSchema,\n          properties: (_a17 = inputSchema.properties) != null ? _a17 : {},\n          additionalProperties: false\n        }) : schemas[name17].parameters;\n        const self = this;\n        const toolWithExecute = tool({\n          description,\n          parameters,\n          execute: async (args, options) => {\n            var _a18;\n            (_a18 = options == null ? void 0 : options.abortSignal) == null ? void 0 : _a18.throwIfAborted();\n            return self.callTool({\n              name: name17,\n              args,\n              options\n            });\n          }\n        });\n        tools[name17] = toolWithExecute;\n      }\n      return tools;\n    } catch (error) {\n      throw error;\n    }\n  }\n  onClose() {\n    if (this.isClosed)\n      return;\n    this.isClosed = true;\n    const error = new MCPClientError({\n      message: \"Connection closed\"\n    });\n    for (const handler of this.responseHandlers.values()) {\n      handler(error);\n    }\n    this.responseHandlers.clear();\n  }\n  onError(error) {\n    if (this.onUncaughtError) {\n      this.onUncaughtError(error);\n    }\n  }\n  onResponse(response) {\n    const messageId = Number(response.id);\n    const handler = this.responseHandlers.get(messageId);\n    if (handler === void 0) {\n      throw new MCPClientError({\n        message: `Protocol error: Received a response for an unknown message ID: ${JSON.stringify(\n          response\n        )}`\n      });\n    }\n    this.responseHandlers.delete(messageId);\n    handler(\n      \"result\" in response ? response : new MCPClientError({\n        message: response.error.message,\n        cause: response.error\n      })\n    );\n  }\n};\n\n// core/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2, options) {\n  if (vector1.length !== vector2.length) {\n    throw new InvalidArgumentError({\n      parameter: \"vector1,vector2\",\n      value: { vector1Length: vector1.length, vector2Length: vector2.length },\n      message: `Vectors must have the same length`\n    });\n  }\n  const n = vector1.length;\n  if (n === 0) {\n    if (options == null ? void 0 : options.throwErrorForEmptyVectors) {\n      throw new InvalidArgumentError({\n        parameter: \"vector1\",\n        value: vector1,\n        message: \"Vectors cannot be empty\"\n      });\n    }\n    return 0;\n  }\n  let magnitudeSquared1 = 0;\n  let magnitudeSquared2 = 0;\n  let dotProduct = 0;\n  for (let i = 0; i < n; i++) {\n    const value1 = vector1[i];\n    const value2 = vector2[i];\n    magnitudeSquared1 += value1 * value1;\n    magnitudeSquared2 += value2 * value2;\n    dotProduct += value1 * value2;\n  }\n  return magnitudeSquared1 === 0 || magnitudeSquared2 === 0 ? 0 : dotProduct / (Math.sqrt(magnitudeSquared1) * Math.sqrt(magnitudeSquared2));\n}\n\n// core/util/simulate-readable-stream.ts\n\nfunction simulateReadableStream({\n  chunks,\n  initialDelayInMs = 0,\n  chunkDelayInMs = 0,\n  _internal\n}) {\n  var _a17;\n  const delay2 = (_a17 = _internal == null ? void 0 : _internal.delay) != null ? _a17 : _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay;\n  let index = 0;\n  return new ReadableStream({\n    async pull(controller) {\n      if (index < chunks.length) {\n        await delay2(index === 0 ? initialDelayInMs : chunkDelayInMs);\n        controller.enqueue(chunks[index++]);\n      } else {\n        controller.close();\n      }\n    }\n  });\n}\n\n// streams/assistant-response.ts\n\nfunction AssistantResponse({ threadId, messageId }, process2) {\n  const stream = new ReadableStream({\n    async start(controller) {\n      var _a17;\n      const textEncoder = new TextEncoder();\n      const sendMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode(\n            (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"assistant_message\", message)\n          )\n        );\n      };\n      const sendDataMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode(\n            (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"data_message\", message)\n          )\n        );\n      };\n      const sendError = (errorMessage) => {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"error\", errorMessage))\n        );\n      };\n      const forwardStream = async (stream2) => {\n        var _a18, _b;\n        let result = void 0;\n        for await (const value of stream2) {\n          switch (value.event) {\n            case \"thread.message.created\": {\n              controller.enqueue(\n                textEncoder.encode(\n                  (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"assistant_message\", {\n                    id: value.data.id,\n                    role: \"assistant\",\n                    content: [{ type: \"text\", text: { value: \"\" } }]\n                  })\n                )\n              );\n              break;\n            }\n            case \"thread.message.delta\": {\n              const content = (_a18 = value.data.delta.content) == null ? void 0 : _a18[0];\n              if ((content == null ? void 0 : content.type) === \"text\" && ((_b = content.text) == null ? void 0 : _b.value) != null) {\n                controller.enqueue(\n                  textEncoder.encode(\n                    (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"text\", content.text.value)\n                  )\n                );\n              }\n              break;\n            }\n            case \"thread.run.completed\":\n            case \"thread.run.requires_action\": {\n              result = value.data;\n              break;\n            }\n          }\n        }\n        return result;\n      };\n      controller.enqueue(\n        textEncoder.encode(\n          (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"assistant_control_data\", {\n            threadId,\n            messageId\n          })\n        )\n      );\n      try {\n        await process2({\n          sendMessage,\n          sendDataMessage,\n          forwardStream\n        });\n      } catch (error) {\n        sendError((_a17 = error.message) != null ? _a17 : `${error}`);\n      } finally {\n        controller.close();\n      }\n    },\n    pull(controller) {\n    },\n    cancel() {\n    }\n  });\n  return new Response(stream, {\n    status: 200,\n    headers: {\n      \"Content-Type\": \"text/plain; charset=utf-8\"\n    }\n  });\n}\n\n// streams/langchain-adapter.ts\nvar langchain_adapter_exports = {};\n__export(langchain_adapter_exports, {\n  mergeIntoDataStream: () => mergeIntoDataStream,\n  toDataStream: () => toDataStream,\n  toDataStreamResponse: () => toDataStreamResponse\n});\n\n\n// streams/stream-callbacks.ts\nfunction createCallbacksTransformer(callbacks = {}) {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = \"\";\n  return new TransformStream({\n    async start() {\n      if (callbacks.onStart)\n        await callbacks.onStart();\n    },\n    async transform(message, controller) {\n      controller.enqueue(textEncoder.encode(message));\n      aggregatedResponse += message;\n      if (callbacks.onToken)\n        await callbacks.onToken(message);\n      if (callbacks.onText && typeof message === \"string\") {\n        await callbacks.onText(message);\n      }\n    },\n    async flush() {\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n      if (callbacks.onFinal) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    }\n  });\n}\n\n// streams/langchain-adapter.ts\nfunction toDataStreamInternal(stream, callbacks) {\n  return stream.pipeThrough(\n    new TransformStream({\n      transform: async (value, controller) => {\n        var _a17;\n        if (typeof value === \"string\") {\n          controller.enqueue(value);\n          return;\n        }\n        if (\"event\" in value) {\n          if (value.event === \"on_chat_model_stream\") {\n            forwardAIMessageChunk(\n              (_a17 = value.data) == null ? void 0 : _a17.chunk,\n              controller\n            );\n          }\n          return;\n        }\n        forwardAIMessageChunk(value, controller);\n      }\n    })\n  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(\n    new TransformStream({\n      transform: async (chunk, controller) => {\n        controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"text\", chunk));\n      }\n    })\n  );\n}\nfunction toDataStream(stream, callbacks) {\n  return toDataStreamInternal(stream, callbacks).pipeThrough(\n    new TextEncoderStream()\n  );\n}\nfunction toDataStreamResponse(stream, options) {\n  var _a17;\n  const dataStream = toDataStreamInternal(\n    stream,\n    options == null ? void 0 : options.callbacks\n  ).pipeThrough(new TextEncoderStream());\n  const data = options == null ? void 0 : options.data;\n  const init = options == null ? void 0 : options.init;\n  const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;\n  return new Response(responseStream, {\n    status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,\n    statusText: init == null ? void 0 : init.statusText,\n    headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {\n      contentType: \"text/plain; charset=utf-8\",\n      dataStreamVersion: \"v1\"\n    })\n  });\n}\nfunction mergeIntoDataStream(stream, options) {\n  options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));\n}\nfunction forwardAIMessageChunk(chunk, controller) {\n  if (typeof chunk.content === \"string\") {\n    controller.enqueue(chunk.content);\n  } else {\n    const content = chunk.content;\n    for (const item of content) {\n      if (item.type === \"text\") {\n        controller.enqueue(item.text);\n      }\n    }\n  }\n}\n\n// streams/llamaindex-adapter.ts\nvar llamaindex_adapter_exports = {};\n__export(llamaindex_adapter_exports, {\n  mergeIntoDataStream: () => mergeIntoDataStream2,\n  toDataStream: () => toDataStream2,\n  toDataStreamResponse: () => toDataStreamResponse2\n});\n\n\nfunction toDataStreamInternal2(stream, callbacks) {\n  const trimStart = trimStartOfStream();\n  return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertAsyncIteratorToReadableStream)(stream[Symbol.asyncIterator]()).pipeThrough(\n    new TransformStream({\n      async transform(message, controller) {\n        controller.enqueue(trimStart(message.delta));\n      }\n    })\n  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(\n    new TransformStream({\n      transform: async (chunk, controller) => {\n        controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"text\", chunk));\n      }\n    })\n  );\n}\nfunction toDataStream2(stream, callbacks) {\n  return toDataStreamInternal2(stream, callbacks).pipeThrough(\n    new TextEncoderStream()\n  );\n}\nfunction toDataStreamResponse2(stream, options = {}) {\n  var _a17;\n  const { init, data, callbacks } = options;\n  const dataStream = toDataStreamInternal2(stream, callbacks).pipeThrough(\n    new TextEncoderStream()\n  );\n  const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;\n  return new Response(responseStream, {\n    status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,\n    statusText: init == null ? void 0 : init.statusText,\n    headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {\n      contentType: \"text/plain; charset=utf-8\",\n      dataStreamVersion: \"v1\"\n    })\n  });\n}\nfunction mergeIntoDataStream2(stream, options) {\n  options.dataStream.merge(toDataStreamInternal2(stream, options.callbacks));\n}\nfunction trimStartOfStream() {\n  let isStreamStart = true;\n  return (text2) => {\n    if (isStreamStart) {\n      text2 = text2.trimStart();\n      if (text2)\n        isStreamStart = false;\n    }\n    return text2;\n  };\n}\n\n// streams/stream-data.ts\n\n\n// util/constants.ts\nvar HANGING_STREAM_WARNING_TIME_MS = 15 * 1e3;\n\n// streams/stream-data.ts\nvar StreamData = class {\n  constructor() {\n    this.encoder = new TextEncoder();\n    this.controller = null;\n    this.isClosed = false;\n    this.warningTimeout = null;\n    const self = this;\n    this.stream = new ReadableStream({\n      start: async (controller) => {\n        self.controller = controller;\n        if (true) {\n          self.warningTimeout = setTimeout(() => {\n            console.warn(\n              \"The data stream is hanging. Did you forget to close it with `data.close()`?\"\n            );\n          }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n      },\n      pull: (controller) => {\n      },\n      cancel: (reason) => {\n        this.isClosed = true;\n      }\n    });\n  }\n  async close() {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.close();\n    this.isClosed = true;\n    if (this.warningTimeout) {\n      clearTimeout(this.warningTimeout);\n    }\n  }\n  append(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.enqueue(\n      this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"data\", [value]))\n    );\n  }\n  appendMessageAnnotation(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.enqueue(\n      this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"message_annotations\", [value]))\n    );\n  }\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vYWlANC4zLjE2X3JlYWN0QDE4LjMuMV96b2RAMy4yNS41MS9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQ0FBb0M7QUFDcEU7O0FBRUE7QUFDNEc7QUFVbEY7O0FBRTFCO0FBQ3dEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0JBQW9CLHNFQUFvQjtBQUN4QyxPQUFPO0FBQ1A7QUFDQSxvQkFBb0Isc0VBQW9CO0FBQ3hDLE9BQU87QUFDUDtBQUNBLG9CQUFvQixzRUFBb0I7QUFDeEMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCx3QkFBd0Isc0VBQW9CO0FBQzVDLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0VBQW9CO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSTtBQUNKLGdCQUFnQixzRUFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Li9ub2RlX21vZHVsZXMvLnBucG0vYWlANC4zLjE2X3JlYWN0QDE4LjMuMV96b2RAMy4yNS41MS9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanM/ODM2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUxNyBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZTE3LCB7IGdldDogYWxsW25hbWUxN10sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBjb3JlL2luZGV4LnRzXG5pbXBvcnQgeyBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjUsIGdlbmVyYXRlSWQgYXMgZ2VuZXJhdGVJZDIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHtcbiAgZm9ybWF0QXNzaXN0YW50U3RyZWFtUGFydCxcbiAgZm9ybWF0RGF0YVN0cmVhbVBhcnQgYXMgZm9ybWF0RGF0YVN0cmVhbVBhcnQzLFxuICBqc29uU2NoZW1hIGFzIGpzb25TY2hlbWEyLFxuICBwYXJzZUFzc2lzdGFudFN0cmVhbVBhcnQsXG4gIHBhcnNlRGF0YVN0cmVhbVBhcnQsXG4gIHByb2Nlc3NEYXRhU3RyZWFtLFxuICBwcm9jZXNzVGV4dFN0cmVhbSxcbiAgem9kU2NoZW1hXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIGNvcmUvZGF0YS1zdHJlYW0vY3JlYXRlLWRhdGEtc3RyZWFtLnRzXG5pbXBvcnQgeyBmb3JtYXREYXRhU3RyZWFtUGFydCB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiBjcmVhdGVEYXRhU3RyZWFtKHtcbiAgZXhlY3V0ZSxcbiAgb25FcnJvciA9ICgpID0+IFwiQW4gZXJyb3Igb2NjdXJyZWQuXCJcbiAgLy8gbWFzayBlcnJvciBtZXNzYWdlcyBmb3Igc2FmZXR5IGJ5IGRlZmF1bHRcbn0pIHtcbiAgbGV0IGNvbnRyb2xsZXI7XG4gIGNvbnN0IG9uZ29pbmdTdHJlYW1Qcm9taXNlcyA9IFtdO1xuICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXJBcmcpIHtcbiAgICAgIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyQXJnO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIHNhZmVFbnF1ZXVlKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZXhlY3V0ZSh7XG4gICAgICB3cml0ZShkYXRhKSB7XG4gICAgICAgIHNhZmVFbnF1ZXVlKGRhdGEpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlRGF0YShkYXRhKSB7XG4gICAgICAgIHNhZmVFbnF1ZXVlKGZvcm1hdERhdGFTdHJlYW1QYXJ0KFwiZGF0YVwiLCBbZGF0YV0pKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZU1lc3NhZ2VBbm5vdGF0aW9uKGFubm90YXRpb24pIHtcbiAgICAgICAgc2FmZUVucXVldWUoZm9ybWF0RGF0YVN0cmVhbVBhcnQoXCJtZXNzYWdlX2Fubm90YXRpb25zXCIsIFthbm5vdGF0aW9uXSkpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlU291cmNlKHNvdXJjZSkge1xuICAgICAgICBzYWZlRW5xdWV1ZShmb3JtYXREYXRhU3RyZWFtUGFydChcInNvdXJjZVwiLCBzb3VyY2UpKTtcbiAgICAgIH0sXG4gICAgICBtZXJnZShzdHJlYW1BcmcpIHtcbiAgICAgICAgb25nb2luZ1N0cmVhbVByb21pc2VzLnB1c2goXG4gICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbUFyZy5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBzYWZlRW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHNhZmVFbnF1ZXVlKGZvcm1hdERhdGFTdHJlYW1QYXJ0KFwiZXJyb3JcIiwgb25FcnJvcihlcnJvcikpKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3JcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBvbmdvaW5nU3RyZWFtUHJvbWlzZXMucHVzaChcbiAgICAgICAgcmVzdWx0LmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgIHNhZmVFbnF1ZXVlKGZvcm1hdERhdGFTdHJlYW1QYXJ0KFwiZXJyb3JcIiwgb25FcnJvcihlcnJvcikpKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHNhZmVFbnF1ZXVlKGZvcm1hdERhdGFTdHJlYW1QYXJ0KFwiZXJyb3JcIiwgb25FcnJvcihlcnJvcikpKTtcbiAgfVxuICBjb25zdCB3YWl0Rm9yU3RyZWFtcyA9IG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgd2hpbGUgKG9uZ29pbmdTdHJlYW1Qcm9taXNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCBvbmdvaW5nU3RyZWFtUHJvbWlzZXMuc2hpZnQoKTtcbiAgICB9XG4gICAgcmVzb2x2ZSgpO1xuICB9KTtcbiAgd2FpdEZvclN0cmVhbXMuZmluYWxseSgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzdHJlYW07XG59XG5cbi8vIGNvcmUvdXRpbC9wcmVwYXJlLXJlc3BvbnNlLWhlYWRlcnMudHNcbmZ1bmN0aW9uIHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaGVhZGVycywge1xuICBjb250ZW50VHlwZSxcbiAgZGF0YVN0cmVhbVZlcnNpb25cbn0pIHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gbmV3IEhlYWRlcnMoaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9KTtcbiAgaWYgKCFyZXNwb25zZUhlYWRlcnMuaGFzKFwiQ29udGVudC1UeXBlXCIpKSB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBjb250ZW50VHlwZSk7XG4gIH1cbiAgaWYgKGRhdGFTdHJlYW1WZXJzaW9uICE9PSB2b2lkIDApIHtcbiAgICByZXNwb25zZUhlYWRlcnMuc2V0KFwiWC1WZXJjZWwtQUktRGF0YS1TdHJlYW1cIiwgZGF0YVN0cmVhbVZlcnNpb24pO1xuICB9XG4gIHJldHVybiByZXNwb25zZUhlYWRlcnM7XG59XG5cbi8vIGNvcmUvZGF0YS1zdHJlYW0vY3JlYXRlLWRhdGEtc3RyZWFtLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBjcmVhdGVEYXRhU3RyZWFtUmVzcG9uc2Uoe1xuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIGV4ZWN1dGUsXG4gIG9uRXJyb3Jcbn0pIHtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICBjcmVhdGVEYXRhU3RyZWFtKHsgZXhlY3V0ZSwgb25FcnJvciB9KS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSksXG4gICAge1xuICAgICAgc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaGVhZGVycywge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgIGRhdGFTdHJlYW1WZXJzaW9uOiBcInYxXCJcbiAgICAgIH0pXG4gICAgfVxuICApO1xufVxuXG4vLyBjb3JlL3V0aWwvcHJlcGFyZS1vdXRnb2luZy1odHRwLWhlYWRlcnMudHNcbmZ1bmN0aW9uIHByZXBhcmVPdXRnb2luZ0h0dHBIZWFkZXJzKGhlYWRlcnMsIHtcbiAgY29udGVudFR5cGUsXG4gIGRhdGFTdHJlYW1WZXJzaW9uXG59KSB7XG4gIGNvbnN0IG91dGdvaW5nSGVhZGVycyA9IHt9O1xuICBpZiAoaGVhZGVycyAhPSBudWxsKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgIG91dGdvaW5nSGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIGlmIChvdXRnb2luZ0hlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPT0gbnVsbCkge1xuICAgIG91dGdvaW5nSGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IGNvbnRlbnRUeXBlO1xuICB9XG4gIGlmIChkYXRhU3RyZWFtVmVyc2lvbiAhPT0gdm9pZCAwKSB7XG4gICAgb3V0Z29pbmdIZWFkZXJzW1wiWC1WZXJjZWwtQUktRGF0YS1TdHJlYW1cIl0gPSBkYXRhU3RyZWFtVmVyc2lvbjtcbiAgfVxuICByZXR1cm4gb3V0Z29pbmdIZWFkZXJzO1xufVxuXG4vLyBjb3JlL3V0aWwvd3JpdGUtdG8tc2VydmVyLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICByZXNwb25zZSxcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBoZWFkZXJzLFxuICBzdHJlYW1cbn0pIHtcbiAgcmVzcG9uc2Uud3JpdGVIZWFkKHN0YXR1cyAhPSBudWxsID8gc3RhdHVzIDogMjAwLCBzdGF0dXNUZXh0LCBoZWFkZXJzKTtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICBjb25zdCByZWFkID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgcmVzcG9uc2Uud3JpdGUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgfVxuICB9O1xuICByZWFkKCk7XG59XG5cbi8vIGNvcmUvZGF0YS1zdHJlYW0vcGlwZS1kYXRhLXN0cmVhbS10by1yZXNwb25zZS50c1xuZnVuY3Rpb24gcGlwZURhdGFTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCB7XG4gIHN0YXR1cyxcbiAgc3RhdHVzVGV4dCxcbiAgaGVhZGVycyxcbiAgZXhlY3V0ZSxcbiAgb25FcnJvclxufSkge1xuICB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICAgIHJlc3BvbnNlLFxuICAgIHN0YXR1cyxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHByZXBhcmVPdXRnb2luZ0h0dHBIZWFkZXJzKGhlYWRlcnMsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgIGRhdGFTdHJlYW1WZXJzaW9uOiBcInYxXCJcbiAgICB9KSxcbiAgICBzdHJlYW06IGNyZWF0ZURhdGFTdHJlYW0oeyBleGVjdXRlLCBvbkVycm9yIH0pLnBpcGVUaHJvdWdoKFxuICAgICAgbmV3IFRleHRFbmNvZGVyU3RyZWFtKClcbiAgICApXG4gIH0pO1xufVxuXG4vLyBlcnJvcnMvaW52YWxpZC1hcmd1bWVudC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZSA9IFwiQUlfSW52YWxpZEFyZ3VtZW50RXJyb3JcIjtcbnZhciBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXJhbWV0ZXIsXG4gICAgdmFsdWUsXG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZSxcbiAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIGFyZ3VtZW50IGZvciBwYXJhbWV0ZXIgJHtwYXJhbWV0ZXJ9OiAke21lc3NhZ2V9YFxuICAgIH0pO1xuICAgIHRoaXNbX2FdID0gdHJ1ZTtcbiAgICB0aGlzLnBhcmFtZXRlciA9IHBhcmFtZXRlcjtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cbn07XG5fYSA9IHN5bWJvbDtcblxuLy8gdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBkZWxheSwgZ2V0RXJyb3JNZXNzYWdlLCBpc0Fib3J0RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyB1dGlsL3JldHJ5LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMiA9IFwiQUlfUmV0cnlFcnJvclwiO1xudmFyIG1hcmtlcjIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTJ9YDtcbnZhciBzeW1ib2wyID0gU3ltYm9sLmZvcihtYXJrZXIyKTtcbnZhciBfYTI7XG52YXIgUmV0cnlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjIge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSxcbiAgICByZWFzb24sXG4gICAgZXJyb3JzXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUyLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2EyXSA9IHRydWU7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5sYXN0RXJyb3IgPSBlcnJvcnNbZXJyb3JzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IyLmhhc01hcmtlcihlcnJvciwgbWFya2VyMik7XG4gIH1cbn07XG5fYTIgPSBzeW1ib2wyO1xuXG4vLyB1dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50c1xudmFyIHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiA9ICh7XG4gIG1heFJldHJpZXMgPSAyLFxuICBpbml0aWFsRGVsYXlJbk1zID0gMmUzLFxuICBiYWNrb2ZmRmFjdG9yID0gMlxufSA9IHt9KSA9PiBhc3luYyAoZikgPT4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gIG1heFJldHJpZXMsXG4gIGRlbGF5SW5NczogaW5pdGlhbERlbGF5SW5NcyxcbiAgYmFja29mZkZhY3RvclxufSk7XG5hc3luYyBmdW5jdGlvbiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKGYsIHtcbiAgbWF4UmV0cmllcyxcbiAgZGVsYXlJbk1zLFxuICBiYWNrb2ZmRmFjdG9yXG59LCBlcnJvcnMgPSBbXSkge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBmKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA9PT0gMCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZShlcnJvcik7XG4gICAgY29uc3QgbmV3RXJyb3JzID0gWy4uLmVycm9ycywgZXJyb3JdO1xuICAgIGNvbnN0IHRyeU51bWJlciA9IG5ld0Vycm9ycy5sZW5ndGg7XG4gICAgaWYgKHRyeU51bWJlciA+IG1heFJldHJpZXMpIHtcbiAgICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMuIExhc3QgZXJyb3I6ICR7ZXJyb3JNZXNzYWdlfWAsXG4gICAgICAgIHJlYXNvbjogXCJtYXhSZXRyaWVzRXhjZWVkZWRcIixcbiAgICAgICAgZXJyb3JzOiBuZXdFcnJvcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBBUElDYWxsRXJyb3IuaXNJbnN0YW5jZShlcnJvcikgJiYgZXJyb3IuaXNSZXRyeWFibGUgPT09IHRydWUgJiYgdHJ5TnVtYmVyIDw9IG1heFJldHJpZXMpIHtcbiAgICAgIGF3YWl0IGRlbGF5KGRlbGF5SW5Ncyk7XG4gICAgICByZXR1cm4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihcbiAgICAgICAgZixcbiAgICAgICAgeyBtYXhSZXRyaWVzLCBkZWxheUluTXM6IGJhY2tvZmZGYWN0b3IgKiBkZWxheUluTXMsIGJhY2tvZmZGYWN0b3IgfSxcbiAgICAgICAgbmV3RXJyb3JzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHJ5TnVtYmVyID09PSAxKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMgd2l0aCBub24tcmV0cnlhYmxlIGVycm9yOiAnJHtlcnJvck1lc3NhZ2V9J2AsXG4gICAgICByZWFzb246IFwiZXJyb3JOb3RSZXRyeWFibGVcIixcbiAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gY29yZS9wcm9tcHQvcHJlcGFyZS1yZXRyaWVzLnRzXG5mdW5jdGlvbiBwcmVwYXJlUmV0cmllcyh7XG4gIG1heFJldHJpZXNcbn0pIHtcbiAgaWYgKG1heFJldHJpZXMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXRyaWVzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlID49IDBcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG1heFJldHJpZXNSZXN1bHQgPSBtYXhSZXRyaWVzICE9IG51bGwgPyBtYXhSZXRyaWVzIDogMjtcbiAgcmV0dXJuIHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzUmVzdWx0LFxuICAgIHJldHJ5OiByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzUmVzdWx0IH0pXG4gIH07XG59XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L2Fzc2VtYmxlLW9wZXJhdGlvbi1uYW1lLnRzXG5mdW5jdGlvbiBhc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICBvcGVyYXRpb25JZCxcbiAgdGVsZW1ldHJ5XG59KSB7XG4gIHJldHVybiB7XG4gICAgLy8gc3RhbmRhcmRpemVkIG9wZXJhdGlvbiBhbmQgcmVzb3VyY2UgbmFtZTpcbiAgICBcIm9wZXJhdGlvbi5uYW1lXCI6IGAke29wZXJhdGlvbklkfSR7KHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWQpICE9IG51bGwgPyBgICR7dGVsZW1ldHJ5LmZ1bmN0aW9uSWR9YCA6IFwiXCJ9YCxcbiAgICBcInJlc291cmNlLm5hbWVcIjogdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuZnVuY3Rpb25JZCxcbiAgICAvLyBkZXRhaWxlZCwgQUkgU0RLIHNwZWNpZmljIGRhdGE6XG4gICAgXCJhaS5vcGVyYXRpb25JZFwiOiBvcGVyYXRpb25JZCxcbiAgICBcImFpLnRlbGVtZXRyeS5mdW5jdGlvbklkXCI6IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWRcbiAgfTtcbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvZ2V0LWJhc2UtdGVsZW1ldHJ5LWF0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgbW9kZWwsXG4gIHNldHRpbmdzLFxuICB0ZWxlbWV0cnksXG4gIGhlYWRlcnNcbn0pIHtcbiAgdmFyIF9hMTc7XG4gIHJldHVybiB7XG4gICAgXCJhaS5tb2RlbC5wcm92aWRlclwiOiBtb2RlbC5wcm92aWRlcixcbiAgICBcImFpLm1vZGVsLmlkXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgLy8gc2V0dGluZ3M6XG4gICAgLi4uT2JqZWN0LmVudHJpZXMoc2V0dGluZ3MpLnJlZHVjZSgoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBhdHRyaWJ1dGVzW2BhaS5zZXR0aW5ncy4ke2tleX1gXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfSwge30pLFxuICAgIC8vIGFkZCBtZXRhZGF0YSBhcyBhdHRyaWJ1dGVzOlxuICAgIC4uLk9iamVjdC5lbnRyaWVzKChfYTE3ID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkubWV0YWRhdGEpICE9IG51bGwgPyBfYTE3IDoge30pLnJlZHVjZShcbiAgICAgIChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgYXR0cmlidXRlc1tgYWkudGVsZW1ldHJ5Lm1ldGFkYXRhLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICAvLyByZXF1ZXN0IGhlYWRlcnNcbiAgICAuLi5PYmplY3QuZW50cmllcyhoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30pLnJlZHVjZSgoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBhdHRyaWJ1dGVzW2BhaS5yZXF1ZXN0LmhlYWRlcnMuJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH0sIHt9KVxuICB9O1xufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9nZXQtdHJhY2VyLnRzXG5pbXBvcnQgeyB0cmFjZSB9IGZyb20gXCJAb3BlbnRlbGVtZXRyeS9hcGlcIjtcblxuLy8gY29yZS90ZWxlbWV0cnkvbm9vcC10cmFjZXIudHNcbnZhciBub29wVHJhY2VyID0ge1xuICBzdGFydFNwYW4oKSB7XG4gICAgcmV0dXJuIG5vb3BTcGFuO1xuICB9LFxuICBzdGFydEFjdGl2ZVNwYW4obmFtZTE3LCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBhcmcxKG5vb3BTcGFuKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmcyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBhcmcyKG5vb3BTcGFuKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmczID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBhcmczKG5vb3BTcGFuKTtcbiAgICB9XG4gIH1cbn07XG52YXIgbm9vcFNwYW4gPSB7XG4gIHNwYW5Db250ZXh0KCkge1xuICAgIHJldHVybiBub29wU3BhbkNvbnRleHQ7XG4gIH0sXG4gIHNldEF0dHJpYnV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc2V0QXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZExpbmsoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZExpbmtzKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzZXRTdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHVwZGF0ZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgaXNSZWNvcmRpbmcoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICByZWNvcmRFeGNlcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgbm9vcFNwYW5Db250ZXh0ID0ge1xuICB0cmFjZUlkOiBcIlwiLFxuICBzcGFuSWQ6IFwiXCIsXG4gIHRyYWNlRmxhZ3M6IDBcbn07XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L2dldC10cmFjZXIudHNcbmZ1bmN0aW9uIGdldFRyYWNlcih7XG4gIGlzRW5hYmxlZCA9IGZhbHNlLFxuICB0cmFjZXJcbn0gPSB7fSkge1xuICBpZiAoIWlzRW5hYmxlZCkge1xuICAgIHJldHVybiBub29wVHJhY2VyO1xuICB9XG4gIGlmICh0cmFjZXIpIHtcbiAgICByZXR1cm4gdHJhY2VyO1xuICB9XG4gIHJldHVybiB0cmFjZS5nZXRUcmFjZXIoXCJhaVwiKTtcbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvcmVjb3JkLXNwYW4udHNcbmltcG9ydCB7IFNwYW5TdGF0dXNDb2RlIH0gZnJvbSBcIkBvcGVudGVsZW1ldHJ5L2FwaVwiO1xuZnVuY3Rpb24gcmVjb3JkU3Bhbih7XG4gIG5hbWU6IG5hbWUxNyxcbiAgdHJhY2VyLFxuICBhdHRyaWJ1dGVzLFxuICBmbixcbiAgZW5kV2hlbkRvbmUgPSB0cnVlXG59KSB7XG4gIHJldHVybiB0cmFjZXIuc3RhcnRBY3RpdmVTcGFuKG5hbWUxNywgeyBhdHRyaWJ1dGVzIH0sIGFzeW5jIChzcGFuKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKHNwYW4pO1xuICAgICAgaWYgKGVuZFdoZW5Eb25lKSB7XG4gICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHNwYW4ucmVjb3JkRXhjZXB0aW9uKHtcbiAgICAgICAgICAgIG5hbWU6IGVycm9yLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgY29kZTogU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBTcGFuU3RhdHVzQ29kZS5FUlJPUiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L3NlbGVjdC10ZWxlbWV0cnktYXR0cmlidXRlcy50c1xuZnVuY3Rpb24gc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gIHRlbGVtZXRyeSxcbiAgYXR0cmlidXRlc1xufSkge1xuICBpZiAoKHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmlzRW5hYmxlZCkgIT09IHRydWUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpLnJlZHVjZSgoYXR0cmlidXRlczIsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlczI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCJpbnB1dFwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnB1dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAoKHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LnJlY29yZElucHV0cykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLmlucHV0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB2b2lkIDAgPyBhdHRyaWJ1dGVzMiA6IHsgLi4uYXR0cmlidXRlczIsIFtrZXldOiByZXN1bHQgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcIm91dHB1dFwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5vdXRwdXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKCh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5yZWNvcmRPdXRwdXRzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMyO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUub3V0cHV0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB2b2lkIDAgPyBhdHRyaWJ1dGVzMiA6IHsgLi4uYXR0cmlidXRlczIsIFtrZXldOiByZXN1bHQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4uYXR0cmlidXRlczIsIFtrZXldOiB2YWx1ZSB9O1xuICB9LCB7fSk7XG59XG5cbi8vIGNvcmUvZW1iZWQvZW1iZWQudHNcbmFzeW5jIGZ1bmN0aW9uIGVtYmVkKHtcbiAgbW9kZWwsXG4gIHZhbHVlLFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5XG59KSB7XG4gIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHsgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyB9KTtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuZW1iZWRcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHsgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWRcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgXCJhaS52YWx1ZVwiOiB7IGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgfVxuICAgICAgfVxuICAgIH0pLFxuICAgIHRyYWNlcixcbiAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgIGNvbnN0IHsgZW1iZWRkaW5nLCB1c2FnZSwgcmF3UmVzcG9uc2UgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAoKSA9PiAoXG4gICAgICAgICAgLy8gbmVzdGVkIHNwYW5zIHRvIGFsaWduIHdpdGggdGhlIGVtYmVkTWFueSB0ZWxlbWV0cnkgZGF0YTpcbiAgICAgICAgICByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuZW1iZWQuZG9FbWJlZFwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5lbWJlZC5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjogeyBpbnB1dDogKCkgPT4gW0pTT04uc3RyaW5naWZ5KHZhbHVlKV0gfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9FbWJlZFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTc7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFt2YWx1ZV0sXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nMiA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5nc1swXTtcbiAgICAgICAgICAgICAgY29uc3QgdXNhZ2UyID0gKF9hMTcgPSBtb2RlbFJlc3BvbnNlLnVzYWdlKSAhPSBudWxsID8gX2ExNyA6IHsgdG9rZW5zOiBOYU4gfTtcbiAgICAgICAgICAgICAgZG9FbWJlZFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAoZW1iZWRkaW5nMykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nMylcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlMi50b2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVtYmVkZGluZzogZW1iZWRkaW5nMixcbiAgICAgICAgICAgICAgICB1c2FnZTogdXNhZ2UyLFxuICAgICAgICAgICAgICAgIHJhd1Jlc3BvbnNlOiBtb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nXCI6IHsgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpIH0sXG4gICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZS50b2tlbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRSZXN1bHQoeyB2YWx1ZSwgZW1iZWRkaW5nLCB1c2FnZSwgcmF3UmVzcG9uc2UgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0RW1iZWRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB0aGlzLmVtYmVkZGluZyA9IG9wdGlvbnMuZW1iZWRkaW5nO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMucmF3UmVzcG9uc2UgPSBvcHRpb25zLnJhd1Jlc3BvbnNlO1xuICB9XG59O1xuXG4vLyBjb3JlL3V0aWwvc3BsaXQtYXJyYXkudHNcbmZ1bmN0aW9uIHNwbGl0QXJyYXkoYXJyYXksIGNodW5rU2l6ZSkge1xuICBpZiAoY2h1bmtTaXplIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaHVua1NpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMFwiKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgcmVzdWx0LnB1c2goYXJyYXkuc2xpY2UoaSwgaSArIGNodW5rU2l6ZSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGNvcmUvZW1iZWQvZW1iZWQtbWFueS50c1xuYXN5bmMgZnVuY3Rpb24gZW1iZWRNYW55KHtcbiAgbW9kZWwsXG4gIHZhbHVlcyxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7IG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcgfSk7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLmVtYmVkTWFueVwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5lbWJlZE1hbnlcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICBjb25zdCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCA9IG1vZGVsLm1heEVtYmVkZGluZ3NQZXJDYWxsO1xuICAgICAgaWYgKG1heEVtYmVkZGluZ3NQZXJDYWxsID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMiwgdXNhZ2UgfSA9IGF3YWl0IHJldHJ5KCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9FbWJlZFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTc7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nczMgPSBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3M7XG4gICAgICAgICAgICAgIGNvbnN0IHVzYWdlMiA9IChfYTE3ID0gbW9kZWxSZXNwb25zZS51c2FnZSkgIT0gbnVsbCA/IF9hMTcgOiB7IHRva2VuczogTmFOIH07XG4gICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMy5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7IGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MzLCB1c2FnZTogdXNhZ2UyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMi5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UudG9rZW5zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRNYW55UmVzdWx0KHsgdmFsdWVzLCBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMiwgdXNhZ2UgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZUNodW5rcyA9IHNwbGl0QXJyYXkodmFsdWVzLCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCk7XG4gICAgICBjb25zdCBlbWJlZGRpbmdzID0gW107XG4gICAgICBsZXQgdG9rZW5zID0gMDtcbiAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgdmFsdWVDaHVua3MpIHtcbiAgICAgICAgY29uc3QgeyBlbWJlZGRpbmdzOiByZXNwb25zZUVtYmVkZGluZ3MsIHVzYWdlIH0gPSBhd2FpdCByZXRyeSgoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICAgIFwiYWkudmFsdWVzXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBjaHVuay5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9FbWJlZFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTc7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGNodW5rLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IGVtYmVkZGluZ3MyID0gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzO1xuICAgICAgICAgICAgICBjb25zdCB1c2FnZTIgPSAoX2ExNyA9IG1vZGVsUmVzcG9uc2UudXNhZ2UpICE9IG51bGwgPyBfYTE3IDogeyB0b2tlbnM6IE5hTiB9O1xuICAgICAgICAgICAgICBkb0VtYmVkU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5nczIubWFwKChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlMi50b2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4geyBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMiwgdXNhZ2U6IHVzYWdlMiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZW1iZWRkaW5ncy5wdXNoKC4uLnJlc3BvbnNlRW1iZWRkaW5ncyk7XG4gICAgICAgIHRva2VucyArPSB1c2FnZS50b2tlbnM7XG4gICAgICB9XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MubWFwKChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdG9rZW5zXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdEVtYmVkTWFueVJlc3VsdCh7XG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgZW1iZWRkaW5ncyxcbiAgICAgICAgdXNhZ2U6IHsgdG9rZW5zIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdEVtYmVkTWFueVJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gICAgdGhpcy5lbWJlZGRpbmdzID0gb3B0aW9ucy5lbWJlZGRpbmdzO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICB9XG59O1xuXG4vLyBlcnJvcnMvbm8taW1hZ2UtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMyA9IFwiQUlfTm9JbWFnZUdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDMgPSBTeW1ib2wuZm9yKG1hcmtlcjMpO1xudmFyIF9hMztcbnZhciBOb0ltYWdlR2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UgPSBcIk5vIGltYWdlIGdlbmVyYXRlZC5cIixcbiAgICBjYXVzZSxcbiAgICByZXNwb25zZXNcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTMsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2EzXSA9IHRydWU7XG4gICAgdGhpcy5yZXNwb25zZXMgPSByZXNwb25zZXM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjMuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIzKTtcbiAgfVxufTtcbl9hMyA9IHN5bWJvbDM7XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZWQtZmlsZS50c1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIERlZmF1bHRHZW5lcmF0ZWRGaWxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZGF0YSxcbiAgICBtaW1lVHlwZVxuICB9KSB7XG4gICAgY29uc3QgaXNVaW50OEFycmF5ID0gZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgdGhpcy5iYXNlNjREYXRhID0gaXNVaW50OEFycmF5ID8gdm9pZCAwIDogZGF0YTtcbiAgICB0aGlzLnVpbnQ4QXJyYXlEYXRhID0gaXNVaW50OEFycmF5ID8gZGF0YSA6IHZvaWQgMDtcbiAgICB0aGlzLm1pbWVUeXBlID0gbWltZVR5cGU7XG4gIH1cbiAgLy8gbGF6eSBjb252ZXJzaW9uIHdpdGggY2FjaGluZyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBjb252ZXJzaW9uIG92ZXJoZWFkOlxuICBnZXQgYmFzZTY0KCkge1xuICAgIGlmICh0aGlzLmJhc2U2NERhdGEgPT0gbnVsbCkge1xuICAgICAgdGhpcy5iYXNlNjREYXRhID0gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCh0aGlzLnVpbnQ4QXJyYXlEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYmFzZTY0RGF0YTtcbiAgfVxuICAvLyBsYXp5IGNvbnZlcnNpb24gd2l0aCBjYWNoaW5nIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbnZlcnNpb24gb3ZlcmhlYWQ6XG4gIGdldCB1aW50OEFycmF5KCkge1xuICAgIGlmICh0aGlzLnVpbnQ4QXJyYXlEYXRhID09IG51bGwpIHtcbiAgICAgIHRoaXMudWludDhBcnJheURhdGEgPSBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KHRoaXMuYmFzZTY0RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVpbnQ4QXJyYXlEYXRhO1xuICB9XG59O1xudmFyIERlZmF1bHRHZW5lcmF0ZWRGaWxlV2l0aFR5cGUgPSBjbGFzcyBleHRlbmRzIERlZmF1bHRHZW5lcmF0ZWRGaWxlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMudHlwZSA9IFwiZmlsZVwiO1xuICB9XG59O1xuXG4vLyBjb3JlL3V0aWwvZGV0ZWN0LW1pbWV0eXBlLnRzXG5pbXBvcnQgeyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5IGFzIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbnZhciBpbWFnZU1pbWVUeXBlU2lnbmF0dXJlcyA9IFtcbiAge1xuICAgIG1pbWVUeXBlOiBcImltYWdlL2dpZlwiLFxuICAgIGJ5dGVzUHJlZml4OiBbNzEsIDczLCA3MF0sXG4gICAgYmFzZTY0UHJlZml4OiBcIlIwbEdcIlxuICB9LFxuICB7XG4gICAgbWltZVR5cGU6IFwiaW1hZ2UvcG5nXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsxMzcsIDgwLCA3OCwgNzFdLFxuICAgIGJhc2U2NFByZWZpeDogXCJpVkJPUndcIlxuICB9LFxuICB7XG4gICAgbWltZVR5cGU6IFwiaW1hZ2UvanBlZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMjU1LCAyMTZdLFxuICAgIGJhc2U2NFByZWZpeDogXCIvOWovXCJcbiAgfSxcbiAge1xuICAgIG1pbWVUeXBlOiBcImltYWdlL3dlYnBcIixcbiAgICBieXRlc1ByZWZpeDogWzgyLCA3MywgNzAsIDcwXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiVWtsR1JnXCJcbiAgfSxcbiAge1xuICAgIG1pbWVUeXBlOiBcImltYWdlL2JtcFwiLFxuICAgIGJ5dGVzUHJlZml4OiBbNjYsIDc3XSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiUWtcIlxuICB9LFxuICB7XG4gICAgbWltZVR5cGU6IFwiaW1hZ2UvdGlmZlwiLFxuICAgIGJ5dGVzUHJlZml4OiBbNzMsIDczLCA0MiwgMF0sXG4gICAgYmFzZTY0UHJlZml4OiBcIlNVa3FBQVwiXG4gIH0sXG4gIHtcbiAgICBtaW1lVHlwZTogXCJpbWFnZS90aWZmXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs3NywgNzcsIDAsIDQyXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiVFUwQUtnXCJcbiAgfSxcbiAge1xuICAgIG1pbWVUeXBlOiBcImltYWdlL2F2aWZcIixcbiAgICBieXRlc1ByZWZpeDogW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMzIsXG4gICAgICAxMDIsXG4gICAgICAxMTYsXG4gICAgICAxMjEsXG4gICAgICAxMTIsXG4gICAgICA5NyxcbiAgICAgIDExOCxcbiAgICAgIDEwNSxcbiAgICAgIDEwMlxuICAgIF0sXG4gICAgYmFzZTY0UHJlZml4OiBcIkFBQUFJR1owZVhCaGRtbG1cIlxuICB9LFxuICB7XG4gICAgbWltZVR5cGU6IFwiaW1hZ2UvaGVpY1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAzMixcbiAgICAgIDEwMixcbiAgICAgIDExNixcbiAgICAgIDEyMSxcbiAgICAgIDExMixcbiAgICAgIDEwNCxcbiAgICAgIDEwMSxcbiAgICAgIDEwNSxcbiAgICAgIDk5XG4gICAgXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiQUFBQUlHWjBlWEJvWldsalwiXG4gIH1cbl07XG52YXIgYXVkaW9NaW1lVHlwZVNpZ25hdHVyZXMgPSBbXG4gIHtcbiAgICBtaW1lVHlwZTogXCJhdWRpby9tcGVnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNTUsIDI1MV0sXG4gICAgYmFzZTY0UHJlZml4OiBcIi8vcz1cIlxuICB9LFxuICB7XG4gICAgbWltZVR5cGU6IFwiYXVkaW8vd2F2XCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs4MiwgNzMsIDcwLCA3MF0sXG4gICAgYmFzZTY0UHJlZml4OiBcIlVrbEdSXCJcbiAgfSxcbiAge1xuICAgIG1pbWVUeXBlOiBcImF1ZGlvL29nZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbNzksIDEwMywgMTAzLCA4M10sXG4gICAgYmFzZTY0UHJlZml4OiBcIlQyZG5Vd1wiXG4gIH0sXG4gIHtcbiAgICBtaW1lVHlwZTogXCJhdWRpby9mbGFjXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsxMDIsIDc2LCA5NywgNjddLFxuICAgIGJhc2U2NFByZWZpeDogXCJaa3hoUXdcIlxuICB9LFxuICB7XG4gICAgbWltZVR5cGU6IFwiYXVkaW8vYWFjXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs2NCwgMjEsIDAsIDBdLFxuICAgIGJhc2U2NFByZWZpeDogXCJRQlVBXCJcbiAgfSxcbiAge1xuICAgIG1pbWVUeXBlOiBcImF1ZGlvL21wNFwiLFxuICAgIGJ5dGVzUHJlZml4OiBbMTAyLCAxMTYsIDEyMSwgMTEyXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiWm5SNWNBXCJcbiAgfVxuXTtcbnZhciBzdHJpcElEMyA9IChkYXRhKSA9PiB7XG4gIGNvbnN0IGJ5dGVzID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5MihkYXRhKSA6IGRhdGE7XG4gIGNvbnN0IGlkM1NpemUgPSAoYnl0ZXNbNl0gJiAxMjcpIDw8IDIxIHwgKGJ5dGVzWzddICYgMTI3KSA8PCAxNCB8IChieXRlc1s4XSAmIDEyNykgPDwgNyB8IGJ5dGVzWzldICYgMTI3O1xuICByZXR1cm4gYnl0ZXMuc2xpY2UoaWQzU2l6ZSArIDEwKTtcbn07XG5mdW5jdGlvbiBzdHJpcElEM1RhZ3NJZlByZXNlbnQoZGF0YSkge1xuICBjb25zdCBoYXNJZDMgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhLnN0YXJ0c1dpdGgoXCJTVVF6XCIpIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICYmIGRhdGEubGVuZ3RoID4gMTAgJiYgZGF0YVswXSA9PT0gNzMgJiYgLy8gJ0knXG4gIGRhdGFbMV0gPT09IDY4ICYmIC8vICdEJ1xuICBkYXRhWzJdID09PSA1MTtcbiAgcmV0dXJuIGhhc0lkMyA/IHN0cmlwSUQzKGRhdGEpIDogZGF0YTtcbn1cbmZ1bmN0aW9uIGRldGVjdE1pbWVUeXBlKHtcbiAgZGF0YSxcbiAgc2lnbmF0dXJlc1xufSkge1xuICBjb25zdCBwcm9jZXNzZWREYXRhID0gc3RyaXBJRDNUYWdzSWZQcmVzZW50KGRhdGEpO1xuICBmb3IgKGNvbnN0IHNpZ25hdHVyZSBvZiBzaWduYXR1cmVzKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzZWREYXRhID09PSBcInN0cmluZ1wiID8gcHJvY2Vzc2VkRGF0YS5zdGFydHNXaXRoKHNpZ25hdHVyZS5iYXNlNjRQcmVmaXgpIDogcHJvY2Vzc2VkRGF0YS5sZW5ndGggPj0gc2lnbmF0dXJlLmJ5dGVzUHJlZml4Lmxlbmd0aCAmJiBzaWduYXR1cmUuYnl0ZXNQcmVmaXguZXZlcnkoXG4gICAgICAoYnl0ZSwgaW5kZXgpID0+IHByb2Nlc3NlZERhdGFbaW5kZXhdID09PSBieXRlXG4gICAgKSkge1xuICAgICAgcmV0dXJuIHNpZ25hdHVyZS5taW1lVHlwZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1pbWFnZS9nZW5lcmF0ZS1pbWFnZS50c1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZSh7XG4gIG1vZGVsLFxuICBwcm9tcHQsXG4gIG4gPSAxLFxuICBzaXplLFxuICBhc3BlY3RSYXRpbyxcbiAgc2VlZCxcbiAgcHJvdmlkZXJPcHRpb25zLFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVyc1xufSkge1xuICB2YXIgX2ExNztcbiAgY29uc3QgeyByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoeyBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnIH0pO1xuICBjb25zdCBtYXhJbWFnZXNQZXJDYWxsID0gKF9hMTcgPSBtb2RlbC5tYXhJbWFnZXNQZXJDYWxsKSAhPSBudWxsID8gX2ExNyA6IDE7XG4gIGNvbnN0IGNhbGxDb3VudCA9IE1hdGguY2VpbChuIC8gbWF4SW1hZ2VzUGVyQ2FsbCk7XG4gIGNvbnN0IGNhbGxJbWFnZUNvdW50cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGNhbGxDb3VudCB9LCAoXywgaSkgPT4ge1xuICAgIGlmIChpIDwgY2FsbENvdW50IC0gMSkge1xuICAgICAgcmV0dXJuIG1heEltYWdlc1BlckNhbGw7XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbmRlciA9IG4gJSBtYXhJbWFnZXNQZXJDYWxsO1xuICAgIHJldHVybiByZW1haW5kZXIgPT09IDAgPyBtYXhJbWFnZXNQZXJDYWxsIDogcmVtYWluZGVyO1xuICB9KTtcbiAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGNhbGxJbWFnZUNvdW50cy5tYXAoXG4gICAgICBhc3luYyAoY2FsbEltYWdlQ291bnQpID0+IHJldHJ5KFxuICAgICAgICAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgbjogY2FsbEltYWdlQ291bnQsXG4gICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIGFzcGVjdFJhdGlvLFxuICAgICAgICAgIHNlZWQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck9wdGlvbnMgIT0gbnVsbCA/IHByb3ZpZGVyT3B0aW9ucyA6IHt9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKVxuICApO1xuICBjb25zdCBpbWFnZXMgPSBbXTtcbiAgY29uc3Qgd2FybmluZ3MgPSBbXTtcbiAgY29uc3QgcmVzcG9uc2VzID0gW107XG4gIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBpbWFnZXMucHVzaChcbiAgICAgIC4uLnJlc3VsdC5pbWFnZXMubWFwKFxuICAgICAgICAoaW1hZ2UpID0+IHtcbiAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICByZXR1cm4gbmV3IERlZmF1bHRHZW5lcmF0ZWRGaWxlKHtcbiAgICAgICAgICAgIGRhdGE6IGltYWdlLFxuICAgICAgICAgICAgbWltZVR5cGU6IChfYTE4ID0gZGV0ZWN0TWltZVR5cGUoe1xuICAgICAgICAgICAgICBkYXRhOiBpbWFnZSxcbiAgICAgICAgICAgICAgc2lnbmF0dXJlczogaW1hZ2VNaW1lVHlwZVNpZ25hdHVyZXNcbiAgICAgICAgICAgIH0pKSAhPSBudWxsID8gX2ExOCA6IFwiaW1hZ2UvcG5nXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gICAgd2FybmluZ3MucHVzaCguLi5yZXN1bHQud2FybmluZ3MpO1xuICAgIHJlc3BvbnNlcy5wdXNoKHJlc3VsdC5yZXNwb25zZSk7XG4gIH1cbiAgaWYgKCFpbWFnZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IE5vSW1hZ2VHZW5lcmF0ZWRFcnJvcih7IHJlc3BvbnNlcyB9KTtcbiAgfVxuICByZXR1cm4gbmV3IERlZmF1bHRHZW5lcmF0ZUltYWdlUmVzdWx0KHsgaW1hZ2VzLCB3YXJuaW5ncywgcmVzcG9uc2VzIH0pO1xufVxudmFyIERlZmF1bHRHZW5lcmF0ZUltYWdlUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5pbWFnZXMgPSBvcHRpb25zLmltYWdlcztcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnJlc3BvbnNlcyA9IG9wdGlvbnMucmVzcG9uc2VzO1xuICB9XG4gIGdldCBpbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZXNbMF07XG4gIH1cbn07XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L2dlbmVyYXRlLW9iamVjdC50c1xuaW1wb3J0IHtcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IGNyZWF0ZUlkR2VuZXJhdG9yLCBzYWZlUGFyc2VKU09OIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gZXJyb3JzL25vLW9iamVjdC1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU0ID0gXCJBSV9Ob09iamVjdEdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNH1gO1xudmFyIHN5bWJvbDQgPSBTeW1ib2wuZm9yKG1hcmtlcjQpO1xudmFyIF9hNDtcbnZhciBOb09iamVjdEdlbmVyYXRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlID0gXCJObyBvYmplY3QgZ2VuZXJhdGVkLlwiLFxuICAgIGNhdXNlLFxuICAgIHRleHQ6IHRleHQyLFxuICAgIHJlc3BvbnNlLFxuICAgIHVzYWdlLFxuICAgIGZpbmlzaFJlYXNvblxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNCwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTRdID0gdHJ1ZTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0MjtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgdGhpcy51c2FnZSA9IHVzYWdlO1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gZmluaXNoUmVhc29uO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I0Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNCk7XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyB1dGlsL2Rvd25sb2FkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I1IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNSA9IFwiQUlfRG93bmxvYWRFcnJvclwiO1xudmFyIG1hcmtlcjUgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTV9YDtcbnZhciBzeW1ib2w1ID0gU3ltYm9sLmZvcihtYXJrZXI1KTtcbnZhciBfYTU7XG52YXIgRG93bmxvYWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdXJsLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBjYXVzZSxcbiAgICBtZXNzYWdlID0gY2F1c2UgPT0gbnVsbCA/IGBGYWlsZWQgdG8gZG93bmxvYWQgJHt1cmx9OiAke3N0YXR1c0NvZGV9ICR7c3RhdHVzVGV4dH1gIDogYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH06ICR7Y2F1c2V9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNSwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTVdID0gdHJ1ZTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjUuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI1KTtcbiAgfVxufTtcbl9hNSA9IHN5bWJvbDU7XG5cbi8vIHV0aWwvZG93bmxvYWQudHNcbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkKHsgdXJsIH0pIHtcbiAgdmFyIF9hMTc7XG4gIGNvbnN0IHVybFRleHQgPSB1cmwudG9TdHJpbmcoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybFRleHQpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBEb3dubG9hZEVycm9yKHtcbiAgICAgICAgdXJsOiB1cmxUZXh0LFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogbmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSksXG4gICAgICBtaW1lVHlwZTogKF9hMTcgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSkgIT0gbnVsbCA/IF9hMTcgOiB2b2lkIDBcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChEb3dubG9hZEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3IoeyB1cmw6IHVybFRleHQsIGNhdXNlOiBlcnJvciB9KTtcbiAgfVxufVxuXG4vLyBjb3JlL3Byb21wdC9kYXRhLWNvbnRlbnQudHNcbmltcG9ydCB7XG4gIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkgYXMgY29udmVydEJhc2U2NFRvVWludDhBcnJheTMsXG4gIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQgYXMgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NDJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gY29yZS9wcm9tcHQvaW52YWxpZC1kYXRhLWNvbnRlbnQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjYgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU2ID0gXCJBSV9JbnZhbGlkRGF0YUNvbnRlbnRFcnJvclwiO1xudmFyIG1hcmtlcjYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTZ9YDtcbnZhciBzeW1ib2w2ID0gU3ltYm9sLmZvcihtYXJrZXI2KTtcbnZhciBfYTY7XG52YXIgSW52YWxpZERhdGFDb250ZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I2IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRlbnQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGEgY29udGVudC4gRXhwZWN0ZWQgYSBiYXNlNjQgc3RyaW5nLCBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciwgb3IgQnVmZmVyLCBidXQgZ290ICR7dHlwZW9mIGNvbnRlbnR9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTYsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E2XSA9IHRydWU7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNi5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjYpO1xuICB9XG59O1xuX2E2ID0gc3ltYm9sNjtcblxuLy8gY29yZS9wcm9tcHQvZGF0YS1jb250ZW50LnRzXG5pbXBvcnQgeyB6IH0gZnJvbSBcInpvZFwiO1xudmFyIGRhdGFDb250ZW50U2NoZW1hID0gei51bmlvbihbXG4gIHouc3RyaW5nKCksXG4gIHouaW5zdGFuY2VvZihVaW50OEFycmF5KSxcbiAgei5pbnN0YW5jZW9mKEFycmF5QnVmZmVyKSxcbiAgei5jdXN0b20oXG4gICAgLy8gQnVmZmVyIG1pZ2h0IG5vdCBiZSBhdmFpbGFibGUgaW4gc29tZSBlbnZpcm9ubWVudHMgc3VjaCBhcyBDbG91ZEZsYXJlOlxuICAgICh2YWx1ZSkgPT4ge1xuICAgICAgdmFyIF9hMTcsIF9iO1xuICAgICAgcmV0dXJuIChfYiA9IChfYTE3ID0gZ2xvYmFsVGhpcy5CdWZmZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmlzQnVmZmVyKHZhbHVlKSkgIT0gbnVsbCA/IF9iIDogZmFsc2U7XG4gICAgfSxcbiAgICB7IG1lc3NhZ2U6IFwiTXVzdCBiZSBhIEJ1ZmZlclwiIH1cbiAgKVxuXSk7XG5mdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhjb250ZW50KSB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NDIobmV3IFVpbnQ4QXJyYXkoY29udGVudCkpO1xuICB9XG4gIHJldHVybiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0Mihjb250ZW50KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShjb250ZW50KSB7XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29udmVydEJhc2U2NFRvVWludDhBcnJheTMoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBkYXRhIGNvbnRlbnQuIENvbnRlbnQgc3RyaW5nIGlzIG5vdCBhIGJhc2U2NC1lbmNvZGVkIG1lZGlhLlwiLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNvbnRlbnQpO1xuICB9XG4gIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7IGNvbnRlbnQgfSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VWludDhBcnJheVRvVGV4dCh1aW50OEFycmF5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh1aW50OEFycmF5KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBkZWNvZGluZyBVaW50OEFycmF5IHRvIHRleHRcIik7XG4gIH1cbn1cblxuLy8gY29yZS9wcm9tcHQvaW52YWxpZC1tZXNzYWdlLXJvbGUtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjcgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU3ID0gXCJBSV9JbnZhbGlkTWVzc2FnZVJvbGVFcnJvclwiO1xudmFyIG1hcmtlcjcgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTd9YDtcbnZhciBzeW1ib2w3ID0gU3ltYm9sLmZvcihtYXJrZXI3KTtcbnZhciBfYTc7XG52YXIgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I3IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHJvbGUsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIG1lc3NhZ2Ugcm9sZTogJyR7cm9sZX0nLiBNdXN0IGJlIG9uZSBvZjogXCJzeXN0ZW1cIiwgXCJ1c2VyXCIsIFwiYXNzaXN0YW50XCIsIFwidG9vbFwiLmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTcsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTddID0gdHJ1ZTtcbiAgICB0aGlzLnJvbGUgPSByb2xlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I3Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNyk7XG4gIH1cbn07XG5fYTcgPSBzeW1ib2w3O1xuXG4vLyBjb3JlL3Byb21wdC9zcGxpdC1kYXRhLXVybC50c1xuZnVuY3Rpb24gc3BsaXREYXRhVXJsKGRhdGFVcmwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBbaGVhZGVyLCBiYXNlNjRDb250ZW50XSA9IGRhdGFVcmwuc3BsaXQoXCIsXCIpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW1lVHlwZTogaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV0sXG4gICAgICBiYXNlNjRDb250ZW50XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWltZVR5cGU6IHZvaWQgMCxcbiAgICAgIGJhc2U2NENvbnRlbnQ6IHZvaWQgMFxuICAgIH07XG4gIH1cbn1cblxuLy8gY29yZS9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQudHNcbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICBwcm9tcHQsXG4gIG1vZGVsU3VwcG9ydHNJbWFnZVVybHMgPSB0cnVlLFxuICBtb2RlbFN1cHBvcnRzVXJsID0gKCkgPT4gZmFsc2UsXG4gIGRvd25sb2FkSW1wbGVtZW50YXRpb24gPSBkb3dubG9hZFxufSkge1xuICBjb25zdCBkb3dubG9hZGVkQXNzZXRzID0gYXdhaXQgZG93bmxvYWRBc3NldHMoXG4gICAgcHJvbXB0Lm1lc3NhZ2VzLFxuICAgIGRvd25sb2FkSW1wbGVtZW50YXRpb24sXG4gICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJscyxcbiAgICBtb2RlbFN1cHBvcnRzVXJsXG4gICk7XG4gIHJldHVybiBbXG4gICAgLi4ucHJvbXB0LnN5c3RlbSAhPSBudWxsID8gW3sgcm9sZTogXCJzeXN0ZW1cIiwgY29udGVudDogcHJvbXB0LnN5c3RlbSB9XSA6IFtdLFxuICAgIC4uLnByb21wdC5tZXNzYWdlcy5tYXAoXG4gICAgICAobWVzc2FnZSkgPT4gY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UobWVzc2FnZSwgZG93bmxvYWRlZEFzc2V0cylcbiAgICApXG4gIF07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZShtZXNzYWdlLCBkb3dubG9hZGVkQXNzZXRzKSB7XG4gIHZhciBfYTE3LCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gIGNvbnN0IHJvbGUgPSBtZXNzYWdlLnJvbGU7XG4gIHN3aXRjaCAocm9sZSkge1xuICAgIGNhc2UgXCJzeXN0ZW1cIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiAoX2ExNyA9IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zKSAhPSBudWxsID8gX2ExNyA6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJ1c2VyXCI6IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiAoX2IgPSBtZXNzYWdlLnByb3ZpZGVyT3B0aW9ucykgIT0gbnVsbCA/IF9iIDogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoKHBhcnQpID0+IGNvbnZlcnRQYXJ0VG9MYW5ndWFnZU1vZGVsUGFydChwYXJ0LCBkb3dubG9hZGVkQXNzZXRzKSkuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwidGV4dFwiIHx8IHBhcnQudGV4dCAhPT0gXCJcIiksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IChfYyA9IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zKSAhPSBudWxsID8gX2MgOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dLFxuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IChfZCA9IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zKSAhPSBudWxsID8gX2QgOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQuZmlsdGVyKFxuICAgICAgICAgIC8vIHJlbW92ZSBlbXB0eSB0ZXh0IHBhcnRzOlxuICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwidGV4dFwiIHx8IHBhcnQudGV4dCAhPT0gXCJcIlxuICAgICAgICApLm1hcCgocGFydCkgPT4ge1xuICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgIGNvbnN0IHByb3ZpZGVyT3B0aW9ucyA9IChfYTE4ID0gcGFydC5wcm92aWRlck9wdGlvbnMpICE9IG51bGwgPyBfYTE4IDogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IHBhcnQuZGF0YSBpbnN0YW5jZW9mIFVSTCA/IHBhcnQuZGF0YSA6IGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nKHBhcnQuZGF0YSksXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHBhcnQuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcnQubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHBhcnQuc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlZGFjdGVkLXJlYXNvbmluZ1wiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWRhY3RlZC1yZWFzb25pbmdcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBwYXJ0LmRhdGEsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgYXJnczogcGFydC5hcmdzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IChfZSA9IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zKSAhPSBudWxsID8gX2UgOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50Lm1hcCgocGFydCkgPT4ge1xuICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgIHJlc3VsdDogcGFydC5yZXN1bHQsXG4gICAgICAgICAgICBjb250ZW50OiBwYXJ0LmV4cGVyaW1lbnRhbF9jb250ZW50LFxuICAgICAgICAgICAgaXNFcnJvcjogcGFydC5pc0Vycm9yLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogKF9hMTggPSBwYXJ0LnByb3ZpZGVyT3B0aW9ucykgIT0gbnVsbCA/IF9hMTggOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IChfZiA9IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zKSAhPSBudWxsID8gX2YgOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcm9sZTtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcih7IHJvbGU6IF9leGhhdXN0aXZlQ2hlY2sgfSk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEFzc2V0cyhtZXNzYWdlcywgZG93bmxvYWRJbXBsZW1lbnRhdGlvbiwgbW9kZWxTdXBwb3J0c0ltYWdlVXJscywgbW9kZWxTdXBwb3J0c1VybCkge1xuICBjb25zdCB1cmxzID0gbWVzc2FnZXMuZmlsdGVyKChtZXNzYWdlKSA9PiBtZXNzYWdlLnJvbGUgPT09IFwidXNlclwiKS5tYXAoKG1lc3NhZ2UpID0+IG1lc3NhZ2UuY29udGVudCkuZmlsdGVyKFxuICAgIChjb250ZW50KSA9PiBBcnJheS5pc0FycmF5KGNvbnRlbnQpXG4gICkuZmxhdCgpLmZpbHRlcihcbiAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcImltYWdlXCIgfHwgcGFydC50eXBlID09PSBcImZpbGVcIlxuICApLmZpbHRlcihcbiAgICAocGFydCkgPT4gIShwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiAmJiBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzID09PSB0cnVlKVxuICApLm1hcCgocGFydCkgPT4gcGFydC50eXBlID09PSBcImltYWdlXCIgPyBwYXJ0LmltYWdlIDogcGFydC5kYXRhKS5tYXAoXG4gICAgKHBhcnQpID0+IChcbiAgICAgIC8vIHN1cHBvcnQgc3RyaW5nIHVybHM6XG4gICAgICB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIiAmJiAocGFydC5zdGFydHNXaXRoKFwiaHR0cDpcIikgfHwgcGFydC5zdGFydHNXaXRoKFwiaHR0cHM6XCIpKSA/IG5ldyBVUkwocGFydCkgOiBwYXJ0XG4gICAgKVxuICApLmZpbHRlcigoaW1hZ2UpID0+IGltYWdlIGluc3RhbmNlb2YgVVJMKS5maWx0ZXIoKHVybCkgPT4gIW1vZGVsU3VwcG9ydHNVcmwodXJsKSk7XG4gIGNvbnN0IGRvd25sb2FkZWRJbWFnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICB1cmxzLm1hcChhc3luYyAodXJsKSA9PiAoe1xuICAgICAgdXJsLFxuICAgICAgZGF0YTogYXdhaXQgZG93bmxvYWRJbXBsZW1lbnRhdGlvbih7IHVybCB9KVxuICAgIH0pKVxuICApO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIGRvd25sb2FkZWRJbWFnZXMubWFwKCh7IHVybCwgZGF0YSB9KSA9PiBbdXJsLnRvU3RyaW5nKCksIGRhdGFdKVxuICApO1xufVxuZnVuY3Rpb24gY29udmVydFBhcnRUb0xhbmd1YWdlTW9kZWxQYXJ0KHBhcnQsIGRvd25sb2FkZWRBc3NldHMpIHtcbiAgdmFyIF9hMTcsIF9iLCBfYywgX2Q7XG4gIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgcHJvdmlkZXJNZXRhZGF0YTogKF9hMTcgPSBwYXJ0LnByb3ZpZGVyT3B0aW9ucykgIT0gbnVsbCA/IF9hMTcgOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgfTtcbiAgfVxuICBsZXQgbWltZVR5cGUgPSBwYXJ0Lm1pbWVUeXBlO1xuICBsZXQgZGF0YTtcbiAgbGV0IGNvbnRlbnQ7XG4gIGxldCBub3JtYWxpemVkRGF0YTtcbiAgY29uc3QgdHlwZSA9IHBhcnQudHlwZTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImltYWdlXCI6XG4gICAgICBkYXRhID0gcGFydC5pbWFnZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICBkYXRhID0gcGFydC5kYXRhO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFydCB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb250ZW50ID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBuZXcgVVJMKGRhdGEpIDogZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb250ZW50ID0gZGF0YTtcbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVSTCkge1xuICAgIGlmIChjb250ZW50LnByb3RvY29sID09PSBcImRhdGE6XCIpIHtcbiAgICAgIGNvbnN0IHsgbWltZVR5cGU6IGRhdGFVcmxNaW1lVHlwZSwgYmFzZTY0Q29udGVudCB9ID0gc3BsaXREYXRhVXJsKFxuICAgICAgICBjb250ZW50LnRvU3RyaW5nKClcbiAgICAgICk7XG4gICAgICBpZiAoZGF0YVVybE1pbWVUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhIFVSTCBmb3JtYXQgaW4gcGFydCAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgICBtaW1lVHlwZSA9IGRhdGFVcmxNaW1lVHlwZTtcbiAgICAgIG5vcm1hbGl6ZWREYXRhID0gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGJhc2U2NENvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkb3dubG9hZGVkRmlsZSA9IGRvd25sb2FkZWRBc3NldHNbY29udGVudC50b1N0cmluZygpXTtcbiAgICAgIGlmIChkb3dubG9hZGVkRmlsZSkge1xuICAgICAgICBub3JtYWxpemVkRGF0YSA9IGRvd25sb2FkZWRGaWxlLmRhdGE7XG4gICAgICAgIG1pbWVUeXBlICE9IG51bGwgPyBtaW1lVHlwZSA6IG1pbWVUeXBlID0gZG93bmxvYWRlZEZpbGUubWltZVR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkRGF0YSA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vcm1hbGl6ZWREYXRhID0gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGNvbnRlbnQpO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJpbWFnZVwiOiB7XG4gICAgICBpZiAobm9ybWFsaXplZERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIG1pbWVUeXBlID0gKF9iID0gZGV0ZWN0TWltZVR5cGUoe1xuICAgICAgICAgIGRhdGE6IG5vcm1hbGl6ZWREYXRhLFxuICAgICAgICAgIHNpZ25hdHVyZXM6IGltYWdlTWltZVR5cGVTaWduYXR1cmVzXG4gICAgICAgIH0pKSAhPSBudWxsID8gX2IgOiBtaW1lVHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgaW1hZ2U6IG5vcm1hbGl6ZWREYXRhLFxuICAgICAgICBtaW1lVHlwZSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogKF9jID0gcGFydC5wcm92aWRlck9wdGlvbnMpICE9IG51bGwgPyBfYyA6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgIGlmIChtaW1lVHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWltZSB0eXBlIGlzIG1pc3NpbmcgZm9yIGZpbGUgcGFydGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIGRhdGE6IG5vcm1hbGl6ZWREYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nKG5vcm1hbGl6ZWREYXRhKSA6IG5vcm1hbGl6ZWREYXRhLFxuICAgICAgICBmaWxlbmFtZTogcGFydC5maWxlbmFtZSxcbiAgICAgICAgbWltZVR5cGUsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IChfZCA9IHBhcnQucHJvdmlkZXJPcHRpb25zKSAhPSBudWxsID8gX2QgOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLWNhbGwtc2V0dGluZ3MudHNcbmZ1bmN0aW9uIHByZXBhcmVDYWxsU2V0dGluZ3Moe1xuICBtYXhUb2tlbnMsXG4gIHRlbXBlcmF0dXJlLFxuICB0b3BQLFxuICB0b3BLLFxuICBwcmVzZW5jZVBlbmFsdHksXG4gIGZyZXF1ZW5jeVBlbmFsdHksXG4gIHN0b3BTZXF1ZW5jZXMsXG4gIHNlZWRcbn0pIHtcbiAgaWYgKG1heFRva2VucyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFRva2VucykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhUb2tlbnNcIixcbiAgICAgICAgdmFsdWU6IG1heFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhUb2tlbnMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4VG9rZW5zIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFRva2Vuc1wiLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFRva2VucyBtdXN0IGJlID49IDFcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0ZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wZXJhdHVyZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRlbXBlcmF0dXJlXCIsXG4gICAgICAgIHZhbHVlOiB0ZW1wZXJhdHVyZSxcbiAgICAgICAgbWVzc2FnZTogXCJ0ZW1wZXJhdHVyZSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodG9wUCAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BQICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidG9wUFwiLFxuICAgICAgICB2YWx1ZTogdG9wUCxcbiAgICAgICAgbWVzc2FnZTogXCJ0b3BQIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0b3BLICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRvcEsgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0b3BLXCIsXG4gICAgICAgIHZhbHVlOiB0b3BLLFxuICAgICAgICBtZXNzYWdlOiBcInRvcEsgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBwcmVzZW5jZVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJwcmVzZW5jZVBlbmFsdHlcIixcbiAgICAgICAgdmFsdWU6IHByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogXCJwcmVzZW5jZVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZnJlcXVlbmN5UGVuYWx0eSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImZyZXF1ZW5jeVBlbmFsdHlcIixcbiAgICAgICAgdmFsdWU6IGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwiZnJlcXVlbmN5UGVuYWx0eSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoc2VlZCAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNlZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2VlZFwiLFxuICAgICAgICB2YWx1ZTogc2VlZCxcbiAgICAgICAgbWVzc2FnZTogXCJzZWVkIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtYXhUb2tlbnMsXG4gICAgLy8gVE9ETyB2NSByZW1vdmUgZGVmYXVsdCAwIGZvciB0ZW1wZXJhdHVyZVxuICAgIHRlbXBlcmF0dXJlOiB0ZW1wZXJhdHVyZSAhPSBudWxsID8gdGVtcGVyYXR1cmUgOiAwLFxuICAgIHRvcFAsXG4gICAgdG9wSyxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBzdG9wU2VxdWVuY2VzOiBzdG9wU2VxdWVuY2VzICE9IG51bGwgJiYgc3RvcFNlcXVlbmNlcy5sZW5ndGggPiAwID8gc3RvcFNlcXVlbmNlcyA6IHZvaWQgMCxcbiAgICBzZWVkXG4gIH07XG59XG5cbi8vIGNvcmUvcHJvbXB0L3N0YW5kYXJkaXplLXByb21wdC50c1xuaW1wb3J0IHsgSW52YWxpZFByb21wdEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNhZmVWYWxpZGF0ZVR5cGVzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejcgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvcHJvbXB0L2F0dGFjaG1lbnRzLXRvLXBhcnRzLnRzXG5mdW5jdGlvbiBhdHRhY2htZW50c1RvUGFydHMoYXR0YWNobWVudHMpIHtcbiAgdmFyIF9hMTcsIF9iLCBfYztcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgZm9yIChjb25zdCBhdHRhY2htZW50IG9mIGF0dGFjaG1lbnRzKSB7XG4gICAgbGV0IHVybDtcbiAgICB0cnkge1xuICAgICAgdXJsID0gbmV3IFVSTChhdHRhY2htZW50LnVybCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVUkw6ICR7YXR0YWNobWVudC51cmx9YCk7XG4gICAgfVxuICAgIHN3aXRjaCAodXJsLnByb3RvY29sKSB7XG4gICAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICAgIGNhc2UgXCJodHRwczpcIjoge1xuICAgICAgICBpZiAoKF9hMTcgPSBhdHRhY2htZW50LmNvbnRlbnRUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5zdGFydHNXaXRoKFwiaW1hZ2UvXCIpKSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6IFwiaW1hZ2VcIiwgaW1hZ2U6IHVybCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWF0dGFjaG1lbnQuY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJZiB0aGUgYXR0YWNobWVudCBpcyBub3QgYW4gaW1hZ2UsIGl0IG11c3Qgc3BlY2lmeSBhIGNvbnRlbnQgdHlwZVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgZGF0YTogdXJsLFxuICAgICAgICAgICAgbWltZVR5cGU6IGF0dGFjaG1lbnQuY29udGVudFR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkYXRhOlwiOiB7XG4gICAgICAgIGxldCBoZWFkZXI7XG4gICAgICAgIGxldCBiYXNlNjRDb250ZW50O1xuICAgICAgICBsZXQgbWltZVR5cGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBhdHRhY2htZW50LnVybC5zcGxpdChcIixcIik7XG4gICAgICAgICAgbWltZVR5cGUgPSBoZWFkZXIuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiOlwiKVsxXTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgZGF0YSBVUkw6ICR7YXR0YWNobWVudC51cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbWVUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdDogJHthdHRhY2htZW50LnVybH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9iID0gYXR0YWNobWVudC5jb250ZW50VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgIGltYWdlOiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoX2MgPSBhdHRhY2htZW50LmNvbnRlbnRUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc3RhcnRzV2l0aChcInRleHQvXCIpKSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHRleHQ6IGNvbnZlcnRVaW50OEFycmF5VG9UZXh0KFxuICAgICAgICAgICAgICBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudClcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWF0dGFjaG1lbnQuY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJZiB0aGUgYXR0YWNobWVudCBpcyBub3QgYW4gaW1hZ2Ugb3IgdGV4dCwgaXQgbXVzdCBzcGVjaWZ5IGEgY29udGVudCB0eXBlXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICBkYXRhOiBiYXNlNjRDb250ZW50LFxuICAgICAgICAgICAgbWltZVR5cGU6IGF0dGFjaG1lbnQuY29udGVudFR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBVUkwgcHJvdG9jb2w6ICR7dXJsLnByb3RvY29sfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIGNvcmUvcHJvbXB0L21lc3NhZ2UtY29udmVyc2lvbi1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yOCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTggPSBcIkFJX01lc3NhZ2VDb252ZXJzaW9uRXJyb3JcIjtcbnZhciBtYXJrZXI4ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU4fWA7XG52YXIgc3ltYm9sOCA9IFN5bWJvbC5mb3IobWFya2VyOCk7XG52YXIgX2E4O1xudmFyIE1lc3NhZ2VDb252ZXJzaW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I4IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG9yaWdpbmFsTWVzc2FnZSxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU4LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E4XSA9IHRydWU7XG4gICAgdGhpcy5vcmlnaW5hbE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2U7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjguaGFzTWFya2VyKGVycm9yLCBtYXJrZXI4KTtcbiAgfVxufTtcbl9hOCA9IHN5bWJvbDg7XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnZlcnQtdG8tY29yZS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gY29udmVydFRvQ29yZU1lc3NhZ2VzKG1lc3NhZ2VzLCBvcHRpb25zKSB7XG4gIHZhciBfYTE3LCBfYjtcbiAgY29uc3QgdG9vbHMgPSAoX2ExNyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudG9vbHMpICE9IG51bGwgPyBfYTE3IDoge307XG4gIGNvbnN0IGNvcmVNZXNzYWdlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VzW2ldO1xuICAgIGNvbnN0IGlzTGFzdE1lc3NhZ2UgPSBpID09PSBtZXNzYWdlcy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IHsgcm9sZSwgY29udGVudCwgZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzIH0gPSBtZXNzYWdlO1xuICAgIHN3aXRjaCAocm9sZSkge1xuICAgICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBpZiAobWVzc2FnZS5wYXJ0cyA9PSBudWxsKSB7XG4gICAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICBjb250ZW50OiBleHBlcmltZW50YWxfYXR0YWNobWVudHMgPyBbXG4gICAgICAgICAgICAgIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGNvbnRlbnQgfSxcbiAgICAgICAgICAgICAgLi4uYXR0YWNobWVudHNUb1BhcnRzKGV4cGVyaW1lbnRhbF9hdHRhY2htZW50cylcbiAgICAgICAgICAgIF0gOiBjb250ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdGV4dFBhcnRzID0gbWVzc2FnZS5wYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIpLm1hcCgocGFydCkgPT4gKHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgY29udGVudDogZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzID8gWy4uLnRleHRQYXJ0cywgLi4uYXR0YWNobWVudHNUb1BhcnRzKGV4cGVyaW1lbnRhbF9hdHRhY2htZW50cyldIDogdGV4dFBhcnRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucGFydHMgIT0gbnVsbCkge1xuICAgICAgICAgIGxldCBwcm9jZXNzQmxvY2syID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50MiA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGJsb2NrKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZpbGVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgICBjb250ZW50Mi5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjoge1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXRhaWwgb2YgcGFydC5kZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZGV0YWlsLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGRldGFpbC50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IGRldGFpbC5zaWduYXR1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlZGFjdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50Mi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWRhY3RlZC1yZWFzb25pbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGV0YWlsLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1pbnZvY2F0aW9uXCI6XG4gICAgICAgICAgICAgICAgICBjb250ZW50Mi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sSW52b2NhdGlvbi50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sSW52b2NhdGlvbi50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogcGFydC50b29sSW52b2NhdGlvbi5hcmdzXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBwYXJ0O1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJ0OiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBJbnZvY2F0aW9ucyA9IGJsb2NrLmZpbHRlcihcbiAgICAgICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0b29sLWludm9jYXRpb25cIlxuICAgICAgICAgICAgKS5tYXAoKHBhcnQpID0+IHBhcnQudG9vbEludm9jYXRpb24pO1xuICAgICAgICAgICAgaWYgKHN0ZXBJbnZvY2F0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiBzdGVwSW52b2NhdGlvbnMubWFwKFxuICAgICAgICAgICAgICAgICAgKHRvb2xJbnZvY2F0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKFwicmVzdWx0XCIgaW4gdG9vbEludm9jYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1lc3NhZ2VDb252ZXJzaW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxNZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJUb29sSW52b2NhdGlvbiBtdXN0IGhhdmUgYSByZXN1bHQ6IFwiICsgSlNPTi5zdHJpbmdpZnkodG9vbEludm9jYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0b29sQ2FsbElkLCB0b29sTmFtZSwgcmVzdWx0IH0gPSB0b29sSW52b2NhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodG9vbDIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wyLmV4cGVyaW1lbnRhbF90b1Rvb2xSZXN1bHRDb250ZW50KSAhPSBudWxsID8ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQocmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGVudDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jayA9IFtdO1xuICAgICAgICAgICAgYmxvY2tIYXNUb29sSW52b2NhdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgIGN1cnJlbnRTdGVwKys7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgcHJvY2Vzc0Jsb2NrID0gcHJvY2Vzc0Jsb2NrMjtcbiAgICAgICAgICBsZXQgY3VycmVudFN0ZXAgPSAwO1xuICAgICAgICAgIGxldCBibG9ja0hhc1Rvb2xJbnZvY2F0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgIGxldCBibG9jayA9IFtdO1xuICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBtZXNzYWdlLnBhcnRzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrSGFzVG9vbEludm9jYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICBwcm9jZXNzQmxvY2syKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJsb2NrLnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImZpbGVcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZ1wiOiB7XG4gICAgICAgICAgICAgICAgYmxvY2sucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwidG9vbC1pbnZvY2F0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICBpZiAoKChfYiA9IHBhcnQudG9vbEludm9jYXRpb24uc3RlcCkgIT0gbnVsbCA/IF9iIDogMCkgIT09IGN1cnJlbnRTdGVwKSB7XG4gICAgICAgICAgICAgICAgICBwcm9jZXNzQmxvY2syKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJsb2NrLnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgYmxvY2tIYXNUb29sSW52b2NhdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3NCbG9jazIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b29sSW52b2NhdGlvbnMgPSBtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucztcbiAgICAgICAgaWYgKHRvb2xJbnZvY2F0aW9ucyA9PSBudWxsIHx8IHRvb2xJbnZvY2F0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7IHJvbGU6IFwiYXNzaXN0YW50XCIsIGNvbnRlbnQgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF4U3RlcCA9IHRvb2xJbnZvY2F0aW9ucy5yZWR1Y2UoKG1heCwgdG9vbEludm9jYXRpb24pID0+IHtcbiAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgobWF4LCAoX2ExOCA9IHRvb2xJbnZvY2F0aW9uLnN0ZXApICE9IG51bGwgPyBfYTE4IDogMCk7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDw9IG1heFN0ZXA7IGkyKyspIHtcbiAgICAgICAgICBjb25zdCBzdGVwSW52b2NhdGlvbnMgPSB0b29sSW52b2NhdGlvbnMuZmlsdGVyKFxuICAgICAgICAgICAgKHRvb2xJbnZvY2F0aW9uKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgICAgICByZXR1cm4gKChfYTE4ID0gdG9vbEludm9jYXRpb24uc3RlcCkgIT0gbnVsbCA/IF9hMTggOiAwKSA9PT0gaTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoc3RlcEludm9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgIC4uLmlzTGFzdE1lc3NhZ2UgJiYgY29udGVudCAmJiBpMiA9PT0gMCA/IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBjb250ZW50IH1dIDogW10sXG4gICAgICAgICAgICAgIC4uLnN0ZXBJbnZvY2F0aW9ucy5tYXAoXG4gICAgICAgICAgICAgICAgKHsgdG9vbENhbGxJZCwgdG9vbE5hbWUsIGFyZ3MgfSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBhcmdzXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgY29udGVudDogc3RlcEludm9jYXRpb25zLm1hcCgodG9vbEludm9jYXRpb24pID0+IHtcbiAgICAgICAgICAgICAgaWYgKCEoXCJyZXN1bHRcIiBpbiB0b29sSW52b2NhdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWVzc2FnZUNvbnZlcnNpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICBvcmlnaW5hbE1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlRvb2xJbnZvY2F0aW9uIG11c3QgaGF2ZSBhIHJlc3VsdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0b29sSW52b2NhdGlvbilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCB7IHRvb2xDYWxsSWQsIHRvb2xOYW1lLCByZXN1bHQgfSA9IHRvb2xJbnZvY2F0aW9uO1xuICAgICAgICAgICAgICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICAgICAgcmV0dXJuICh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQpICE9IG51bGwgPyB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiB0b29sMi5leHBlcmltZW50YWxfdG9Ub29sUmVzdWx0Q29udGVudChyZXN1bHQpLFxuICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZW50OiB0b29sMi5leHBlcmltZW50YWxfdG9Ub29sUmVzdWx0Q29udGVudChyZXN1bHQpXG4gICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50ICYmICFpc0xhc3RNZXNzYWdlKSB7XG4gICAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goeyByb2xlOiBcImFzc2lzdGFudFwiLCBjb250ZW50IH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRhdGFcIjoge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHJvbGU7XG4gICAgICAgIHRocm93IG5ldyBNZXNzYWdlQ29udmVyc2lvbkVycm9yKHtcbiAgICAgICAgICBvcmlnaW5hbE1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgbWVzc2FnZTogYFVuc3VwcG9ydGVkIHJvbGU6ICR7X2V4aGF1c3RpdmVDaGVja31gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29yZU1lc3NhZ2VzO1xufVxuXG4vLyBjb3JlL3Byb21wdC9tZXNzYWdlLnRzXG5pbXBvcnQgeyB6IGFzIHo2IH0gZnJvbSBcInpvZFwiO1xuXG4vLyBjb3JlL3R5cGVzL3Byb3ZpZGVyLW1ldGFkYXRhLnRzXG5pbXBvcnQgeyB6IGFzIHozIH0gZnJvbSBcInpvZFwiO1xuXG4vLyBjb3JlL3R5cGVzL2pzb24tdmFsdWUudHNcbmltcG9ydCB7IHogYXMgejIgfSBmcm9tIFwiem9kXCI7XG52YXIganNvblZhbHVlU2NoZW1hID0gejIubGF6eShcbiAgKCkgPT4gejIudW5pb24oW1xuICAgIHoyLm51bGwoKSxcbiAgICB6Mi5zdHJpbmcoKSxcbiAgICB6Mi5udW1iZXIoKSxcbiAgICB6Mi5ib29sZWFuKCksXG4gICAgejIucmVjb3JkKHoyLnN0cmluZygpLCBqc29uVmFsdWVTY2hlbWEpLFxuICAgIHoyLmFycmF5KGpzb25WYWx1ZVNjaGVtYSlcbiAgXSlcbik7XG5cbi8vIGNvcmUvdHlwZXMvcHJvdmlkZXItbWV0YWRhdGEudHNcbnZhciBwcm92aWRlck1ldGFkYXRhU2NoZW1hID0gejMucmVjb3JkKFxuICB6My5zdHJpbmcoKSxcbiAgejMucmVjb3JkKHozLnN0cmluZygpLCBqc29uVmFsdWVTY2hlbWEpXG4pO1xuXG4vLyBjb3JlL3Byb21wdC9jb250ZW50LXBhcnQudHNcbmltcG9ydCB7IHogYXMgejUgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvcHJvbXB0L3Rvb2wtcmVzdWx0LWNvbnRlbnQudHNcbmltcG9ydCB7IHogYXMgejQgfSBmcm9tIFwiem9kXCI7XG52YXIgdG9vbFJlc3VsdENvbnRlbnRTY2hlbWEgPSB6NC5hcnJheShcbiAgejQudW5pb24oW1xuICAgIHo0Lm9iamVjdCh7IHR5cGU6IHo0LmxpdGVyYWwoXCJ0ZXh0XCIpLCB0ZXh0OiB6NC5zdHJpbmcoKSB9KSxcbiAgICB6NC5vYmplY3Qoe1xuICAgICAgdHlwZTogejQubGl0ZXJhbChcImltYWdlXCIpLFxuICAgICAgZGF0YTogejQuc3RyaW5nKCksXG4gICAgICBtaW1lVHlwZTogejQuc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgIH0pXG4gIF0pXG4pO1xuXG4vLyBjb3JlL3Byb21wdC9jb250ZW50LXBhcnQudHNcbnZhciB0ZXh0UGFydFNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHR5cGU6IHo1LmxpdGVyYWwoXCJ0ZXh0XCIpLFxuICB0ZXh0OiB6NS5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGltYWdlUGFydFNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHR5cGU6IHo1LmxpdGVyYWwoXCJpbWFnZVwiKSxcbiAgaW1hZ2U6IHo1LnVuaW9uKFtkYXRhQ29udGVudFNjaGVtYSwgejUuaW5zdGFuY2VvZihVUkwpXSksXG4gIG1pbWVUeXBlOiB6NS5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgZmlsZVBhcnRTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICB0eXBlOiB6NS5saXRlcmFsKFwiZmlsZVwiKSxcbiAgZGF0YTogejUudW5pb24oW2RhdGFDb250ZW50U2NoZW1hLCB6NS5pbnN0YW5jZW9mKFVSTCldKSxcbiAgZmlsZW5hbWU6IHo1LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIG1pbWVUeXBlOiB6NS5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIHJlYXNvbmluZ1BhcnRTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICB0eXBlOiB6NS5saXRlcmFsKFwicmVhc29uaW5nXCIpLFxuICB0ZXh0OiB6NS5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIHJlZGFjdGVkUmVhc29uaW5nUGFydFNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHR5cGU6IHo1LmxpdGVyYWwoXCJyZWRhY3RlZC1yZWFzb25pbmdcIiksXG4gIGRhdGE6IHo1LnN0cmluZygpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgdG9vbENhbGxQYXJ0U2NoZW1hID0gejUub2JqZWN0KHtcbiAgdHlwZTogejUubGl0ZXJhbChcInRvb2wtY2FsbFwiKSxcbiAgdG9vbENhbGxJZDogejUuc3RyaW5nKCksXG4gIHRvb2xOYW1lOiB6NS5zdHJpbmcoKSxcbiAgYXJnczogejUudW5rbm93bigpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgdG9vbFJlc3VsdFBhcnRTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICB0eXBlOiB6NS5saXRlcmFsKFwidG9vbC1yZXN1bHRcIiksXG4gIHRvb2xDYWxsSWQ6IHo1LnN0cmluZygpLFxuICB0b29sTmFtZTogejUuc3RyaW5nKCksXG4gIHJlc3VsdDogejUudW5rbm93bigpLFxuICBjb250ZW50OiB0b29sUmVzdWx0Q29udGVudFNjaGVtYS5vcHRpb25hbCgpLFxuICBpc0Vycm9yOiB6NS5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xuXG4vLyBjb3JlL3Byb21wdC9tZXNzYWdlLnRzXG52YXIgY29yZVN5c3RlbU1lc3NhZ2VTY2hlbWEgPSB6Ni5vYmplY3Qoe1xuICByb2xlOiB6Ni5saXRlcmFsKFwic3lzdGVtXCIpLFxuICBjb250ZW50OiB6Ni5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGNvcmVVc2VyTWVzc2FnZVNjaGVtYSA9IHo2Lm9iamVjdCh7XG4gIHJvbGU6IHo2LmxpdGVyYWwoXCJ1c2VyXCIpLFxuICBjb250ZW50OiB6Ni51bmlvbihbXG4gICAgejYuc3RyaW5nKCksXG4gICAgejYuYXJyYXkoejYudW5pb24oW3RleHRQYXJ0U2NoZW1hLCBpbWFnZVBhcnRTY2hlbWEsIGZpbGVQYXJ0U2NoZW1hXSkpXG4gIF0pLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZUFzc2lzdGFudE1lc3NhZ2VTY2hlbWEgPSB6Ni5vYmplY3Qoe1xuICByb2xlOiB6Ni5saXRlcmFsKFwiYXNzaXN0YW50XCIpLFxuICBjb250ZW50OiB6Ni51bmlvbihbXG4gICAgejYuc3RyaW5nKCksXG4gICAgejYuYXJyYXkoXG4gICAgICB6Ni51bmlvbihbXG4gICAgICAgIHRleHRQYXJ0U2NoZW1hLFxuICAgICAgICBmaWxlUGFydFNjaGVtYSxcbiAgICAgICAgcmVhc29uaW5nUGFydFNjaGVtYSxcbiAgICAgICAgcmVkYWN0ZWRSZWFzb25pbmdQYXJ0U2NoZW1hLFxuICAgICAgICB0b29sQ2FsbFBhcnRTY2hlbWFcbiAgICAgIF0pXG4gICAgKVxuICBdKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGNvcmVUb29sTWVzc2FnZVNjaGVtYSA9IHo2Lm9iamVjdCh7XG4gIHJvbGU6IHo2LmxpdGVyYWwoXCJ0b29sXCIpLFxuICBjb250ZW50OiB6Ni5hcnJheSh0b29sUmVzdWx0UGFydFNjaGVtYSksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBjb3JlTWVzc2FnZVNjaGVtYSA9IHo2LnVuaW9uKFtcbiAgY29yZVN5c3RlbU1lc3NhZ2VTY2hlbWEsXG4gIGNvcmVVc2VyTWVzc2FnZVNjaGVtYSxcbiAgY29yZUFzc2lzdGFudE1lc3NhZ2VTY2hlbWEsXG4gIGNvcmVUb29sTWVzc2FnZVNjaGVtYVxuXSk7XG5cbi8vIGNvcmUvcHJvbXB0L3N0YW5kYXJkaXplLXByb21wdC50c1xuZnVuY3Rpb24gc3RhbmRhcmRpemVQcm9tcHQoe1xuICBwcm9tcHQsXG4gIHRvb2xzXG59KSB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG9yIG1lc3NhZ2VzIG11c3QgYmUgZGVmaW5lZFwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJwcm9tcHQgYW5kIG1lc3NhZ2VzIGNhbm5vdCBiZSBkZWZpbmVkIGF0IHRoZSBzYW1lIHRpbWVcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQuc3lzdGVtICE9IG51bGwgJiYgdHlwZW9mIHByb21wdC5zeXN0ZW0gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwic3lzdGVtIG11c3QgYmUgYSBzdHJpbmdcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHByb21wdC5wcm9tcHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG11c3QgYmUgYSBzdHJpbmdcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInByb21wdFwiLFxuICAgICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtLFxuICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IHByb21wdC5wcm9tcHRcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gIH1cbiAgaWYgKHByb21wdC5tZXNzYWdlcyAhPSBudWxsKSB7XG4gICAgY29uc3QgcHJvbXB0VHlwZSA9IGRldGVjdFByb21wdFR5cGUocHJvbXB0Lm1lc3NhZ2VzKTtcbiAgICBjb25zdCBtZXNzYWdlcyA9IHByb21wdFR5cGUgPT09IFwidWktbWVzc2FnZXNcIiA/IGNvbnZlcnRUb0NvcmVNZXNzYWdlcyhwcm9tcHQubWVzc2FnZXMsIHtcbiAgICAgIHRvb2xzXG4gICAgfSkgOiBwcm9tcHQubWVzc2FnZXM7XG4gICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgbWVzc2FnZTogXCJtZXNzYWdlcyBtdXN0IG5vdCBiZSBlbXB0eVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgICAgIHZhbHVlOiBtZXNzYWdlcyxcbiAgICAgIHNjaGVtYTogejcuYXJyYXkoY29yZU1lc3NhZ2VTY2hlbWEpXG4gICAgfSk7XG4gICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2U6IFtcbiAgICAgICAgICBcIm1lc3NhZ2UgbXVzdCBiZSBhIENvcmVNZXNzYWdlIG9yIGEgVUkgbWVzc2FnZVwiLFxuICAgICAgICAgIGBWYWxpZGF0aW9uIGVycm9yOiAke3ZhbGlkYXRpb25SZXN1bHQuZXJyb3IubWVzc2FnZX1gXG4gICAgICAgIF0uam9pbihcIlxcblwiKSxcbiAgICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtZXNzYWdlc1wiLFxuICAgICAgbWVzc2FnZXMsXG4gICAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW1cbiAgICB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcInVucmVhY2hhYmxlXCIpO1xufVxuZnVuY3Rpb24gZGV0ZWN0UHJvbXB0VHlwZShwcm9tcHQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHByb21wdCkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFtcbiAgICAgICAgXCJtZXNzYWdlcyBtdXN0IGJlIGFuIGFycmF5IG9mIENvcmVNZXNzYWdlIG9yIFVJTWVzc2FnZVwiLFxuICAgICAgICBgUmVjZWl2ZWQgbm9uLWFycmF5IHZhbHVlOiAke0pTT04uc3RyaW5naWZ5KHByb21wdCl9YFxuICAgICAgXS5qb2luKFwiXFxuXCIpLFxuICAgICAgY2F1c2U6IHByb21wdFxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFwibWVzc2FnZXNcIjtcbiAgfVxuICBjb25zdCBjaGFyYWN0ZXJpc3RpY3MgPSBwcm9tcHQubWFwKGRldGVjdFNpbmdsZU1lc3NhZ2VDaGFyYWN0ZXJpc3RpY3MpO1xuICBpZiAoY2hhcmFjdGVyaXN0aWNzLnNvbWUoKGMpID0+IGMgPT09IFwiaGFzLXVpLXNwZWNpZmljLXBhcnRzXCIpKSB7XG4gICAgcmV0dXJuIFwidWktbWVzc2FnZXNcIjtcbiAgfVxuICBjb25zdCBub25NZXNzYWdlSW5kZXggPSBjaGFyYWN0ZXJpc3RpY3MuZmluZEluZGV4KFxuICAgIChjKSA9PiBjICE9PSBcImhhcy1jb3JlLXNwZWNpZmljLXBhcnRzXCIgJiYgYyAhPT0gXCJtZXNzYWdlXCJcbiAgKTtcbiAgaWYgKG5vbk1lc3NhZ2VJbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gXCJtZXNzYWdlc1wiO1xuICB9XG4gIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgIHByb21wdCxcbiAgICBtZXNzYWdlOiBbXG4gICAgICBcIm1lc3NhZ2VzIG11c3QgYmUgYW4gYXJyYXkgb2YgQ29yZU1lc3NhZ2Ugb3IgVUlNZXNzYWdlXCIsXG4gICAgICBgUmVjZWl2ZWQgbWVzc2FnZSBvZiB0eXBlOiBcIiR7Y2hhcmFjdGVyaXN0aWNzW25vbk1lc3NhZ2VJbmRleF19XCIgYXQgaW5kZXggJHtub25NZXNzYWdlSW5kZXh9YCxcbiAgICAgIGBtZXNzYWdlc1ske25vbk1lc3NhZ2VJbmRleH1dOiAke0pTT04uc3RyaW5naWZ5KHByb21wdFtub25NZXNzYWdlSW5kZXhdKX1gXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuICAgIGNhdXNlOiBwcm9tcHRcbiAgfSk7XG59XG5mdW5jdGlvbiBkZXRlY3RTaW5nbGVNZXNzYWdlQ2hhcmFjdGVyaXN0aWNzKG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcIm9iamVjdFwiICYmIG1lc3NhZ2UgIT09IG51bGwgJiYgKG1lc3NhZ2Uucm9sZSA9PT0gXCJmdW5jdGlvblwiIHx8IC8vIFVJLW9ubHkgcm9sZVxuICBtZXNzYWdlLnJvbGUgPT09IFwiZGF0YVwiIHx8IC8vIFVJLW9ubHkgcm9sZVxuICBcInRvb2xJbnZvY2F0aW9uc1wiIGluIG1lc3NhZ2UgfHwgLy8gVUktc3BlY2lmaWMgZmllbGRcbiAgXCJwYXJ0c1wiIGluIG1lc3NhZ2UgfHwgLy8gVUktc3BlY2lmaWMgZmllbGRcbiAgXCJleHBlcmltZW50YWxfYXR0YWNobWVudHNcIiBpbiBtZXNzYWdlKSkge1xuICAgIHJldHVybiBcImhhcy11aS1zcGVjaWZpYy1wYXJ0c1wiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcIm9iamVjdFwiICYmIG1lc3NhZ2UgIT09IG51bGwgJiYgXCJjb250ZW50XCIgaW4gbWVzc2FnZSAmJiAoQXJyYXkuaXNBcnJheShtZXNzYWdlLmNvbnRlbnQpIHx8IC8vIENvcmUgbWVzc2FnZXMgY2FuIGhhdmUgYXJyYXkgY29udGVudFxuICBcImV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXCIgaW4gbWVzc2FnZSB8fCBcInByb3ZpZGVyT3B0aW9uc1wiIGluIG1lc3NhZ2UpKSB7XG4gICAgcmV0dXJuIFwiaGFzLWNvcmUtc3BlY2lmaWMtcGFydHNcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJiBtZXNzYWdlICE9PSBudWxsICYmIFwicm9sZVwiIGluIG1lc3NhZ2UgJiYgXCJjb250ZW50XCIgaW4gbWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiICYmIFtcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIiwgXCJ0b29sXCJdLmluY2x1ZGVzKG1lc3NhZ2Uucm9sZSkpIHtcbiAgICByZXR1cm4gXCJtZXNzYWdlXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib3RoZXJcIjtcbiAgfVxufVxuXG4vLyBjb3JlL3R5cGVzL3VzYWdlLnRzXG5mdW5jdGlvbiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2Uoe1xuICBwcm9tcHRUb2tlbnMsXG4gIGNvbXBsZXRpb25Ub2tlbnNcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHRUb2tlbnMsXG4gICAgY29tcGxldGlvblRva2VucyxcbiAgICB0b3RhbFRva2VuczogcHJvbXB0VG9rZW5zICsgY29tcGxldGlvblRva2Vuc1xuICB9O1xufVxuZnVuY3Rpb24gYWRkTGFuZ3VhZ2VNb2RlbFVzYWdlKHVzYWdlMSwgdXNhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAgcHJvbXB0VG9rZW5zOiB1c2FnZTEucHJvbXB0VG9rZW5zICsgdXNhZ2UyLnByb21wdFRva2VucyxcbiAgICBjb21wbGV0aW9uVG9rZW5zOiB1c2FnZTEuY29tcGxldGlvblRva2VucyArIHVzYWdlMi5jb21wbGV0aW9uVG9rZW5zLFxuICAgIHRvdGFsVG9rZW5zOiB1c2FnZTEudG90YWxUb2tlbnMgKyB1c2FnZTIudG90YWxUb2tlbnNcbiAgfTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvaW5qZWN0LWpzb24taW5zdHJ1Y3Rpb24udHNcbnZhciBERUZBVUxUX1NDSEVNQV9QUkVGSVggPSBcIkpTT04gc2NoZW1hOlwiO1xudmFyIERFRkFVTFRfU0NIRU1BX1NVRkZJWCA9IFwiWW91IE1VU1QgYW5zd2VyIHdpdGggYSBKU09OIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIEpTT04gc2NoZW1hIGFib3ZlLlwiO1xudmFyIERFRkFVTFRfR0VORVJJQ19TVUZGSVggPSBcIllvdSBNVVNUIGFuc3dlciB3aXRoIEpTT04uXCI7XG5mdW5jdGlvbiBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICBwcm9tcHQsXG4gIHNjaGVtYSxcbiAgc2NoZW1hUHJlZml4ID0gc2NoZW1hICE9IG51bGwgPyBERUZBVUxUX1NDSEVNQV9QUkVGSVggOiB2b2lkIDAsXG4gIHNjaGVtYVN1ZmZpeCA9IHNjaGVtYSAhPSBudWxsID8gREVGQVVMVF9TQ0hFTUFfU1VGRklYIDogREVGQVVMVF9HRU5FUklDX1NVRkZJWFxufSkge1xuICByZXR1cm4gW1xuICAgIHByb21wdCAhPSBudWxsICYmIHByb21wdC5sZW5ndGggPiAwID8gcHJvbXB0IDogdm9pZCAwLFxuICAgIHByb21wdCAhPSBudWxsICYmIHByb21wdC5sZW5ndGggPiAwID8gXCJcIiA6IHZvaWQgMCxcbiAgICAvLyBhZGQgYSBuZXdsaW5lIGlmIHByb21wdCBpcyBub3QgbnVsbFxuICAgIHNjaGVtYVByZWZpeCxcbiAgICBzY2hlbWEgIT0gbnVsbCA/IEpTT04uc3RyaW5naWZ5KHNjaGVtYSkgOiB2b2lkIDAsXG4gICAgc2NoZW1hU3VmZml4XG4gIF0uZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9IG51bGwpLmpvaW4oXCJcXG5cIik7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L291dHB1dC1zdHJhdGVneS50c1xuaW1wb3J0IHtcbiAgaXNKU09OQXJyYXksXG4gIGlzSlNPTk9iamVjdCxcbiAgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Jcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNhZmVWYWxpZGF0ZVR5cGVzIGFzIHNhZmVWYWxpZGF0ZVR5cGVzMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyBhc1NjaGVtYSB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIGNvcmUvdXRpbC9hc3luYy1pdGVyYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oc291cmNlKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHNvdXJjZS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKCkpO1xuICBzdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gKCkgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgcmV0dXJuIGRvbmUgPyB7IGRvbmU6IHRydWUsIHZhbHVlOiB2b2lkIDAgfSA6IHsgZG9uZTogZmFsc2UsIHZhbHVlIH07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvb3V0cHV0LXN0cmF0ZWd5LnRzXG52YXIgbm9TY2hlbWFPdXRwdXRTdHJhdGVneSA9IHtcbiAgdHlwZTogXCJuby1zY2hlbWFcIixcbiAganNvblNjaGVtYTogdm9pZCAwLFxuICB2YWxpZGF0ZVBhcnRpYWxSZXN1bHQoeyB2YWx1ZSwgdGV4dERlbHRhIH0pIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogeyBwYXJ0aWFsOiB2YWx1ZSwgdGV4dERlbHRhIH0gfTtcbiAgfSxcbiAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgICB0ZXh0OiBjb250ZXh0LnRleHQsXG4gICAgICAgIHJlc3BvbnNlOiBjb250ZXh0LnJlc3BvbnNlLFxuICAgICAgICB1c2FnZTogY29udGV4dC51c2FnZSxcbiAgICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0LmZpbmlzaFJlYXNvblxuICAgICAgfSlcbiAgICB9IDogeyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSB9O1xuICB9LFxuICBjcmVhdGVFbGVtZW50U3RyZWFtKCkge1xuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBuby1zY2hlbWEgbW9kZVwiXG4gICAgfSk7XG4gIH1cbn07XG52YXIgb2JqZWN0T3V0cHV0U3RyYXRlZ3kgPSAoc2NoZW1hKSA9PiAoe1xuICB0eXBlOiBcIm9iamVjdFwiLFxuICBqc29uU2NoZW1hOiBzY2hlbWEuanNvblNjaGVtYSxcbiAgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHsgdmFsdWUsIHRleHREZWx0YSB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICB2YWx1ZToge1xuICAgICAgICAvLyBOb3RlOiBjdXJyZW50bHkgbm8gdmFsaWRhdGlvbiBvZiBwYXJ0aWFsIHJlc3VsdHM6XG4gICAgICAgIHBhcnRpYWw6IHZhbHVlLFxuICAgICAgICB0ZXh0RGVsdGFcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHNhZmVWYWxpZGF0ZVR5cGVzMih7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnRTdHJlYW0oKSB7XG4gICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKHtcbiAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiZWxlbWVudCBzdHJlYW1zIGluIG9iamVjdCBtb2RlXCJcbiAgICB9KTtcbiAgfVxufSk7XG52YXIgYXJyYXlPdXRwdXRTdHJhdGVneSA9IChzY2hlbWEpID0+IHtcbiAgY29uc3QgeyAkc2NoZW1hLCAuLi5pdGVtU2NoZW1hIH0gPSBzY2hlbWEuanNvblNjaGVtYTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICAvLyB3cmFwIGluIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFycmF5IG9mIGVsZW1lbnRzLCBzaW5jZSBtb3N0IExMTXMgd2lsbCBub3RcbiAgICAvLyBiZSBhYmxlIHRvIGdlbmVyYXRlIGFuIGFycmF5IGRpcmVjdGx5OlxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBvcHRpbWl6YXRpb246IHVzZSBhcnJheXMgZGlyZWN0bHkgd2hlbiBtb2RlbCBzdXBwb3J0cyBncmFtbWFyLWd1aWRlZCBnZW5lcmF0aW9uXG4gICAganNvblNjaGVtYToge1xuICAgICAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGVsZW1lbnRzOiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IGl0ZW1TY2hlbWEgfVxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkOiBbXCJlbGVtZW50c1wiXSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgIH0sXG4gICAgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHsgdmFsdWUsIGxhdGVzdE9iamVjdCwgaXNGaXJzdERlbHRhLCBpc0ZpbmFsRGVsdGEgfSkge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgIWlzSlNPTkFycmF5KHZhbHVlLmVsZW1lbnRzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcih7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYW4gYXJyYXkgb2YgZWxlbWVudHNcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBpbnB1dEFycmF5ID0gdmFsdWUuZWxlbWVudHM7XG4gICAgICBjb25zdCByZXN1bHRBcnJheSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBpbnB1dEFycmF5W2ldO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzYWZlVmFsaWRhdGVUeXBlczIoeyB2YWx1ZTogZWxlbWVudCwgc2NoZW1hIH0pO1xuICAgICAgICBpZiAoaSA9PT0gaW5wdXRBcnJheS5sZW5ndGggLSAxICYmICFpc0ZpbmFsRGVsdGEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRBcnJheS5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwdWJsaXNoZWRFbGVtZW50Q291bnQgPSAoX2ExNyA9IGxhdGVzdE9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogbGF0ZXN0T2JqZWN0Lmxlbmd0aCkgIT0gbnVsbCA/IF9hMTcgOiAwO1xuICAgICAgbGV0IHRleHREZWx0YSA9IFwiXCI7XG4gICAgICBpZiAoaXNGaXJzdERlbHRhKSB7XG4gICAgICAgIHRleHREZWx0YSArPSBcIltcIjtcbiAgICAgIH1cbiAgICAgIGlmIChwdWJsaXNoZWRFbGVtZW50Q291bnQgPiAwKSB7XG4gICAgICAgIHRleHREZWx0YSArPSBcIixcIjtcbiAgICAgIH1cbiAgICAgIHRleHREZWx0YSArPSByZXN1bHRBcnJheS5zbGljZShwdWJsaXNoZWRFbGVtZW50Q291bnQpLm1hcCgoZWxlbWVudCkgPT4gSlNPTi5zdHJpbmdpZnkoZWxlbWVudCkpLmpvaW4oXCIsXCIpO1xuICAgICAgaWYgKGlzRmluYWxEZWx0YSkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCJdXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHBhcnRpYWw6IHJlc3VsdEFycmF5LFxuICAgICAgICAgIHRleHREZWx0YVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8ICFpc0pTT05BcnJheSh2YWx1ZS5lbGVtZW50cykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFuIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRBcnJheSA9IHZhbHVlLmVsZW1lbnRzO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGlucHV0QXJyYXkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2FmZVZhbGlkYXRlVHlwZXMyKHsgdmFsdWU6IGVsZW1lbnQsIHNjaGVtYSB9KTtcbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiBpbnB1dEFycmF5IH07XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50U3RyZWFtKG9yaWdpbmFsU3RyZWFtKSB7XG4gICAgICBsZXQgcHVibGlzaGVkRWxlbWVudHMgPSAwO1xuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICAgIG9yaWdpbmFsU3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXkgPSBjaHVuay5vYmplY3Q7XG4gICAgICAgICAgICAgICAgICBmb3IgKDsgcHVibGlzaGVkRWxlbWVudHMgPCBhcnJheS5sZW5ndGg7IHB1Ymxpc2hlZEVsZW1lbnRzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGFycmF5W3B1Ymxpc2hlZEVsZW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBVbnN1cHBvcnRlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn07XG52YXIgZW51bU91dHB1dFN0cmF0ZWd5ID0gKGVudW1WYWx1ZXMpID0+IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICAvLyB3cmFwIGluIG9iamVjdCB0aGF0IGNvbnRhaW5zIHJlc3VsdCwgc2luY2UgbW9zdCBMTE1zIHdpbGwgbm90XG4gICAgLy8gYmUgYWJsZSB0byBnZW5lcmF0ZSBhbiBlbnVtIHZhbHVlIGRpcmVjdGx5OlxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBvcHRpbWl6YXRpb246IHVzZSBlbnVtcyBkaXJlY3RseSB3aGVuIG1vZGVsIHN1cHBvcnRzIHRvcC1sZXZlbCBlbnVtc1xuICAgIGpzb25TY2hlbWE6IHtcbiAgICAgICRzY2hlbWE6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICByZXN1bHQ6IHsgdHlwZTogXCJzdHJpbmdcIiwgZW51bTogZW51bVZhbHVlcyB9XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IFtcInJlc3VsdFwiXSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgIH0sXG4gICAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yZXN1bHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogJ3ZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBzdHJpbmcgaW4gdGhlIFwicmVzdWx0XCIgcHJvcGVydHkuJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5yZXN1bHQ7XG4gICAgICByZXR1cm4gZW51bVZhbHVlcy5pbmNsdWRlcyhyZXN1bHQpID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0IH0gOiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYSBzdHJpbmcgaW4gdGhlIGVudW1cIlxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9LFxuICAgIHZhbGlkYXRlUGFydGlhbFJlc3VsdCgpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwicGFydGlhbCByZXN1bHRzIGluIGVudW0gbW9kZVwiXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnRTdHJlYW0oKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBlbnVtIG1vZGVcIlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIGdldE91dHB1dFN0cmF0ZWd5KHtcbiAgb3V0cHV0LFxuICBzY2hlbWEsXG4gIGVudW1WYWx1ZXNcbn0pIHtcbiAgc3dpdGNoIChvdXRwdXQpIHtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gb2JqZWN0T3V0cHV0U3RyYXRlZ3koYXNTY2hlbWEoc2NoZW1hKSk7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICByZXR1cm4gYXJyYXlPdXRwdXRTdHJhdGVneShhc1NjaGVtYShzY2hlbWEpKTtcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgcmV0dXJuIGVudW1PdXRwdXRTdHJhdGVneShlbnVtVmFsdWVzKTtcbiAgICBjYXNlIFwibm8tc2NoZW1hXCI6XG4gICAgICByZXR1cm4gbm9TY2hlbWFPdXRwdXRTdHJhdGVneTtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gb3V0cHV0O1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvdXRwdXQ6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvdmFsaWRhdGUtb2JqZWN0LWdlbmVyYXRpb24taW5wdXQudHNcbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0KHtcbiAgb3V0cHV0LFxuICBtb2RlLFxuICBzY2hlbWEsXG4gIHNjaGVtYU5hbWUsXG4gIHNjaGVtYURlc2NyaXB0aW9uLFxuICBlbnVtVmFsdWVzXG59KSB7XG4gIGlmIChvdXRwdXQgIT0gbnVsbCAmJiBvdXRwdXQgIT09IFwib2JqZWN0XCIgJiYgb3V0cHV0ICE9PSBcImFycmF5XCIgJiYgb3V0cHV0ICE9PSBcImVudW1cIiAmJiBvdXRwdXQgIT09IFwibm8tc2NoZW1hXCIpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgcGFyYW1ldGVyOiBcIm91dHB1dFwiLFxuICAgICAgdmFsdWU6IG91dHB1dCxcbiAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBvdXRwdXQgdHlwZS5cIlxuICAgIH0pO1xuICB9XG4gIGlmIChvdXRwdXQgPT09IFwibm8tc2NoZW1hXCIpIHtcbiAgICBpZiAobW9kZSA9PT0gXCJhdXRvXCIgfHwgbW9kZSA9PT0gXCJ0b29sXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtb2RlXCIsXG4gICAgICAgIHZhbHVlOiBtb2RlLFxuICAgICAgICBtZXNzYWdlOiAnTW9kZSBtdXN0IGJlIFwianNvblwiIGZvciBuby1zY2hlbWEgb3V0cHV0LidcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgaXMgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFEZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hRGVzY3JpcHRpb25cIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBkZXNjcmlwdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYU5hbWUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYU5hbWVcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYU5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIG5hbWUgaXMgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyByZXF1aXJlZCBmb3Igb2JqZWN0IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBvYmplY3Qgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJhcnJheVwiKSB7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiRWxlbWVudCBzY2hlbWEgaXMgcmVxdWlyZWQgZm9yIGFycmF5IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBhcnJheSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcImVudW1cIikge1xuICAgIGlmIChzY2hlbWEgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyBub3Qgc3VwcG9ydGVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFEZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hRGVzY3JpcHRpb25cIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBkZXNjcmlwdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFOYW1lICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFOYW1lXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWFOYW1lLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBuYW1lIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIHJlcXVpcmVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZW51bVZhbHVlcykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBtdXN0IGJlIHN0cmluZ3MuXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIGNvcmUvcHJvbXB0L3N0cmluZ2lmeS1mb3ItdGVsZW1ldHJ5LnRzXG5mdW5jdGlvbiBzdHJpbmdpZnlGb3JUZWxlbWV0cnkocHJvbXB0KSB7XG4gIGNvbnN0IHByb2Nlc3NlZFByb21wdCA9IHByb21wdC5tYXAoKG1lc3NhZ2UpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ubWVzc2FnZSxcbiAgICAgIGNvbnRlbnQ6IHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlLmNvbnRlbnQgOiBtZXNzYWdlLmNvbnRlbnQubWFwKHByb2Nlc3NQYXJ0KVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocHJvY2Vzc2VkUHJvbXB0KTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NQYXJ0KHBhcnQpIHtcbiAgaWYgKHBhcnQudHlwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBhcnQsXG4gICAgICBpbWFnZTogcGFydC5pbWFnZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhwYXJ0LmltYWdlKSA6IHBhcnQuaW1hZ2VcbiAgICB9O1xuICB9XG4gIHJldHVybiBwYXJ0O1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9nZW5lcmF0ZS1vYmplY3QudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQgPSBjcmVhdGVJZEdlbmVyYXRvcih7IHByZWZpeDogXCJhaW9ialwiLCBzaXplOiAyNCB9KTtcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlT2JqZWN0KHtcbiAgbW9kZWwsXG4gIGVudW06IGVudW1WYWx1ZXMsXG4gIC8vIHJlbmFtZSBiYyBlbnVtIGlzIHJlc2VydmVkIGJ5IHR5cGVzY3JpcHRcbiAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgc2NoZW1hTmFtZSxcbiAgc2NoZW1hRGVzY3JpcHRpb24sXG4gIG1vZGUsXG4gIG91dHB1dCA9IFwib2JqZWN0XCIsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF9yZXBhaXJUZXh0OiByZXBhaXJUZXh0LFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICBwcm92aWRlck9wdGlvbnMgPSBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgX2ludGVybmFsOiB7XG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMgPSBvcmlnaW5hbEdlbmVyYXRlSWQsXG4gICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICB9ID0ge30sXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIHZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0KHtcbiAgICBvdXRwdXQsXG4gICAgbW9kZSxcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoeyBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnIH0pO1xuICBjb25zdCBvdXRwdXRTdHJhdGVneSA9IGdldE91dHB1dFN0cmF0ZWd5KHtcbiAgICBvdXRwdXQsXG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBlbnVtVmFsdWVzXG4gIH0pO1xuICBpZiAob3V0cHV0U3RyYXRlZ3kudHlwZSA9PT0gXCJuby1zY2hlbWFcIiAmJiBtb2RlID09PSB2b2lkIDApIHtcbiAgICBtb2RlID0gXCJqc29uXCI7XG4gIH1cbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVPYmplY3RcIixcbiAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgfSxcbiAgICAgICAgXCJhaS5zY2hlbWFcIjogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSAhPSBudWxsID8geyBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSkgfSA6IHZvaWQgMCxcbiAgICAgICAgXCJhaS5zY2hlbWEubmFtZVwiOiBzY2hlbWFOYW1lLFxuICAgICAgICBcImFpLnNjaGVtYS5kZXNjcmlwdGlvblwiOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgXCJhaS5zZXR0aW5ncy5vdXRwdXRcIjogb3V0cHV0U3RyYXRlZ3kudHlwZSxcbiAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGVcbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICB2YXIgX2ExNywgX2IsIF9jLCBfZDtcbiAgICAgIGlmIChtb2RlID09PSBcImF1dG9cIiB8fCBtb2RlID09IG51bGwpIHtcbiAgICAgICAgbW9kZSA9IG1vZGVsLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICBsZXQgZmluaXNoUmVhc29uO1xuICAgICAgbGV0IHVzYWdlO1xuICAgICAgbGV0IHdhcm5pbmdzO1xuICAgICAgbGV0IHJhd1Jlc3BvbnNlO1xuICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgbGV0IHJlcXVlc3Q7XG4gICAgICBsZXQgbG9ncHJvYnM7XG4gICAgICBsZXQgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlIFwianNvblwiOiB7XG4gICAgICAgICAgY29uc3Qgc3RhbmRhcmRpemVkUHJvbXB0ID0gc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiB7XG4gICAgICAgICAgICAgIHN5c3RlbTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSA9PSBudWxsID8gaW5qZWN0SnNvbkluc3RydWN0aW9uKHsgcHJvbXB0OiBzeXN0ZW0gfSkgOiBtb2RlbC5zdXBwb3J0c1N0cnVjdHVyZWRPdXRwdXRzID8gc3lzdGVtIDogaW5qZWN0SnNvbkluc3RydWN0aW9uKHtcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IHN5c3RlbSxcbiAgICAgICAgICAgICAgICBzY2hlbWE6IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWFcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgICAgbWVzc2FnZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b29sczogdm9pZCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgIHByb21wdDogc3RhbmRhcmRpemVkUHJvbXB0LFxuICAgICAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHMsXG4gICAgICAgICAgICBtb2RlbFN1cHBvcnRzVXJsOiAoX2ExNyA9IG1vZGVsLnN1cHBvcnRzVXJsKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5iaW5kKG1vZGVsKVxuICAgICAgICAgICAgLy8gc3VwcG9ydCAndGhpcycgY29udGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGdlbmVyYXRlUmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgICAgbmFtZTogXCJhaS5nZW5lcmF0ZU9iamVjdC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZU9iamVjdC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdGFuZGFyZGl6ZWRQcm9tcHQudHlwZVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHByb21wdE1lc3NhZ2VzKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkuc2V0dGluZ3MubW9kZVwiOiBtb2RlLFxuICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hMTgsIF9iMiwgX2MyLCBfZDIsIF9lLCBfZjtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LWpzb25cIixcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0OiBzdGFuZGFyZGl6ZWRQcm9tcHQudHlwZSxcbiAgICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICBpZDogKF9iMiA9IChfYTE4ID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTguaWQpICE9IG51bGwgPyBfYjIgOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2QyID0gKF9jMiA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYzIudGltZXN0YW1wKSAhPSBudWxsID8gX2QyIDogY3VycmVudERhdGUoKSxcbiAgICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfZiA9IChfZSA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZS5tb2RlbElkKSAhPSBudWxsID8gX2YgOiBtb2RlbC5tb2RlbElkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Mi50ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiB0aGUgbW9kZWwgZGlkIG5vdCByZXR1cm4gYSByZXNwb25zZS5cIixcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZShyZXN1bHQyLnVzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiByZXN1bHQyLmZpbmlzaFJlYXNvblxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwYW4yLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogcmVzdWx0Mi5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IHJlc3VsdDIudGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogcmVzcG9uc2VEYXRhLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtyZXN1bHQyLmZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLnByb21wdF90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuY29tcGxldGlvbl90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQyLCBvYmplY3RUZXh0OiByZXN1bHQyLnRleHQsIHJlc3BvbnNlRGF0YSB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVSZXN1bHQub2JqZWN0VGV4dDtcbiAgICAgICAgICBmaW5pc2hSZWFzb24gPSBnZW5lcmF0ZVJlc3VsdC5maW5pc2hSZWFzb247XG4gICAgICAgICAgdXNhZ2UgPSBnZW5lcmF0ZVJlc3VsdC51c2FnZTtcbiAgICAgICAgICB3YXJuaW5ncyA9IGdlbmVyYXRlUmVzdWx0Lndhcm5pbmdzO1xuICAgICAgICAgIHJhd1Jlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmF3UmVzcG9uc2U7XG4gICAgICAgICAgbG9ncHJvYnMgPSBnZW5lcmF0ZVJlc3VsdC5sb2dwcm9icztcbiAgICAgICAgICByZXN1bHRQcm92aWRlck1ldGFkYXRhID0gZ2VuZXJhdGVSZXN1bHQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICByZXF1ZXN0ID0gKF9iID0gZ2VuZXJhdGVSZXN1bHQucmVxdWVzdCkgIT0gbnVsbCA/IF9iIDoge307XG4gICAgICAgICAgcmVzcG9uc2UgPSBnZW5lcmF0ZVJlc3VsdC5yZXNwb25zZURhdGE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICAgIGNvbnN0IHN0YW5kYXJkaXplZFByb21wdCA9IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICAgICAgICAgIHByb21wdDogeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSxcbiAgICAgICAgICAgIHRvb2xzOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiBzdGFuZGFyZGl6ZWRQcm9tcHQsXG4gICAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJscyxcbiAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IChfYyA9IG1vZGVsLnN1cHBvcnRzVXJsKSA9PSBudWxsID8gdm9pZCAwIDogX2MuYmluZChtb2RlbClcbiAgICAgICAgICAgIC8vIHN1cHBvcnQgJ3RoaXMnIGNvbnRleHQsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgaW5wdXRGb3JtYXQgPSBzdGFuZGFyZGl6ZWRQcm9tcHQudHlwZTtcbiAgICAgICAgICBjb25zdCBnZW5lcmF0ZVJlc3VsdCA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5mb3JtYXRcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gaW5wdXRGb3JtYXRcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdHJpbmdpZnlGb3JUZWxlbWV0cnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGUsXG4gICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IHNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IHNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogc2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IHNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbjIpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2ExOCwgX2IyLCBfYzIsIF9kMiwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgICAgICAgICAgbW9kZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdC10b29sXCIsXG4gICAgICAgICAgICAgICAgICAgIHRvb2w6IHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogc2NoZW1hTmFtZSAhPSBudWxsID8gc2NoZW1hTmFtZSA6IFwianNvblwiLFxuICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFEZXNjcmlwdGlvbiAhPSBudWxsID8gc2NoZW1hRGVzY3JpcHRpb24gOiBcIlJlc3BvbmQgd2l0aCBhIEpTT04gb2JqZWN0LlwiLFxuICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgICAgICAgICAgICAgaW5wdXRGb3JtYXQsXG4gICAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0VGV4dCA9IChfYjIgPSAoX2ExOCA9IHJlc3VsdDIudG9vbENhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5hcmdzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgIGlkOiAoX2QyID0gKF9jMiA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYzIuaWQpICE9IG51bGwgPyBfZDIgOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2YgPSAoX2UgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2UudGltZXN0YW1wKSAhPSBudWxsID8gX2YgOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgbW9kZWxJZDogKF9oID0gKF9nID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLm1vZGVsSWQpICE9IG51bGwgPyBfaCA6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3RUZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiB0aGUgdG9vbCB3YXMgbm90IGNhbGxlZC5cIixcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZShyZXN1bHQyLnVzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiByZXN1bHQyLmZpbmlzaFJlYXNvblxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwYW4yLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogcmVzdWx0Mi5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IG9iamVjdFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlRGF0YS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogcmVzdWx0Mi51c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbcmVzdWx0Mi5maW5pc2hSZWFzb25dLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5pbnB1dF90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2Uub3V0cHV0X3Rva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnJlc3VsdDIsIG9iamVjdFRleHQsIHJlc3BvbnNlRGF0YSB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVSZXN1bHQub2JqZWN0VGV4dDtcbiAgICAgICAgICBmaW5pc2hSZWFzb24gPSBnZW5lcmF0ZVJlc3VsdC5maW5pc2hSZWFzb247XG4gICAgICAgICAgdXNhZ2UgPSBnZW5lcmF0ZVJlc3VsdC51c2FnZTtcbiAgICAgICAgICB3YXJuaW5ncyA9IGdlbmVyYXRlUmVzdWx0Lndhcm5pbmdzO1xuICAgICAgICAgIHJhd1Jlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmF3UmVzcG9uc2U7XG4gICAgICAgICAgbG9ncHJvYnMgPSBnZW5lcmF0ZVJlc3VsdC5sb2dwcm9icztcbiAgICAgICAgICByZXN1bHRQcm92aWRlck1ldGFkYXRhID0gZ2VuZXJhdGVSZXN1bHQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICByZXF1ZXN0ID0gKF9kID0gZ2VuZXJhdGVSZXN1bHQucmVxdWVzdCkgIT0gbnVsbCA/IF9kIDoge307XG4gICAgICAgICAgcmVzcG9uc2UgPSBnZW5lcmF0ZVJlc3VsdC5yZXNwb25zZURhdGE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB2b2lkIDA6IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIk1vZGVsIGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0IG9iamVjdCBnZW5lcmF0aW9uIG1vZGUuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gbW9kZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1vZGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcHJvY2Vzc1Jlc3VsdChyZXN1bHQyKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTih7IHRleHQ6IHJlc3VsdDIgfSk7XG4gICAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogY291bGQgbm90IHBhcnNlIHRoZSByZXNwb25zZS5cIixcbiAgICAgICAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgICAgICAgIHRleHQ6IHJlc3VsdDIsXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHVzYWdlOiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UodXNhZ2UpLFxuICAgICAgICAgICAgZmluaXNoUmVhc29uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlRmluYWxSZXN1bHQoXG4gICAgICAgICAgcGFyc2VSZXN1bHQudmFsdWUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGV4dDogcmVzdWx0MixcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZSlcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiByZXNwb25zZSBkaWQgbm90IG1hdGNoIHNjaGVtYS5cIixcbiAgICAgICAgICAgIGNhdXNlOiB2YWxpZGF0aW9uUmVzdWx0LmVycm9yLFxuICAgICAgICAgICAgdGV4dDogcmVzdWx0MixcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZSksXG4gICAgICAgICAgICBmaW5pc2hSZWFzb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWRhdGlvblJlc3VsdC52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGxldCBvYmplY3QyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgb2JqZWN0MiA9IHByb2Nlc3NSZXN1bHQocmVzdWx0KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChyZXBhaXJUZXh0ICE9IG51bGwgJiYgTm9PYmplY3RHZW5lcmF0ZWRFcnJvci5pc0luc3RhbmNlKGVycm9yKSAmJiAoSlNPTlBhcnNlRXJyb3IuaXNJbnN0YW5jZShlcnJvci5jYXVzZSkgfHwgVHlwZVZhbGlkYXRpb25FcnJvcjIuaXNJbnN0YW5jZShlcnJvci5jYXVzZSkpKSB7XG4gICAgICAgICAgY29uc3QgcmVwYWlyZWRUZXh0ID0gYXdhaXQgcmVwYWlyVGV4dCh7XG4gICAgICAgICAgICB0ZXh0OiByZXN1bHQsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IuY2F1c2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocmVwYWlyZWRUZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqZWN0MiA9IHByb2Nlc3NSZXN1bHQocmVwYWlyZWRUZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5vYmplY3RcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG9iamVjdDIpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogdXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0R2VuZXJhdGVPYmplY3RSZXN1bHQoe1xuICAgICAgICBvYmplY3Q6IG9iamVjdDIsXG4gICAgICAgIGZpbmlzaFJlYXNvbixcbiAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZSksXG4gICAgICAgIHdhcm5pbmdzLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5ib2R5XG4gICAgICAgIH0sXG4gICAgICAgIGxvZ3Byb2JzLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiByZXN1bHRQcm92aWRlck1ldGFkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRHZW5lcmF0ZU9iamVjdFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub2JqZWN0ID0gb3B0aW9ucy5vYmplY3Q7XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSBvcHRpb25zLmZpbmlzaFJlYXNvbjtcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgdGhpcy5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YTtcbiAgICB0aGlzLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICB0aGlzLnJlcXVlc3QgPSBvcHRpb25zLnJlcXVlc3Q7XG4gICAgdGhpcy5sb2dwcm9icyA9IG9wdGlvbnMubG9ncHJvYnM7XG4gIH1cbiAgdG9Kc29uUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTE3O1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5vYmplY3QpLCB7XG4gICAgICBzdGF0dXM6IChfYTE3ID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTE3IDogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnMsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9zdHJlYW0tb2JqZWN0LnRzXG5pbXBvcnQgeyBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHtcbiAgaXNEZWVwRXF1YWxEYXRhLFxuICBwYXJzZVBhcnRpYWxKc29uXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIHV0aWwvZGVsYXllZC1wcm9taXNlLnRzXG52YXIgRGVsYXllZFByb21pc2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInBlbmRpbmdcIiB9O1xuICAgIHRoaXMuX3Jlc29sdmUgPSB2b2lkIDA7XG4gICAgdGhpcy5fcmVqZWN0ID0gdm9pZCAwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAodGhpcy5wcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0dXMudHlwZSA9PT0gXCJyZXNvbHZlZFwiKSB7XG4gICAgICAgIHJlc29sdmUodGhpcy5zdGF0dXMudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cy50eXBlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgcmVqZWN0KHRoaXMuc3RhdHVzLmVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gIH1cbiAgcmVzb2x2ZSh2YWx1ZSkge1xuICAgIHZhciBfYTE3O1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInJlc29sdmVkXCIsIHZhbHVlIH07XG4gICAgaWYgKHRoaXMucHJvbWlzZSkge1xuICAgICAgKF9hMTcgPSB0aGlzLl9yZXNvbHZlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmVqZWN0KGVycm9yKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgdGhpcy5zdGF0dXMgPSB7IHR5cGU6IFwicmVqZWN0ZWRcIiwgZXJyb3IgfTtcbiAgICBpZiAodGhpcy5wcm9taXNlKSB7XG4gICAgICAoX2ExNyA9IHRoaXMuX3JlamVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgfVxuICB9XG59O1xuXG4vLyB1dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIHJlc29sdmUsXG4gICAgcmVqZWN0XG4gIH07XG59XG5cbi8vIGNvcmUvdXRpbC9jcmVhdGUtc3RpdGNoYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKSB7XG4gIGxldCBpbm5lclN0cmVhbVJlYWRlcnMgPSBbXTtcbiAgbGV0IGNvbnRyb2xsZXIgPSBudWxsO1xuICBsZXQgaXNDbG9zZWQgPSBmYWxzZTtcbiAgbGV0IHdhaXRGb3JOZXdTdHJlYW0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICBjb25zdCBwcm9jZXNzUHVsbCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNDbG9zZWQgJiYgaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgd2FpdEZvck5ld1N0cmVhbSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgICBhd2FpdCB3YWl0Rm9yTmV3U3RyZWFtLnByb21pc2U7XG4gICAgICByZXR1cm4gcHJvY2Vzc1B1bGwoKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGlubmVyU3RyZWFtUmVhZGVyc1swXS5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBpbm5lclN0cmVhbVJlYWRlcnMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYXdhaXQgcHJvY2Vzc1B1bGwoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Nsb3NlZCkge1xuICAgICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICBpbm5lclN0cmVhbVJlYWRlcnMuc2hpZnQoKTtcbiAgICAgIGlmIChpc0Nsb3NlZCAmJiBpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQoY29udHJvbGxlclBhcmFtKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyUGFyYW07XG4gICAgICB9LFxuICAgICAgcHVsbDogcHJvY2Vzc1B1bGwsXG4gICAgICBhc3luYyBjYW5jZWwoKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIGlubmVyU3RyZWFtUmVhZGVycykge1xuICAgICAgICAgIGF3YWl0IHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBpbm5lclN0cmVhbVJlYWRlcnMgPSBbXTtcbiAgICAgICAgaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGFkZFN0cmVhbTogKGlubmVyU3RyZWFtKSA9PiB7XG4gICAgICBpZiAoaXNDbG9zZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBpbm5lciBzdHJlYW06IG91dGVyIHN0cmVhbSBpcyBjbG9zZWRcIik7XG4gICAgICB9XG4gICAgICBpbm5lclN0cmVhbVJlYWRlcnMucHVzaChpbm5lclN0cmVhbS5nZXRSZWFkZXIoKSk7XG4gICAgICB3YWl0Rm9yTmV3U3RyZWFtLnJlc29sdmUoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdyYWNlZnVsbHkgY2xvc2UgdGhlIG91dGVyIHN0cmVhbS4gVGhpcyB3aWxsIGxldCB0aGUgaW5uZXIgc3RyZWFtc1xuICAgICAqIGZpbmlzaCBwcm9jZXNzaW5nIGFuZCB0aGVuIGNsb3NlIHRoZSBvdXRlciBzdHJlYW0uXG4gICAgICovXG4gICAgY2xvc2U6ICgpID0+IHtcbiAgICAgIGlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIHdhaXRGb3JOZXdTdHJlYW0ucmVzb2x2ZSgpO1xuICAgICAgaWYgKGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogSW1tZWRpYXRlbHkgY2xvc2UgdGhlIG91dGVyIHN0cmVhbS4gVGhpcyB3aWxsIGNhbmNlbCBhbGwgaW5uZXIgc3RyZWFtc1xuICAgICAqIGFuZCBjbG9zZSB0aGUgb3V0ZXIgc3RyZWFtLlxuICAgICAqL1xuICAgIHRlcm1pbmF0ZTogKCkgPT4ge1xuICAgICAgaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgd2FpdEZvck5ld1N0cmVhbS5yZXNvbHZlKCk7XG4gICAgICBpbm5lclN0cmVhbVJlYWRlcnMuZm9yRWFjaCgocmVhZGVyKSA9PiByZWFkZXIuY2FuY2VsKCkpO1xuICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzID0gW107XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBjb3JlL3V0aWwvbm93LnRzXG5mdW5jdGlvbiBub3coKSB7XG4gIHZhciBfYTE3LCBfYjtcbiAgcmV0dXJuIChfYiA9IChfYTE3ID0gZ2xvYmFsVGhpcyA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcubm93KCkpICE9IG51bGwgPyBfYiA6IERhdGUubm93KCk7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L3N0cmVhbS1vYmplY3QudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQyID0gY3JlYXRlSWRHZW5lcmF0b3IyKHsgcHJlZml4OiBcImFpb2JqXCIsIHNpemU6IDI0IH0pO1xuZnVuY3Rpb24gc3RyZWFtT2JqZWN0KHtcbiAgbW9kZWwsXG4gIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gIHNjaGVtYU5hbWUsXG4gIHNjaGVtYURlc2NyaXB0aW9uLFxuICBtb2RlLFxuICBvdXRwdXQgPSBcIm9iamVjdFwiLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICBwcm92aWRlck9wdGlvbnMgPSBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgb25FcnJvcixcbiAgb25GaW5pc2gsXG4gIF9pbnRlcm5hbDoge1xuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkMixcbiAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgIG5vdzogbm93MiA9IG5vd1xuICB9ID0ge30sXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIHZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0KHtcbiAgICBvdXRwdXQsXG4gICAgbW9kZSxcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb25cbiAgfSk7XG4gIGNvbnN0IG91dHB1dFN0cmF0ZWd5ID0gZ2V0T3V0cHV0U3RyYXRlZ3koeyBvdXRwdXQsIHNjaGVtYTogaW5wdXRTY2hlbWEgfSk7XG4gIGlmIChvdXRwdXRTdHJhdGVneS50eXBlID09PSBcIm5vLXNjaGVtYVwiICYmIG1vZGUgPT09IHZvaWQgMCkge1xuICAgIG1vZGUgPSBcImpzb25cIjtcbiAgfVxuICByZXR1cm4gbmV3IERlZmF1bHRTdHJlYW1PYmplY3RSZXN1bHQoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzLFxuICAgIG1heFJldHJpZXMsXG4gICAgYWJvcnRTaWduYWwsXG4gICAgb3V0cHV0U3RyYXRlZ3ksXG4gICAgc3lzdGVtLFxuICAgIHByb21wdCxcbiAgICBtZXNzYWdlcyxcbiAgICBzY2hlbWFOYW1lLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uLFxuICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICBtb2RlLFxuICAgIG9uRXJyb3IsXG4gICAgb25GaW5pc2gsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMsXG4gICAgY3VycmVudERhdGUsXG4gICAgbm93OiBub3cyXG4gIH0pO1xufVxudmFyIERlZmF1bHRTdHJlYW1PYmplY3RSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtb2RlbCxcbiAgICBoZWFkZXJzLFxuICAgIHRlbGVtZXRyeSxcbiAgICBzZXR0aW5ncyxcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsLFxuICAgIG91dHB1dFN0cmF0ZWd5LFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgc2NoZW1hTmFtZSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgbW9kZSxcbiAgICBvbkVycm9yLFxuICAgIG9uRmluaXNoLFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzLFxuICAgIGN1cnJlbnREYXRlLFxuICAgIG5vdzogbm93MlxuICB9KSB7XG4gICAgdGhpcy5vYmplY3RQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy51c2FnZVByb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGFQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy53YXJuaW5nc1Byb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLnJlcXVlc3RQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5yZXNwb25zZVByb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnXG4gICAgfSk7XG4gICAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICBtb2RlbCxcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzZXR0aW5nczogeyAuLi5zZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gICAgfSk7XG4gICAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3Qgc3RpdGNoYWJsZVN0cmVhbSA9IGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKTtcbiAgICBjb25zdCBldmVudFByb2Nlc3NvciA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICBvbkVycm9yID09IG51bGwgPyB2b2lkIDAgOiBvbkVycm9yKHsgZXJyb3I6IGNodW5rLmVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5iYXNlU3RyZWFtID0gc3RpdGNoYWJsZVN0cmVhbS5zdHJlYW0ucGlwZVRocm91Z2goZXZlbnRQcm9jZXNzb3IpO1xuICAgIHJlY29yZFNwYW4oe1xuICAgICAgbmFtZTogXCJhaS5zdHJlYW1PYmplY3RcIixcbiAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtT2JqZWN0XCIsXG4gICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImFpLnNjaGVtYVwiOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hICE9IG51bGwgPyB7IGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hKSB9IDogdm9pZCAwLFxuICAgICAgICAgIFwiYWkuc2NoZW1hLm5hbWVcIjogc2NoZW1hTmFtZSxcbiAgICAgICAgICBcImFpLnNjaGVtYS5kZXNjcmlwdGlvblwiOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgICBcImFpLnNldHRpbmdzLm91dHB1dFwiOiBvdXRwdXRTdHJhdGVneS50eXBlLFxuICAgICAgICAgIFwiYWkuc2V0dGluZ3MubW9kZVwiOiBtb2RlXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgZm46IGFzeW5jIChyb290U3BhbikgPT4ge1xuICAgICAgICB2YXIgX2ExNywgX2I7XG4gICAgICAgIGlmIChtb2RlID09PSBcImF1dG9cIiB8fCBtb2RlID09IG51bGwpIHtcbiAgICAgICAgICBtb2RlID0gbW9kZWwuZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjYWxsT3B0aW9ucztcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVyO1xuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICBjYXNlIFwianNvblwiOiB7XG4gICAgICAgICAgICBjb25zdCBzdGFuZGFyZGl6ZWRQcm9tcHQgPSBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgICAgICAgIHByb21wdDoge1xuICAgICAgICAgICAgICAgIHN5c3RlbTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSA9PSBudWxsID8gaW5qZWN0SnNvbkluc3RydWN0aW9uKHsgcHJvbXB0OiBzeXN0ZW0gfSkgOiBtb2RlbC5zdXBwb3J0c1N0cnVjdHVyZWRPdXRwdXRzID8gc3lzdGVtIDogaW5qZWN0SnNvbkluc3RydWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgIHByb21wdDogc3lzdGVtLFxuICAgICAgICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRvb2xzOiB2b2lkIDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgIG1vZGU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdC1qc29uXCIsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hLFxuICAgICAgICAgICAgICAgIG5hbWU6IHNjaGVtYU5hbWUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgICAgICAgICBpbnB1dEZvcm1hdDogc3RhbmRhcmRpemVkUHJvbXB0LnR5cGUsXG4gICAgICAgICAgICAgIHByb21wdDogYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICAgICAgcHJvbXB0OiBzdGFuZGFyZGl6ZWRQcm9tcHQsXG4gICAgICAgICAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHMsXG4gICAgICAgICAgICAgICAgbW9kZWxTdXBwb3J0c1VybDogKF9hMTcgPSBtb2RlbC5zdXBwb3J0c1VybCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuYmluZChtb2RlbClcbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0ICd0aGlzJyBjb250ZXh0XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhbnNmb3JtZXIgPSB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICAgICAgY29uc3Qgc3RhbmRhcmRpemVkUHJvbXB0ID0gc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgICAgICAgICAgICBwcm9tcHQ6IHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0sXG4gICAgICAgICAgICAgIHRvb2xzOiB2b2lkIDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgIG1vZGU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdC10b29sXCIsXG4gICAgICAgICAgICAgICAgdG9vbDoge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgbmFtZTogc2NoZW1hTmFtZSAhPSBudWxsID8gc2NoZW1hTmFtZSA6IFwianNvblwiLFxuICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwgPyBzY2hlbWFEZXNjcmlwdGlvbiA6IFwiUmVzcG9uZCB3aXRoIGEgSlNPTiBvYmplY3QuXCIsXG4gICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IHN0YW5kYXJkaXplZFByb21wdC50eXBlLFxuICAgICAgICAgICAgICBwcm9tcHQ6IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgICAgIHByb21wdDogc3RhbmRhcmRpemVkUHJvbXB0LFxuICAgICAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgICAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IChfYiA9IG1vZGVsLnN1cHBvcnRzVXJsKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYmluZChtb2RlbClcbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0ICd0aGlzJyBjb250ZXh0LFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVyID0ge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLmFyZ3NUZXh0RGVsdGEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIHZvaWQgMDoge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIk1vZGVsIGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0IG9iamVjdCBnZW5lcmF0aW9uIG1vZGUuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBtb2RlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtb2RlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByZXN1bHQ6IHsgc3RyZWFtLCB3YXJuaW5ncywgcmF3UmVzcG9uc2UsIHJlcXVlc3QgfSxcbiAgICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgICAgc3RhcnRUaW1lc3RhbXBNc1xuICAgICAgICB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLnN0cmVhbU9iamVjdC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5zdHJlYW1PYmplY3QuZG9TdHJlYW1cIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gY2FsbE9wdGlvbnMuaW5wdXRGb3JtYXRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdHJpbmdpZnlGb3JUZWxlbWV0cnkoY2FsbE9wdGlvbnMucHJvbXB0KVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGUsXG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBzZXR0aW5ncy5tYXhUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IHNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogc2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICAgICAgICBmbjogYXN5bmMgKGRvU3RyZWFtU3BhbjIpID0+ICh7XG4gICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXM6IG5vdzIoKSxcbiAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuOiBkb1N0cmVhbVNwYW4yLFxuICAgICAgICAgICAgICByZXN1bHQ6IGF3YWl0IG1vZGVsLmRvU3RyZWFtKGNhbGxPcHRpb25zKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBzZWxmLnJlcXVlc3RQcm9taXNlLnJlc29sdmUocmVxdWVzdCAhPSBudWxsID8gcmVxdWVzdCA6IHt9KTtcbiAgICAgICAgbGV0IHVzYWdlO1xuICAgICAgICBsZXQgZmluaXNoUmVhc29uO1xuICAgICAgICBsZXQgcHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgbGV0IG9iamVjdDI7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgbGV0IGFjY3VtdWxhdGVkVGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCB0ZXh0RGVsdGEgPSBcIlwiO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQzKCksXG4gICAgICAgICAgdGltZXN0YW1wOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGxhdGVzdE9iamVjdEpzb24gPSB2b2lkIDA7XG4gICAgICAgIGxldCBsYXRlc3RPYmplY3QgPSB2b2lkIDA7XG4gICAgICAgIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICAgICAgICBsZXQgaXNGaXJzdERlbHRhID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRyYW5zZm9ybVN0cmVhbSh0cmFuc2Zvcm1lcikpLnBpcGVUaHJvdWdoKFxuICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHZhciBfYTE4LCBfYjIsIF9jO1xuICAgICAgICAgICAgICBpZiAoaXNGaXJzdENodW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNUb0ZpcnN0Q2h1bmsgPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgICAgIGlzRmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maXJzdENodW5rXCIsIHtcbiAgICAgICAgICAgICAgICAgIFwiYWkuc3RyZWFtLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgXCJhaS5zdHJlYW0ubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRUZXh0ICs9IGNodW5rO1xuICAgICAgICAgICAgICAgIHRleHREZWx0YSArPSBjaHVuaztcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlOiBjdXJyZW50T2JqZWN0SnNvbiwgc3RhdGU6IHBhcnNlU3RhdGUgfSA9IHBhcnNlUGFydGlhbEpzb24oYWNjdW11bGF0ZWRUZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE9iamVjdEpzb24gIT09IHZvaWQgMCAmJiAhaXNEZWVwRXF1YWxEYXRhKGxhdGVzdE9iamVjdEpzb24sIGN1cnJlbnRPYmplY3RKc29uKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlUGFydGlhbFJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50T2JqZWN0SnNvbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhLFxuICAgICAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3REZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgaXNGaW5hbERlbHRhOiBwYXJzZVN0YXRlID09PSBcInN1Y2Nlc3NmdWwtcGFyc2VcIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzICYmICFpc0RlZXBFcXVhbERhdGEoXG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC52YWx1ZS5wYXJ0aWFsXG4gICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdEpzb24gPSBjdXJyZW50T2JqZWN0SnNvbjtcbiAgICAgICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0ID0gdmFsaWRhdGlvblJlc3VsdC52YWx1ZS5wYXJ0aWFsO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBsYXRlc3RPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhOiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLnRleHREZWx0YVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdERlbHRhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAoX2ExOCA9IGNodW5rLmlkKSAhPSBudWxsID8gX2ExOCA6IHJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfYjIgPSBjaHVuay50aW1lc3RhbXApICE9IG51bGwgPyBfYjIgOiByZXNwb25zZS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfYyA9IGNodW5rLm1vZGVsSWQpICE9IG51bGwgPyBfYyA6IHJlc3BvbnNlLm1vZGVsSWRcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgICAgICBpZiAodGV4dERlbHRhICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1kZWx0YVwiLCB0ZXh0RGVsdGEgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb24gPSBjaHVuay5maW5pc2hSZWFzb247XG4gICAgICAgICAgICAgICAgICB1c2FnZSA9IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZShjaHVuay51c2FnZSk7XG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhID0gY2h1bmsucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IC4uLmNodW5rLCB1c2FnZSwgcmVzcG9uc2UgfSk7XG4gICAgICAgICAgICAgICAgICBzZWxmLnVzYWdlUHJvbWlzZS5yZXNvbHZlKHVzYWdlKTtcbiAgICAgICAgICAgICAgICAgIHNlbGYucHJvdmlkZXJNZXRhZGF0YVByb21pc2UucmVzb2x2ZShwcm92aWRlck1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgIHNlbGYucmVzcG9uc2VQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmF3UmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJhd1Jlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlRmluYWxSZXN1bHQoXG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdEpzb24sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBhY2N1bXVsYXRlZFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgdXNhZ2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0MiA9IHZhbGlkYXRpb25SZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub2JqZWN0UHJvbWlzZS5yZXNvbHZlKG9iamVjdDIpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiByZXNwb25zZSBkaWQgbm90IG1hdGNoIHNjaGVtYS5cIixcbiAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogdmFsaWRhdGlvblJlc3VsdC5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBhY2N1bXVsYXRlZFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9iamVjdFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gaW52b2tlIG9uRmluaXNoIGNhbGxiYWNrIGFuZCByZXNvbHZlIHRvb2xSZXN1bHRzIHByb21pc2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGFib3V0IHRvIGNsb3NlOlxuICAgICAgICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsVXNhZ2UgPSB1c2FnZSAhPSBudWxsID8gdXNhZ2UgOiB7XG4gICAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IE5hTixcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IE5hTixcbiAgICAgICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBOYU5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG9iamVjdDIpXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiByZXNwb25zZS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiBmaW5hbFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogZmluYWxVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiByZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiBmaW5hbFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI6IGZpbmFsVXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJvb3RTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogZmluYWxVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGZpbmFsVXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG9iamVjdDIpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYXdhaXQgKG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7XG4gICAgICAgICAgICAgICAgICB1c2FnZTogZmluYWxVc2FnZSxcbiAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0MixcbiAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgd2FybmluZ3MsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3I6IGVycm9yMiB9KTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByb290U3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHN0aXRjaGFibGVTdHJlYW0uYWRkU3RyZWFtKHRyYW5zZm9ybWVkU3RyZWFtKTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgIHN0aXRjaGFibGVTdHJlYW0uYWRkU3RyZWFtKFxuICAgICAgICBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHN0aXRjaGFibGVTdHJlYW0uY2xvc2UoKTtcbiAgICB9KTtcbiAgICB0aGlzLm91dHB1dFN0cmF0ZWd5ID0gb3V0cHV0U3RyYXRlZ3k7XG4gIH1cbiAgZ2V0IG9iamVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3RQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCB1c2FnZSgpIHtcbiAgICByZXR1cm4gdGhpcy51c2FnZVByb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyTWV0YWRhdGFQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCBwcm92aWRlck1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyTWV0YWRhdGFQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCB3YXJuaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy53YXJuaW5nc1Byb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdFByb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHJlc3BvbnNlKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlUHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgcGFydGlhbE9iamVjdFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMuYmFzZVN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5vYmplY3QpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgZ2V0IGVsZW1lbnRTdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0U3RyYXRlZ3kuY3JlYXRlRWxlbWVudFN0cmVhbSh0aGlzLmJhc2VTdHJlYW0pO1xuICB9XG4gIGdldCB0ZXh0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKFxuICAgICAgdGhpcy5iYXNlU3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBnZXQgZnVsbFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLmJhc2VTdHJlYW0pO1xuICB9XG4gIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gICAgICByZXNwb25zZSxcbiAgICAgIHN0YXR1czogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlT3V0Z29pbmdIdHRwSGVhZGVycyhpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnMsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KSxcbiAgICAgIHN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKVxuICAgIH0pO1xuICB9XG4gIHRvVGV4dFN0cmVhbVJlc3BvbnNlKGluaXQpIHtcbiAgICB2YXIgX2ExNztcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSksIHtcbiAgICAgIHN0YXR1czogKF9hMTcgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTcgOiAyMDAsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycywge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZS10ZXh0LnRzXG5pbXBvcnQgeyBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBlcnJvcnMvbm8tb3V0cHV0LXNwZWNpZmllZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yOSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTkgPSBcIkFJX05vT3V0cHV0U3BlY2lmaWVkRXJyb3JcIjtcbnZhciBtYXJrZXI5ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU5fWA7XG52YXIgc3ltYm9sOSA9IFN5bWJvbC5mb3IobWFya2VyOSk7XG52YXIgX2E5O1xudmFyIE5vT3V0cHV0U3BlY2lmaWVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I5IHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSA9IFwiTm8gb3V0cHV0IHNwZWNpZmllZC5cIiB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU5LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E5XSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjkuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI5KTtcbiAgfVxufTtcbl9hOSA9IHN5bWJvbDk7XG5cbi8vIGVycm9ycy90b29sLWV4ZWN1dGlvbi1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTAsIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2UyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTAgPSBcIkFJX1Rvb2xFeGVjdXRpb25FcnJvclwiO1xudmFyIG1hcmtlcjEwID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMH1gO1xudmFyIHN5bWJvbDEwID0gU3ltYm9sLmZvcihtYXJrZXIxMCk7XG52YXIgX2ExMDtcbnZhciBUb29sRXhlY3V0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxMCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0b29sQXJncyxcbiAgICB0b29sTmFtZSxcbiAgICB0b29sQ2FsbElkLFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgRXJyb3IgZXhlY3V0aW5nIHRvb2wgJHt0b29sTmFtZX06ICR7Z2V0RXJyb3JNZXNzYWdlMihjYXVzZSl9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTAsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2ExMF0gPSB0cnVlO1xuICAgIHRoaXMudG9vbEFyZ3MgPSB0b29sQXJncztcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gICAgdGhpcy50b29sQ2FsbElkID0gdG9vbENhbGxJZDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTAuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMCk7XG4gIH1cbn07XG5fYTEwID0gc3ltYm9sMTA7XG5cbi8vIGNvcmUvcHJvbXB0L3ByZXBhcmUtdG9vbHMtYW5kLXRvb2wtY2hvaWNlLnRzXG5pbXBvcnQgeyBhc1NjaGVtYSBhcyBhc1NjaGVtYTIgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyBjb3JlL3V0aWwvaXMtbm9uLWVtcHR5LW9iamVjdC50c1xuZnVuY3Rpb24gaXNOb25FbXB0eU9iamVjdChvYmplY3QyKSB7XG4gIHJldHVybiBvYmplY3QyICE9IG51bGwgJiYgT2JqZWN0LmtleXMob2JqZWN0MikubGVuZ3RoID4gMDtcbn1cblxuLy8gY29yZS9wcm9tcHQvcHJlcGFyZS10b29scy1hbmQtdG9vbC1jaG9pY2UudHNcbmZ1bmN0aW9uIHByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2Uoe1xuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgYWN0aXZlVG9vbHNcbn0pIHtcbiAgaWYgKCFpc05vbkVtcHR5T2JqZWN0KHRvb2xzKSkge1xuICAgIHJldHVybiB7XG4gICAgICB0b29sczogdm9pZCAwLFxuICAgICAgdG9vbENob2ljZTogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBjb25zdCBmaWx0ZXJlZFRvb2xzID0gYWN0aXZlVG9vbHMgIT0gbnVsbCA/IE9iamVjdC5lbnRyaWVzKHRvb2xzKS5maWx0ZXIoXG4gICAgKFtuYW1lMTddKSA9PiBhY3RpdmVUb29scy5pbmNsdWRlcyhuYW1lMTcpXG4gICkgOiBPYmplY3QuZW50cmllcyh0b29scyk7XG4gIHJldHVybiB7XG4gICAgdG9vbHM6IGZpbHRlcmVkVG9vbHMubWFwKChbbmFtZTE3LCB0b29sMl0pID0+IHtcbiAgICAgIGNvbnN0IHRvb2xUeXBlID0gdG9vbDIudHlwZTtcbiAgICAgIHN3aXRjaCAodG9vbFR5cGUpIHtcbiAgICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICBuYW1lOiBuYW1lMTcsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbDIuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBhc1NjaGVtYTIodG9vbDIucGFyYW1ldGVycykuanNvblNjaGVtYVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJwcm92aWRlci1kZWZpbmVkXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwicHJvdmlkZXItZGVmaW5lZFwiLFxuICAgICAgICAgICAgbmFtZTogbmFtZTE3LFxuICAgICAgICAgICAgaWQ6IHRvb2wyLmlkLFxuICAgICAgICAgICAgYXJnczogdG9vbDIuYXJnc1xuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSB0b29sVHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHRvb2wgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0b29sQ2hvaWNlOiB0b29sQ2hvaWNlID09IG51bGwgPyB7IHR5cGU6IFwiYXV0b1wiIH0gOiB0eXBlb2YgdG9vbENob2ljZSA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogdG9vbENob2ljZSB9IDogeyB0eXBlOiBcInRvb2xcIiwgdG9vbE5hbWU6IHRvb2xDaG9pY2UudG9vbE5hbWUgfVxuICB9O1xufVxuXG4vLyBjb3JlL3V0aWwvc3BsaXQtb24tbGFzdC13aGl0ZXNwYWNlLnRzXG52YXIgbGFzdFdoaXRlc3BhY2VSZWdleHAgPSAvXihbXFxzXFxTXSo/KShcXHMrKShcXFMqKSQvO1xuZnVuY3Rpb24gc3BsaXRPbkxhc3RXaGl0ZXNwYWNlKHRleHQyKSB7XG4gIGNvbnN0IG1hdGNoID0gdGV4dDIubWF0Y2gobGFzdFdoaXRlc3BhY2VSZWdleHApO1xuICByZXR1cm4gbWF0Y2ggPyB7IHByZWZpeDogbWF0Y2hbMV0sIHdoaXRlc3BhY2U6IG1hdGNoWzJdLCBzdWZmaXg6IG1hdGNoWzNdIH0gOiB2b2lkIDA7XG59XG5cbi8vIGNvcmUvdXRpbC9yZW1vdmUtdGV4dC1hZnRlci1sYXN0LXdoaXRlc3BhY2UudHNcbmZ1bmN0aW9uIHJlbW92ZVRleHRBZnRlckxhc3RXaGl0ZXNwYWNlKHRleHQyKSB7XG4gIGNvbnN0IG1hdGNoID0gc3BsaXRPbkxhc3RXaGl0ZXNwYWNlKHRleHQyKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2gucHJlZml4ICsgbWF0Y2gud2hpdGVzcGFjZSA6IHRleHQyO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvcGFyc2UtdG9vbC1jYWxsLnRzXG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIGFzIHNhZmVQYXJzZUpTT04yLCBzYWZlVmFsaWRhdGVUeXBlcyBhcyBzYWZlVmFsaWRhdGVUeXBlczMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHsgYXNTY2hlbWEgYXMgYXNTY2hlbWEzIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcblxuLy8gZXJyb3JzL2ludmFsaWQtdG9vbC1hcmd1bWVudHMtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjExLCBnZXRFcnJvck1lc3NhZ2UgYXMgZ2V0RXJyb3JNZXNzYWdlMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTExID0gXCJBSV9JbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yXCI7XG52YXIgbWFya2VyMTEgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTExfWA7XG52YXIgc3ltYm9sMTEgPSBTeW1ib2wuZm9yKG1hcmtlcjExKTtcbnZhciBfYTExO1xudmFyIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxMSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0b29sQXJncyxcbiAgICB0b29sTmFtZSxcbiAgICBjYXVzZSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgYXJndW1lbnRzIGZvciB0b29sICR7dG9vbE5hbWV9OiAke2dldEVycm9yTWVzc2FnZTMoXG4gICAgICBjYXVzZVxuICAgICl9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTEsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2ExMV0gPSB0cnVlO1xuICAgIHRoaXMudG9vbEFyZ3MgPSB0b29sQXJncztcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjExLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTEpO1xuICB9XG59O1xuX2ExMSA9IHN5bWJvbDExO1xuXG4vLyBlcnJvcnMvbm8tc3VjaC10b29sLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTEyID0gXCJBSV9Ob1N1Y2hUb29sRXJyb3JcIjtcbnZhciBtYXJrZXIxMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTJ9YDtcbnZhciBzeW1ib2wxMiA9IFN5bWJvbC5mb3IobWFya2VyMTIpO1xudmFyIF9hMTI7XG52YXIgTm9TdWNoVG9vbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTIge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbE5hbWUsXG4gICAgYXZhaWxhYmxlVG9vbHMgPSB2b2lkIDAsXG4gICAgbWVzc2FnZSA9IGBNb2RlbCB0cmllZCB0byBjYWxsIHVuYXZhaWxhYmxlIHRvb2wgJyR7dG9vbE5hbWV9Jy4gJHthdmFpbGFibGVUb29scyA9PT0gdm9pZCAwID8gXCJObyB0b29scyBhcmUgYXZhaWxhYmxlLlwiIDogYEF2YWlsYWJsZSB0b29sczogJHthdmFpbGFibGVUb29scy5qb2luKFwiLCBcIil9LmB9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTIsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTEyXSA9IHRydWU7XG4gICAgdGhpcy50b29sTmFtZSA9IHRvb2xOYW1lO1xuICAgIHRoaXMuYXZhaWxhYmxlVG9vbHMgPSBhdmFpbGFibGVUb29scztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTIuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMik7XG4gIH1cbn07XG5fYTEyID0gc3ltYm9sMTI7XG5cbi8vIGVycm9ycy90b29sLWNhbGwtcmVwYWlyLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMywgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxMyA9IFwiQUlfVG9vbENhbGxSZXBhaXJFcnJvclwiO1xudmFyIG1hcmtlcjEzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxM31gO1xudmFyIHN5bWJvbDEzID0gU3ltYm9sLmZvcihtYXJrZXIxMyk7XG52YXIgX2ExMztcbnZhciBUb29sQ2FsbFJlcGFpckVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY2F1c2UsXG4gICAgb3JpZ2luYWxFcnJvcixcbiAgICBtZXNzYWdlID0gYEVycm9yIHJlcGFpcmluZyB0b29sIGNhbGw6ICR7Z2V0RXJyb3JNZXNzYWdlNChjYXVzZSl9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTMsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2ExM10gPSB0cnVlO1xuICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjEzLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTMpO1xuICB9XG59O1xuX2ExMyA9IHN5bWJvbDEzO1xuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvcGFyc2UtdG9vbC1jYWxsLnRzXG5hc3luYyBmdW5jdGlvbiBwYXJzZVRvb2xDYWxsKHtcbiAgdG9vbENhbGwsXG4gIHRvb2xzLFxuICByZXBhaXJUb29sQ2FsbCxcbiAgc3lzdGVtLFxuICBtZXNzYWdlc1xufSkge1xuICBpZiAodG9vbHMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3IoeyB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUgfSk7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZG9QYXJzZVRvb2xDYWxsKHsgdG9vbENhbGwsIHRvb2xzIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChyZXBhaXJUb29sQ2FsbCA9PSBudWxsIHx8ICEoTm9TdWNoVG9vbEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpIHx8IEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgbGV0IHJlcGFpcmVkVG9vbENhbGwgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICByZXBhaXJlZFRvb2xDYWxsID0gYXdhaXQgcmVwYWlyVG9vbENhbGwoe1xuICAgICAgICB0b29sQ2FsbCxcbiAgICAgICAgdG9vbHMsXG4gICAgICAgIHBhcmFtZXRlclNjaGVtYTogKHsgdG9vbE5hbWUgfSkgPT4gYXNTY2hlbWEzKHRvb2xzW3Rvb2xOYW1lXS5wYXJhbWV0ZXJzKS5qc29uU2NoZW1hLFxuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICBlcnJvclxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAocmVwYWlyRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBUb29sQ2FsbFJlcGFpckVycm9yKHtcbiAgICAgICAgY2F1c2U6IHJlcGFpckVycm9yLFxuICAgICAgICBvcmlnaW5hbEVycm9yOiBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChyZXBhaXJlZFRvb2xDYWxsID09IG51bGwpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgZG9QYXJzZVRvb2xDYWxsKHsgdG9vbENhbGw6IHJlcGFpcmVkVG9vbENhbGwsIHRvb2xzIH0pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb1BhcnNlVG9vbENhbGwoe1xuICB0b29sQ2FsbCxcbiAgdG9vbHNcbn0pIHtcbiAgY29uc3QgdG9vbE5hbWUgPSB0b29sQ2FsbC50b29sTmFtZTtcbiAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gIGlmICh0b29sMiA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7XG4gICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICBhdmFpbGFibGVUb29sczogT2JqZWN0LmtleXModG9vbHMpXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2NoZW1hID0gYXNTY2hlbWEzKHRvb2wyLnBhcmFtZXRlcnMpO1xuICBjb25zdCBwYXJzZVJlc3VsdCA9IHRvb2xDYWxsLmFyZ3MudHJpbSgpID09PSBcIlwiID8gc2FmZVZhbGlkYXRlVHlwZXMzKHsgdmFsdWU6IHt9LCBzY2hlbWEgfSkgOiBzYWZlUGFyc2VKU09OMih7IHRleHQ6IHRvb2xDYWxsLmFyZ3MsIHNjaGVtYSB9KTtcbiAgaWYgKHBhcnNlUmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUb29sQXJndW1lbnRzRXJyb3Ioe1xuICAgICAgdG9vbE5hbWUsXG4gICAgICB0b29sQXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgIHRvb2xOYW1lLFxuICAgIGFyZ3M6IHBhcnNlUmVzdWx0LnZhbHVlXG4gIH07XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9yZWFzb25pbmctZGV0YWlsLnRzXG5mdW5jdGlvbiBhc1JlYXNvbmluZ1RleHQocmVhc29uaW5nKSB7XG4gIGNvbnN0IHJlYXNvbmluZ1RleHQgPSByZWFzb25pbmcuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidGV4dFwiKS5tYXAoKHBhcnQpID0+IHBhcnQudGV4dCkuam9pbihcIlwiKTtcbiAgcmV0dXJuIHJlYXNvbmluZ1RleHQubGVuZ3RoID4gMCA/IHJlYXNvbmluZ1RleHQgOiB2b2lkIDA7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC90by1yZXNwb25zZS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gdG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgdGV4dDogdGV4dDIgPSBcIlwiLFxuICBmaWxlcyxcbiAgcmVhc29uaW5nLFxuICB0b29scyxcbiAgdG9vbENhbGxzLFxuICB0b29sUmVzdWx0cyxcbiAgbWVzc2FnZUlkLFxuICBnZW5lcmF0ZU1lc3NhZ2VJZFxufSkge1xuICBjb25zdCByZXNwb25zZU1lc3NhZ2VzID0gW107XG4gIGNvbnN0IGNvbnRlbnQgPSBbXTtcbiAgaWYgKHJlYXNvbmluZy5sZW5ndGggPiAwKSB7XG4gICAgY29udGVudC5wdXNoKFxuICAgICAgLi4ucmVhc29uaW5nLm1hcChcbiAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIgPyB7IC4uLnBhcnQsIHR5cGU6IFwicmVhc29uaW5nXCIgfSA6IHsgLi4ucGFydCwgdHlwZTogXCJyZWRhY3RlZC1yZWFzb25pbmdcIiB9XG4gICAgICApXG4gICAgKTtcbiAgfVxuICBpZiAoZmlsZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnRlbnQucHVzaChcbiAgICAgIC4uLmZpbGVzLm1hcCgoZmlsZSkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIGRhdGE6IGZpbGUuYmFzZTY0LFxuICAgICAgICBtaW1lVHlwZTogZmlsZS5taW1lVHlwZVxuICAgICAgfSkpXG4gICAgKTtcbiAgfVxuICBpZiAodGV4dDIubGVuZ3RoID4gMCkge1xuICAgIGNvbnRlbnQucHVzaCh7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiB0ZXh0MiB9KTtcbiAgfVxuICBpZiAodG9vbENhbGxzLmxlbmd0aCA+IDApIHtcbiAgICBjb250ZW50LnB1c2goLi4udG9vbENhbGxzKTtcbiAgfVxuICBpZiAoY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICBjb250ZW50LFxuICAgICAgaWQ6IG1lc3NhZ2VJZFxuICAgIH0pO1xuICB9XG4gIGlmICh0b29sUmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgaWQ6IGdlbmVyYXRlTWVzc2FnZUlkKCksXG4gICAgICBjb250ZW50OiB0b29sUmVzdWx0cy5tYXAoKHRvb2xSZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sUmVzdWx0LnRvb2xOYW1lXTtcbiAgICAgICAgcmV0dXJuICh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQpICE9IG51bGwgPyB7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xSZXN1bHQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogdG9vbFJlc3VsdC50b29sTmFtZSxcbiAgICAgICAgICByZXN1bHQ6IHRvb2wyLmV4cGVyaW1lbnRhbF90b1Rvb2xSZXN1bHRDb250ZW50KHRvb2xSZXN1bHQucmVzdWx0KSxcbiAgICAgICAgICBleHBlcmltZW50YWxfY29udGVudDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQoXG4gICAgICAgICAgICB0b29sUmVzdWx0LnJlc3VsdFxuICAgICAgICAgIClcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgdG9vbENhbGxJZDogdG9vbFJlc3VsdC50b29sQ2FsbElkLFxuICAgICAgICAgIHRvb2xOYW1lOiB0b29sUmVzdWx0LnRvb2xOYW1lLFxuICAgICAgICAgIHJlc3VsdDogdG9vbFJlc3VsdC5yZXN1bHRcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZXM7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZS10ZXh0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkMyA9IGNyZWF0ZUlkR2VuZXJhdG9yMyh7XG4gIHByZWZpeDogXCJhaXR4dFwiLFxuICBzaXplOiAyNFxufSk7XG52YXIgb3JpZ2luYWxHZW5lcmF0ZU1lc3NhZ2VJZCA9IGNyZWF0ZUlkR2VuZXJhdG9yMyh7XG4gIHByZWZpeDogXCJtc2dcIixcbiAgc2l6ZTogMjRcbn0pO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUZXh0KHtcbiAgbW9kZWwsXG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBtYXhTdGVwcyA9IDEsXG4gIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZU1lc3NhZ2VJZDogZ2VuZXJhdGVNZXNzYWdlSWQgPSBvcmlnaW5hbEdlbmVyYXRlTWVzc2FnZUlkLFxuICBleHBlcmltZW50YWxfb3V0cHV0OiBvdXRwdXQsXG4gIGV4cGVyaW1lbnRhbF9jb250aW51ZVN0ZXBzOiBjb250aW51ZVN0ZXBzID0gZmFsc2UsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gIHByb3ZpZGVyT3B0aW9ucyA9IGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICBleHBlcmltZW50YWxfYWN0aXZlVG9vbHM6IGFjdGl2ZVRvb2xzLFxuICBleHBlcmltZW50YWxfcHJlcGFyZVN0ZXA6IHByZXBhcmVTdGVwLFxuICBleHBlcmltZW50YWxfcmVwYWlyVG9vbENhbGw6IHJlcGFpclRvb2xDYWxsLFxuICBfaW50ZXJuYWw6IHtcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZDMsXG4gICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICB9ID0ge30sXG4gIG9uU3RlcEZpbmlzaCxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgdmFyIF9hMTc7XG4gIGlmIChtYXhTdGVwcyA8IDEpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgcGFyYW1ldGVyOiBcIm1heFN0ZXBzXCIsXG4gICAgICB2YWx1ZTogbWF4U3RlcHMsXG4gICAgICBtZXNzYWdlOiBcIm1heFN0ZXBzIG11c3QgYmUgYXQgbGVhc3QgMVwiXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoeyBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnIH0pO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyAuLi5zZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCBpbml0aWFsUHJvbXB0ID0gc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgIHByb21wdDoge1xuICAgICAgc3lzdGVtOiAoX2ExNyA9IG91dHB1dCA9PSBudWxsID8gdm9pZCAwIDogb3V0cHV0LmluamVjdEludG9TeXN0ZW1Qcm9tcHQoeyBzeXN0ZW0sIG1vZGVsIH0pKSAhPSBudWxsID8gX2ExNyA6IHN5c3RlbSxcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2VzXG4gICAgfSxcbiAgICB0b29sc1xuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLmdlbmVyYXRlVGV4dFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlVGV4dFwiLFxuICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIC8vIG1vZGVsOlxuICAgICAgICBcImFpLm1vZGVsLnByb3ZpZGVyXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBcImFpLm1vZGVsLmlkXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICB9LFxuICAgICAgICBcImFpLnNldHRpbmdzLm1heFN0ZXBzXCI6IG1heFN0ZXBzXG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgdmFyIF9hMTgsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2osIF9rLCBfbCwgX20sIF9uO1xuICAgICAgY29uc3QgY2FsbFNldHRpbmdzID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICBsZXQgY3VycmVudE1vZGVsUmVzcG9uc2U7XG4gICAgICBsZXQgY3VycmVudFRvb2xDYWxscyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnRUb29sUmVzdWx0cyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnRSZWFzb25pbmdEZXRhaWxzID0gW107XG4gICAgICBsZXQgc3RlcENvdW50ID0gMDtcbiAgICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZXMgPSBbXTtcbiAgICAgIGxldCB0ZXh0MiA9IFwiXCI7XG4gICAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgICBjb25zdCBzdGVwcyA9IFtdO1xuICAgICAgbGV0IHVzYWdlID0ge1xuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiAwLFxuICAgICAgICBwcm9tcHRUb2tlbnM6IDAsXG4gICAgICAgIHRvdGFsVG9rZW5zOiAwXG4gICAgICB9O1xuICAgICAgbGV0IHN0ZXBUeXBlID0gXCJpbml0aWFsXCI7XG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IHByb21wdEZvcm1hdCA9IHN0ZXBDb3VudCA9PT0gMCA/IGluaXRpYWxQcm9tcHQudHlwZSA6IFwibWVzc2FnZXNcIjtcbiAgICAgICAgY29uc3Qgc3RlcElucHV0TWVzc2FnZXMgPSBbXG4gICAgICAgICAgLi4uaW5pdGlhbFByb21wdC5tZXNzYWdlcyxcbiAgICAgICAgICAuLi5yZXNwb25zZU1lc3NhZ2VzXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHByZXBhcmVTdGVwUmVzdWx0ID0gYXdhaXQgKHByZXBhcmVTdGVwID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcCh7XG4gICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgc3RlcHMsXG4gICAgICAgICAgbWF4U3RlcHMsXG4gICAgICAgICAgc3RlcE51bWJlcjogc3RlcENvdW50XG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3Qgc3RlcFRvb2xDaG9pY2UgPSAoX2ExOCA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC50b29sQ2hvaWNlKSAhPSBudWxsID8gX2ExOCA6IHRvb2xDaG9pY2U7XG4gICAgICAgIGNvbnN0IHN0ZXBBY3RpdmVUb29scyA9IChfYiA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5leHBlcmltZW50YWxfYWN0aXZlVG9vbHMpICE9IG51bGwgPyBfYiA6IGFjdGl2ZVRvb2xzO1xuICAgICAgICBjb25zdCBzdGVwTW9kZWwgPSAoX2MgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQubW9kZWwpICE9IG51bGwgPyBfYyA6IG1vZGVsO1xuICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgIHByb21wdDoge1xuICAgICAgICAgICAgdHlwZTogcHJvbXB0Rm9ybWF0LFxuICAgICAgICAgICAgc3lzdGVtOiBpbml0aWFsUHJvbXB0LnN5c3RlbSxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogc3RlcE1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IChfZCA9IHN0ZXBNb2RlbC5zdXBwb3J0c1VybCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmJpbmQoc3RlcE1vZGVsKVxuICAgICAgICAgIC8vIHN1cHBvcnQgJ3RoaXMnIGNvbnRleHRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1vZGUgPSB7XG4gICAgICAgICAgdHlwZTogXCJyZWd1bGFyXCIsXG4gICAgICAgICAgLi4ucHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7XG4gICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgIHRvb2xDaG9pY2U6IHN0ZXBUb29sQ2hvaWNlLFxuICAgICAgICAgICAgYWN0aXZlVG9vbHM6IHN0ZXBBY3RpdmVUb29sc1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICAgIGN1cnJlbnRNb2RlbFJlc3BvbnNlID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmdlbmVyYXRlVGV4dC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlVGV4dC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAvLyBtb2RlbDpcbiAgICAgICAgICAgICAgICBcImFpLm1vZGVsLnByb3ZpZGVyXCI6IHN0ZXBNb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICBcImFpLm1vZGVsLmlkXCI6IHN0ZXBNb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgIC8vIHByb21wdDpcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC5mb3JtYXRcIjogeyBpbnB1dDogKCkgPT4gcHJvbXB0Rm9ybWF0IH0sXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0cmluZ2lmeUZvclRlbGVtZXRyeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xzXCI6IHtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIGxhbmd1YWdlIG1vZGVsIGxldmVsIHRvb2xzOlxuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hMTk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2ExOSA9IG1vZGUudG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTE5Lm1hcCgodG9vbDIpID0+IEpTT04uc3RyaW5naWZ5KHRvb2wyKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sQ2hvaWNlXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBtb2RlLnRvb2xDaG9pY2UgIT0gbnVsbCA/IEpTT04uc3RyaW5naWZ5KG1vZGUudG9vbENob2ljZSkgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogc3RlcE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogc3RlcE1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBzZXR0aW5ncy5tYXhUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IHNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnN0b3Bfc2VxdWVuY2VzXCI6IHNldHRpbmdzLnN0b3BTZXF1ZW5jZXMsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBzZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IHNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChzcGFuMikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExOSwgX2IyLCBfYzIsIF9kMiwgX2UyLCBfZjI7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0ZXBNb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgICAgIC4uLmNhbGxTZXR0aW5ncyxcbiAgICAgICAgICAgICAgICBpbnB1dEZvcm1hdDogcHJvbXB0Rm9ybWF0LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlRm9ybWF0OiBvdXRwdXQgPT0gbnVsbCA/IHZvaWQgMCA6IG91dHB1dC5yZXNwb25zZUZvcm1hdCh7IG1vZGVsIH0pLFxuICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpZDogKF9iMiA9IChfYTE5ID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOS5pZCkgIT0gbnVsbCA/IF9iMiA6IGdlbmVyYXRlSWQzKCksXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2QyID0gKF9jMiA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi50aW1lc3RhbXApICE9IG51bGwgPyBfZDIgOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfZjIgPSAoX2UyID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2UyLm1vZGVsSWQpICE9IG51bGwgPyBfZjIgOiBzdGVwTW9kZWwubW9kZWxJZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiByZXN1bHQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gcmVzdWx0LnRleHRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocmVzdWx0LnRvb2xDYWxscylcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlRGF0YS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogcmVzdWx0LnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHJlc3VsdC51c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtyZXN1bHQuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHJlc3VsdC51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0LnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQsIHJlc3BvbnNlOiByZXNwb25zZURhdGEgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBjdXJyZW50VG9vbENhbGxzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgKChfZSA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnRvb2xDYWxscykgIT0gbnVsbCA/IF9lIDogW10pLm1hcChcbiAgICAgICAgICAgICh0b29sQ2FsbCkgPT4gcGFyc2VUb29sQ2FsbCh7XG4gICAgICAgICAgICAgIHRvb2xDYWxsLFxuICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgcmVwYWlyVG9vbENhbGwsXG4gICAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudFRvb2xSZXN1bHRzID0gdG9vbHMgPT0gbnVsbCA/IFtdIDogYXdhaXQgZXhlY3V0ZVRvb2xzKHtcbiAgICAgICAgICB0b29sQ2FsbHM6IGN1cnJlbnRUb29sQ2FsbHMsXG4gICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXMsXG4gICAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRVc2FnZSA9IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZShcbiAgICAgICAgICBjdXJyZW50TW9kZWxSZXNwb25zZS51c2FnZVxuICAgICAgICApO1xuICAgICAgICB1c2FnZSA9IGFkZExhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZSwgY3VycmVudFVzYWdlKTtcbiAgICAgICAgbGV0IG5leHRTdGVwVHlwZSA9IFwiZG9uZVwiO1xuICAgICAgICBpZiAoKytzdGVwQ291bnQgPCBtYXhTdGVwcykge1xuICAgICAgICAgIGlmIChjb250aW51ZVN0ZXBzICYmIGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbiA9PT0gXCJsZW5ndGhcIiAmJiAvLyBvbmx5IHVzZSBjb250aW51ZSB3aGVuIHRoZXJlIGFyZSBubyB0b29sIGNhbGxzOlxuICAgICAgICAgIGN1cnJlbnRUb29sQ2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBuZXh0U3RlcFR5cGUgPSBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIC8vIHRoZXJlIGFyZSB0b29sIGNhbGxzOlxuICAgICAgICAgICAgY3VycmVudFRvb2xDYWxscy5sZW5ndGggPiAwICYmIC8vIGFsbCBjdXJyZW50IHRvb2wgY2FsbHMgaGF2ZSByZXN1bHRzOlxuICAgICAgICAgICAgY3VycmVudFRvb2xSZXN1bHRzLmxlbmd0aCA9PT0gY3VycmVudFRvb2xDYWxscy5sZW5ndGhcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG5leHRTdGVwVHlwZSA9IFwidG9vbC1yZXN1bHRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxUZXh0ID0gKF9mID0gY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dCkgIT0gbnVsbCA/IF9mIDogXCJcIjtcbiAgICAgICAgY29uc3Qgc3RlcFRleHRMZWFkaW5nV2hpdGVzcGFjZVRyaW1tZWQgPSBzdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiICYmIC8vIG9ubHkgZm9yIGNvbnRpbnVlIHN0ZXBzXG4gICAgICAgIHRleHQyLnRyaW1FbmQoKSAhPT0gdGV4dDIgPyBvcmlnaW5hbFRleHQudHJpbVN0YXJ0KCkgOiBvcmlnaW5hbFRleHQ7XG4gICAgICAgIGNvbnN0IHN0ZXBUZXh0ID0gbmV4dFN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIgPyByZW1vdmVUZXh0QWZ0ZXJMYXN0V2hpdGVzcGFjZShzdGVwVGV4dExlYWRpbmdXaGl0ZXNwYWNlVHJpbW1lZCkgOiBzdGVwVGV4dExlYWRpbmdXaGl0ZXNwYWNlVHJpbW1lZDtcbiAgICAgICAgdGV4dDIgPSBuZXh0U3RlcFR5cGUgPT09IFwiY29udGludWVcIiB8fCBzdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiID8gdGV4dDIgKyBzdGVwVGV4dCA6IHN0ZXBUZXh0O1xuICAgICAgICBjdXJyZW50UmVhc29uaW5nRGV0YWlscyA9IGFzUmVhc29uaW5nRGV0YWlscyhcbiAgICAgICAgICBjdXJyZW50TW9kZWxSZXNwb25zZS5yZWFzb25pbmdcbiAgICAgICAgKTtcbiAgICAgICAgc291cmNlcy5wdXNoKC4uLihfZyA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnNvdXJjZXMpICE9IG51bGwgPyBfZyA6IFtdKTtcbiAgICAgICAgaWYgKHN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IHJlc3BvbnNlTWVzc2FnZXNbcmVzcG9uc2VNZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAodHlwZW9mIGxhc3RNZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlLmNvbnRlbnQgKz0gc3RlcFRleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlLmNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHN0ZXBUZXh0LFxuICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaChcbiAgICAgICAgICAgIC4uLnRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gICAgICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgICAgICBmaWxlczogYXNGaWxlcyhjdXJyZW50TW9kZWxSZXNwb25zZS5maWxlcyksXG4gICAgICAgICAgICAgIHJlYXNvbmluZzogYXNSZWFzb25pbmdEZXRhaWxzKGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlYXNvbmluZyksXG4gICAgICAgICAgICAgIHRvb2xzOiB0b29scyAhPSBudWxsID8gdG9vbHMgOiB7fSxcbiAgICAgICAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICAgICAgICB0b29sUmVzdWx0czogY3VycmVudFRvb2xSZXN1bHRzLFxuICAgICAgICAgICAgICBtZXNzYWdlSWQ6IGdlbmVyYXRlTWVzc2FnZUlkKCksXG4gICAgICAgICAgICAgIGdlbmVyYXRlTWVzc2FnZUlkXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFN0ZXBSZXN1bHQgPSB7XG4gICAgICAgICAgc3RlcFR5cGUsXG4gICAgICAgICAgdGV4dDogc3RlcFRleHQsXG4gICAgICAgICAgLy8gVE9ETyB2NTogcmVuYW1lIHJlYXNvbmluZyB0byByZWFzb25pbmdUZXh0IChhbmQgdXNlIHJlYXNvbmluZyBmb3IgY29tcG9zaXRlIGFycmF5KVxuICAgICAgICAgIHJlYXNvbmluZzogYXNSZWFzb25pbmdUZXh0KGN1cnJlbnRSZWFzb25pbmdEZXRhaWxzKSxcbiAgICAgICAgICByZWFzb25pbmdEZXRhaWxzOiBjdXJyZW50UmVhc29uaW5nRGV0YWlscyxcbiAgICAgICAgICBmaWxlczogYXNGaWxlcyhjdXJyZW50TW9kZWxSZXNwb25zZS5maWxlcyksXG4gICAgICAgICAgc291cmNlczogKF9oID0gY3VycmVudE1vZGVsUmVzcG9uc2Uuc291cmNlcykgIT0gbnVsbCA/IF9oIDogW10sXG4gICAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHMsXG4gICAgICAgICAgZmluaXNoUmVhc29uOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24sXG4gICAgICAgICAgdXNhZ2U6IGN1cnJlbnRVc2FnZSxcbiAgICAgICAgICB3YXJuaW5nczogY3VycmVudE1vZGVsUmVzcG9uc2Uud2FybmluZ3MsXG4gICAgICAgICAgbG9ncHJvYnM6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmxvZ3Byb2JzLFxuICAgICAgICAgIHJlcXVlc3Q6IChfaSA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlcXVlc3QpICE9IG51bGwgPyBfaSA6IHt9LFxuICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAuLi5jdXJyZW50TW9kZWxSZXNwb25zZS5yZXNwb25zZSxcbiAgICAgICAgICAgIGhlYWRlcnM6IChfaiA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2ouaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IChfayA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2suYm9keSxcbiAgICAgICAgICAgIC8vIGRlZXAgY2xvbmUgbXNncyB0byBhdm9pZCBtdXRhdGluZyBwYXN0IG1lc3NhZ2VzIGluIG11bHRpLXN0ZXA6XG4gICAgICAgICAgICBtZXNzYWdlczogc3RydWN0dXJlZENsb25lKHJlc3BvbnNlTWVzc2FnZXMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjdXJyZW50TW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBjdXJyZW50TW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgIGlzQ29udGludWVkOiBuZXh0U3RlcFR5cGUgPT09IFwiY29udGludWVcIlxuICAgICAgICB9O1xuICAgICAgICBzdGVwcy5wdXNoKGN1cnJlbnRTdGVwUmVzdWx0KTtcbiAgICAgICAgYXdhaXQgKG9uU3RlcEZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25TdGVwRmluaXNoKGN1cnJlbnRTdGVwUmVzdWx0KSk7XG4gICAgICAgIHN0ZXBUeXBlID0gbmV4dFN0ZXBUeXBlO1xuICAgICAgfSB3aGlsZSAoc3RlcFR5cGUgIT09IFwiZG9uZVwiKTtcbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShjdXJyZW50TW9kZWxSZXNwb25zZS50b29sQ2FsbHMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0R2VuZXJhdGVUZXh0UmVzdWx0KHtcbiAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgIGZpbGVzOiBhc0ZpbGVzKGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbGVzKSxcbiAgICAgICAgcmVhc29uaW5nOiBhc1JlYXNvbmluZ1RleHQoY3VycmVudFJlYXNvbmluZ0RldGFpbHMpLFxuICAgICAgICByZWFzb25pbmdEZXRhaWxzOiBjdXJyZW50UmVhc29uaW5nRGV0YWlscyxcbiAgICAgICAgc291cmNlcyxcbiAgICAgICAgb3V0cHV0UmVzb2x2ZXI6ICgpID0+IHtcbiAgICAgICAgICBpZiAob3V0cHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb091dHB1dFNwZWNpZmllZEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvdXRwdXQucGFyc2VPdXRwdXQoXG4gICAgICAgICAgICB7IHRleHQ6IHRleHQyIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlOiBjdXJyZW50TW9kZWxSZXNwb25zZS5yZXNwb25zZSxcbiAgICAgICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICB0b29sUmVzdWx0czogY3VycmVudFRvb2xSZXN1bHRzLFxuICAgICAgICBmaW5pc2hSZWFzb246IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgdXNhZ2UsXG4gICAgICAgIHdhcm5pbmdzOiBjdXJyZW50TW9kZWxSZXNwb25zZS53YXJuaW5ncyxcbiAgICAgICAgcmVxdWVzdDogKF9sID0gY3VycmVudE1vZGVsUmVzcG9uc2UucmVxdWVzdCkgIT0gbnVsbCA/IF9sIDoge30sXG4gICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgLi4uY3VycmVudE1vZGVsUmVzcG9uc2UucmVzcG9uc2UsXG4gICAgICAgICAgaGVhZGVyczogKF9tID0gY3VycmVudE1vZGVsUmVzcG9uc2UucmF3UmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfbS5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IChfbiA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX24uYm9keSxcbiAgICAgICAgICBtZXNzYWdlczogcmVzcG9uc2VNZXNzYWdlc1xuICAgICAgICB9LFxuICAgICAgICBsb2dwcm9iczogY3VycmVudE1vZGVsUmVzcG9uc2UubG9ncHJvYnMsXG4gICAgICAgIHN0ZXBzLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjdXJyZW50TW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZVRvb2xzKHtcbiAgdG9vbENhbGxzLFxuICB0b29scyxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnksXG4gIG1lc3NhZ2VzLFxuICBhYm9ydFNpZ25hbFxufSkge1xuICBjb25zdCB0b29sUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHRvb2xDYWxscy5tYXAoYXN5bmMgKHsgdG9vbENhbGxJZCwgdG9vbE5hbWUsIGFyZ3MgfSkgPT4ge1xuICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gICAgICBpZiAoKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi5leGVjdXRlKSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWNvcmRTcGFuKHtcbiAgICAgICAgbmFtZTogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwubmFtZVwiOiB0b29sTmFtZSxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwuaWRcIjogdG9vbENhbGxJZCxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwuYXJnc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoYXJncylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICB0cmFjZXIsXG4gICAgICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgdG9vbDIuZXhlY3V0ZShhcmdzLCB7XG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwucmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHJlc3VsdDIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUb29sRXhlY3V0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgdG9vbEFyZ3M6IGFyZ3MsXG4gICAgICAgICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIHJlc3VsdFxuICAgICAgfTtcbiAgICB9KVxuICApO1xuICByZXR1cm4gdG9vbFJlc3VsdHMuZmlsdGVyKFxuICAgIChyZXN1bHQpID0+IHJlc3VsdCAhPSBudWxsXG4gICk7XG59XG52YXIgRGVmYXVsdEdlbmVyYXRlVGV4dFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudGV4dCA9IG9wdGlvbnMudGV4dDtcbiAgICB0aGlzLmZpbGVzID0gb3B0aW9ucy5maWxlcztcbiAgICB0aGlzLnJlYXNvbmluZyA9IG9wdGlvbnMucmVhc29uaW5nO1xuICAgIHRoaXMucmVhc29uaW5nRGV0YWlscyA9IG9wdGlvbnMucmVhc29uaW5nRGV0YWlscztcbiAgICB0aGlzLnRvb2xDYWxscyA9IG9wdGlvbnMudG9vbENhbGxzO1xuICAgIHRoaXMudG9vbFJlc3VsdHMgPSBvcHRpb25zLnRvb2xSZXN1bHRzO1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gb3B0aW9ucy5maW5pc2hSZWFzb247XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5yZXF1ZXN0ID0gb3B0aW9ucy5yZXF1ZXN0O1xuICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgIHRoaXMuc3RlcHMgPSBvcHRpb25zLnN0ZXBzO1xuICAgIHRoaXMuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgIHRoaXMubG9ncHJvYnMgPSBvcHRpb25zLmxvZ3Byb2JzO1xuICAgIHRoaXMub3V0cHV0UmVzb2x2ZXIgPSBvcHRpb25zLm91dHB1dFJlc29sdmVyO1xuICAgIHRoaXMuc291cmNlcyA9IG9wdGlvbnMuc291cmNlcztcbiAgfVxuICBnZXQgZXhwZXJpbWVudGFsX291dHB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRSZXNvbHZlcigpO1xuICB9XG59O1xuZnVuY3Rpb24gYXNSZWFzb25pbmdEZXRhaWxzKHJlYXNvbmluZykge1xuICBpZiAocmVhc29uaW5nID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKHR5cGVvZiByZWFzb25pbmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHJlYXNvbmluZyB9XTtcbiAgfVxuICByZXR1cm4gcmVhc29uaW5nO1xufVxuZnVuY3Rpb24gYXNGaWxlcyhmaWxlcykge1xuICB2YXIgX2ExNztcbiAgcmV0dXJuIChfYTE3ID0gZmlsZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGZpbGVzLm1hcCgoZmlsZSkgPT4gbmV3IERlZmF1bHRHZW5lcmF0ZWRGaWxlKGZpbGUpKSkgIT0gbnVsbCA/IF9hMTcgOiBbXTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L291dHB1dC50c1xudmFyIG91dHB1dF9leHBvcnRzID0ge307XG5fX2V4cG9ydChvdXRwdXRfZXhwb3J0cywge1xuICBvYmplY3Q6ICgpID0+IG9iamVjdCxcbiAgdGV4dDogKCkgPT4gdGV4dFxufSk7XG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIGFzIHNhZmVQYXJzZUpTT04zLCBzYWZlVmFsaWRhdGVUeXBlcyBhcyBzYWZlVmFsaWRhdGVUeXBlczQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHtcbiAgYXNTY2hlbWEgYXMgYXNTY2hlbWE0LFxuICBwYXJzZVBhcnRpYWxKc29uIGFzIHBhcnNlUGFydGlhbEpzb24yXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIGVycm9ycy9pbmRleC50c1xuaW1wb3J0IHtcbiAgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTYsXG4gIEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IyLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IgYXMgSW52YWxpZFByb21wdEVycm9yMixcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yLFxuICBKU09OUGFyc2VFcnJvciBhcyBKU09OUGFyc2VFcnJvcjIsXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjMsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yIGFzIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuXG4vLyBlcnJvcnMvaW52YWxpZC1zdHJlYW0tcGFydC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxNCA9IFwiQUlfSW52YWxpZFN0cmVhbVBhcnRFcnJvclwiO1xudmFyIG1hcmtlcjE0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxNH1gO1xudmFyIHN5bWJvbDE0ID0gU3ltYm9sLmZvcihtYXJrZXIxNCk7XG52YXIgX2ExNDtcbnZhciBJbnZhbGlkU3RyZWFtUGFydEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY2h1bmssXG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTQsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE0XSA9IHRydWU7XG4gICAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxNC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE0KTtcbiAgfVxufTtcbl9hMTQgPSBzeW1ib2wxNDtcblxuLy8gZXJyb3JzL21jcC1jbGllbnQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE1IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTUgPSBcIkFJX01DUENsaWVudEVycm9yXCI7XG52YXIgbWFya2VyMTUgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTE1fWA7XG52YXIgc3ltYm9sMTUgPSBTeW1ib2wuZm9yKG1hcmtlcjE1KTtcbnZhciBfYTE1O1xudmFyIE1DUENsaWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbmFtZTogbmFtZTE3ID0gXCJNQ1BDbGllbnRFcnJvclwiLFxuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTE3LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMTVdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTUuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNSk7XG4gIH1cbn07XG5fYTE1ID0gc3ltYm9sMTU7XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9vdXRwdXQudHNcbnZhciB0ZXh0ID0gKCkgPT4gKHtcbiAgdHlwZTogXCJ0ZXh0XCIsXG4gIHJlc3BvbnNlRm9ybWF0OiAoKSA9PiAoeyB0eXBlOiBcInRleHRcIiB9KSxcbiAgaW5qZWN0SW50b1N5c3RlbVByb21wdCh7IHN5c3RlbSB9KSB7XG4gICAgcmV0dXJuIHN5c3RlbTtcbiAgfSxcbiAgcGFyc2VQYXJ0aWFsKHsgdGV4dDogdGV4dDIgfSkge1xuICAgIHJldHVybiB7IHBhcnRpYWw6IHRleHQyIH07XG4gIH0sXG4gIHBhcnNlT3V0cHV0KHsgdGV4dDogdGV4dDIgfSkge1xuICAgIHJldHVybiB0ZXh0MjtcbiAgfVxufSk7XG52YXIgb2JqZWN0ID0gKHtcbiAgc2NoZW1hOiBpbnB1dFNjaGVtYVxufSkgPT4ge1xuICBjb25zdCBzY2hlbWEgPSBhc1NjaGVtYTQoaW5wdXRTY2hlbWEpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgcmVzcG9uc2VGb3JtYXQ6ICh7IG1vZGVsIH0pID0+ICh7XG4gICAgICB0eXBlOiBcImpzb25cIixcbiAgICAgIHNjaGVtYTogbW9kZWwuc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyA/IHNjaGVtYS5qc29uU2NoZW1hIDogdm9pZCAwXG4gICAgfSksXG4gICAgaW5qZWN0SW50b1N5c3RlbVByb21wdCh7IHN5c3RlbSwgbW9kZWwgfSkge1xuICAgICAgcmV0dXJuIG1vZGVsLnN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMgPyBzeXN0ZW0gOiBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBwcm9tcHQ6IHN5c3RlbSxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWEuanNvblNjaGVtYVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBwYXJzZVBhcnRpYWwoeyB0ZXh0OiB0ZXh0MiB9KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZVBhcnRpYWxKc29uMih0ZXh0Mik7XG4gICAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgICBjYXNlIFwiZmFpbGVkLXBhcnNlXCI6XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWQtaW5wdXRcIjpcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICBjYXNlIFwicmVwYWlyZWQtcGFyc2VcIjpcbiAgICAgICAgY2FzZSBcInN1Y2Nlc3NmdWwtcGFyc2VcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gTm90ZTogY3VycmVudGx5IG5vIHZhbGlkYXRpb24gb2YgcGFydGlhbCByZXN1bHRzOlxuICAgICAgICAgICAgcGFydGlhbDogcmVzdWx0LnZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSByZXN1bHQuc3RhdGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJzZSBzdGF0ZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwYXJzZU91dHB1dCh7IHRleHQ6IHRleHQyIH0sIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTjMoeyB0ZXh0OiB0ZXh0MiB9KTtcbiAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiBjb3VsZCBub3QgcGFyc2UgdGhlIHJlc3BvbnNlLlwiLFxuICAgICAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICByZXNwb25zZTogY29udGV4dC5yZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogY29udGV4dC51c2FnZSxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQuZmluaXNoUmVhc29uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzNCh7XG4gICAgICAgIHZhbHVlOiBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICAgICAgc2NoZW1hXG4gICAgICB9KTtcbiAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgICAgIGNhdXNlOiB2YWxpZGF0aW9uUmVzdWx0LmVycm9yLFxuICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgIHJlc3BvbnNlOiBjb250ZXh0LnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBjb250ZXh0LnVzYWdlLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dC5maW5pc2hSZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsaWRhdGlvblJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvc21vb3RoLXN0cmVhbS50c1xuaW1wb3J0IHsgZGVsYXkgYXMgb3JpZ2luYWxEZWxheSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciBhcyBJbnZhbGlkQXJndW1lbnRFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIENIVU5LSU5HX1JFR0VYUFMgPSB7XG4gIHdvcmQ6IC9cXFMrXFxzKy9tLFxuICBsaW5lOiAvXFxuKy9tXG59O1xuZnVuY3Rpb24gc21vb3RoU3RyZWFtKHtcbiAgZGVsYXlJbk1zID0gMTAsXG4gIGNodW5raW5nID0gXCJ3b3JkXCIsXG4gIF9pbnRlcm5hbDogeyBkZWxheTogZGVsYXkyID0gb3JpZ2luYWxEZWxheSB9ID0ge31cbn0gPSB7fSkge1xuICBsZXQgZGV0ZWN0Q2h1bms7XG4gIGlmICh0eXBlb2YgY2h1bmtpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGRldGVjdENodW5rID0gKGJ1ZmZlcikgPT4ge1xuICAgICAgY29uc3QgbWF0Y2ggPSBjaHVua2luZyhidWZmZXIpO1xuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIW1hdGNoLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENodW5raW5nIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgbm9uLWVtcHR5IHN0cmluZy5gKTtcbiAgICAgIH1cbiAgICAgIGlmICghYnVmZmVyLnN0YXJ0c1dpdGgobWF0Y2gpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ2h1bmtpbmcgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBtYXRjaCB0aGF0IGlzIGEgcHJlZml4IG9mIHRoZSBidWZmZXIuIFJlY2VpdmVkOiBcIiR7bWF0Y2h9XCIgZXhwZWN0ZWQgdG8gc3RhcnQgd2l0aCBcIiR7YnVmZmVyfVwiYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2h1bmtpbmdSZWdleCA9IHR5cGVvZiBjaHVua2luZyA9PT0gXCJzdHJpbmdcIiA/IENIVU5LSU5HX1JFR0VYUFNbY2h1bmtpbmddIDogY2h1bmtpbmc7XG4gICAgaWYgKGNodW5raW5nUmVnZXggPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yMih7XG4gICAgICAgIGFyZ3VtZW50OiBcImNodW5raW5nXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBDaHVua2luZyBtdXN0IGJlIFwid29yZFwiIG9yIFwibGluZVwiIG9yIGEgUmVnRXhwLiBSZWNlaXZlZDogJHtjaHVua2luZ31gXG4gICAgICB9KTtcbiAgICB9XG4gICAgZGV0ZWN0Q2h1bmsgPSAoYnVmZmVyKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaCA9IGNodW5raW5nUmVnZXguZXhlYyhidWZmZXIpO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgKG1hdGNoID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaFswXSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBidWZmZXIgPSBcIlwiO1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1kZWx0YVwiLCB0ZXh0RGVsdGE6IGJ1ZmZlciB9KTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlciArPSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IGRldGVjdENodW5rKGJ1ZmZlcikpICE9IG51bGwpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtZGVsdGFcIiwgdGV4dERlbHRhOiBtYXRjaCB9KTtcbiAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UobWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgICBhd2FpdCBkZWxheTIoZGVsYXlJbk1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvc3RyZWFtLXRleHQudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE3IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yNCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyBmb3JtYXREYXRhU3RyZWFtUGFydCBhcyBmb3JtYXREYXRhU3RyZWFtUGFydDIgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyB1dGlsL2FzLWFycmF5LnRzXG5mdW5jdGlvbiBhc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gW10gOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn1cblxuLy8gdXRpbC9jb25zdW1lLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gY29uc3VtZVN0cmVhbSh7XG4gIHN0cmVhbSxcbiAgb25FcnJvclxufSkge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIHRyeSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgb25FcnJvciA9PSBudWxsID8gdm9pZCAwIDogb25FcnJvcihlcnJvcik7XG4gIH0gZmluYWxseSB7XG4gICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gIH1cbn1cblxuLy8gY29yZS91dGlsL21lcmdlLXN0cmVhbXMudHNcbmZ1bmN0aW9uIG1lcmdlU3RyZWFtcyhzdHJlYW0xLCBzdHJlYW0yKSB7XG4gIGNvbnN0IHJlYWRlcjEgPSBzdHJlYW0xLmdldFJlYWRlcigpO1xuICBjb25zdCByZWFkZXIyID0gc3RyZWFtMi5nZXRSZWFkZXIoKTtcbiAgbGV0IGxhc3RSZWFkMSA9IHZvaWQgMDtcbiAgbGV0IGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgbGV0IHN0cmVhbTFEb25lID0gZmFsc2U7XG4gIGxldCBzdHJlYW0yRG9uZSA9IGZhbHNlO1xuICBhc3luYyBmdW5jdGlvbiByZWFkU3RyZWFtMShjb250cm9sbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChsYXN0UmVhZDEgPT0gbnVsbCkge1xuICAgICAgICBsYXN0UmVhZDEgPSByZWFkZXIxLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxhc3RSZWFkMTtcbiAgICAgIGxhc3RSZWFkMSA9IHZvaWQgMDtcbiAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZWFkU3RyZWFtMihjb250cm9sbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChsYXN0UmVhZDIgPT0gbnVsbCkge1xuICAgICAgICBsYXN0UmVhZDIgPSByZWFkZXIyLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxhc3RSZWFkMjtcbiAgICAgIGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdHJlYW0xRG9uZSkge1xuICAgICAgICAgIGF3YWl0IHJlYWRTdHJlYW0yKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtMkRvbmUpIHtcbiAgICAgICAgICBhd2FpdCByZWFkU3RyZWFtMShjb250cm9sbGVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RSZWFkMSA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdFJlYWQxID0gcmVhZGVyMS5yZWFkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RSZWFkMiA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdFJlYWQyID0gcmVhZGVyMi5yZWFkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyByZXN1bHQsIHJlYWRlciB9ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICBsYXN0UmVhZDEudGhlbigocmVzdWx0MikgPT4gKHsgcmVzdWx0OiByZXN1bHQyLCByZWFkZXI6IHJlYWRlcjEgfSkpLFxuICAgICAgICAgIGxhc3RSZWFkMi50aGVuKChyZXN1bHQyKSA9PiAoeyByZXN1bHQ6IHJlc3VsdDIsIHJlYWRlcjogcmVhZGVyMiB9KSlcbiAgICAgICAgXSk7XG4gICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhZGVyID09PSByZWFkZXIxKSB7XG4gICAgICAgICAgbGFzdFJlYWQxID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgYXdhaXQgcmVhZFN0cmVhbTIoY29udHJvbGxlcik7XG4gICAgICAgICAgICBzdHJlYW0xRG9uZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIHN0cmVhbTJEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGF3YWl0IHJlYWRTdHJlYW0xKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYW5jZWwoKSB7XG4gICAgICByZWFkZXIxLmNhbmNlbCgpO1xuICAgICAgcmVhZGVyMi5jYW5jZWwoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvcnVuLXRvb2xzLXRyYW5zZm9ybWF0aW9uLnRzXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmZ1bmN0aW9uIHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICB0b29scyxcbiAgZ2VuZXJhdG9yU3RyZWFtLFxuICB0b29sQ2FsbFN0cmVhbWluZyxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnksXG4gIHN5c3RlbSxcbiAgbWVzc2FnZXMsXG4gIGFib3J0U2lnbmFsLFxuICByZXBhaXJUb29sQ2FsbFxufSkge1xuICBsZXQgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyID0gbnVsbDtcbiAgY29uc3QgdG9vbFJlc3VsdHNTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgYWN0aXZlVG9vbENhbGxzID0ge307XG4gIGNvbnN0IG91dHN0YW5kaW5nVG9vbFJlc3VsdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgbGV0IGZpbmlzaENodW5rID0gdm9pZCAwO1xuICBmdW5jdGlvbiBhdHRlbXB0Q2xvc2UoKSB7XG4gICAgaWYgKGNhbkNsb3NlICYmIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgaWYgKGZpbmlzaENodW5rICE9IG51bGwpIHtcbiAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoZmluaXNoQ2h1bmspO1xuICAgICAgfVxuICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZvcndhcmRTdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rLnR5cGU7XG4gICAgICBzd2l0Y2ggKGNodW5rVHlwZSkge1xuICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6XG4gICAgICAgIGNhc2UgXCJyZWFzb25pbmctc2lnbmF0dXJlXCI6XG4gICAgICAgIGNhc2UgXCJyZWRhY3RlZC1yZWFzb25pbmdcIjpcbiAgICAgICAgY2FzZSBcInNvdXJjZVwiOlxuICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjpcbiAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICBuZXcgRGVmYXVsdEdlbmVyYXRlZEZpbGVXaXRoVHlwZSh7XG4gICAgICAgICAgICAgIGRhdGE6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICAgIG1pbWVUeXBlOiBjaHVuay5taW1lVHlwZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjoge1xuICAgICAgICAgIGlmICh0b29sQ2FsbFN0cmVhbWluZykge1xuICAgICAgICAgICAgaWYgKCFhY3RpdmVUb29sQ2FsbHNbY2h1bmsudG9vbENhbGxJZF0pIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYWN0aXZlVG9vbENhbGxzW2NodW5rLnRvb2xDYWxsSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsLWRlbHRhXCIsXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgYXJnc1RleHREZWx0YTogY2h1bmsuYXJnc1RleHREZWx0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbCA9IGF3YWl0IHBhcnNlVG9vbENhbGwoe1xuICAgICAgICAgICAgICB0b29sQ2FsbDogY2h1bmssXG4gICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICByZXBhaXJUb29sQ2FsbCxcbiAgICAgICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodG9vbENhbGwpO1xuICAgICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sQ2FsbC50b29sTmFtZV07XG4gICAgICAgICAgICBpZiAodG9vbDIuZXhlY3V0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2xFeGVjdXRpb25JZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sUmVzdWx0cy5hZGQodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnRvb2xDYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLm5hbWVcIjogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwuaWRcIjogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5hcmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHRvb2xDYWxsLmFyZ3MpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgICAgZm46IGFzeW5jIChzcGFuKSA9PiB0b29sMi5leGVjdXRlKHRvb2xDYWxsLmFyZ3MsIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsXG4gICAgICAgICAgICAgICAgfSkudGhlbihcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIC4uLnRvb2xDYWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuZGVsZXRlKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLnJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBUb29sRXhlY3V0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xBcmdzOiB0b29sQ2FsbC5hcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuZGVsZXRlKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgIGZpbmlzaENodW5rID0ge1xuICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY2h1bmsuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgbG9ncHJvYnM6IGNodW5rLmxvZ3Byb2JzLFxuICAgICAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZShjaHVuay51c2FnZSksXG4gICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVua1R5cGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmhhbmRsZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmbHVzaCgpIHtcbiAgICAgIGNhbkNsb3NlID0gdHJ1ZTtcbiAgICAgIGF0dGVtcHRDbG9zZSgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIGdlbmVyYXRvclN0cmVhbS5waXBlVGhyb3VnaChmb3J3YXJkU3RyZWFtKS5waXBlVG8oXG4gICAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKSxcbiAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW0ucGlwZVRvKFxuICAgICAgICAgIG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgICAgICB3cml0ZShjaHVuaykge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgXSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3N0cmVhbS10ZXh0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkNCA9IGNyZWF0ZUlkR2VuZXJhdG9yNCh7XG4gIHByZWZpeDogXCJhaXR4dFwiLFxuICBzaXplOiAyNFxufSk7XG52YXIgb3JpZ2luYWxHZW5lcmF0ZU1lc3NhZ2VJZDIgPSBjcmVhdGVJZEdlbmVyYXRvcjQoe1xuICBwcmVmaXg6IFwibXNnXCIsXG4gIHNpemU6IDI0XG59KTtcbmZ1bmN0aW9uIHN0cmVhbVRleHQoe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIG1heFN0ZXBzID0gMSxcbiAgZXhwZXJpbWVudGFsX2dlbmVyYXRlTWVzc2FnZUlkOiBnZW5lcmF0ZU1lc3NhZ2VJZCA9IG9yaWdpbmFsR2VuZXJhdGVNZXNzYWdlSWQyLFxuICBleHBlcmltZW50YWxfb3V0cHV0OiBvdXRwdXQsXG4gIGV4cGVyaW1lbnRhbF9jb250aW51ZVN0ZXBzOiBjb250aW51ZVN0ZXBzID0gZmFsc2UsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gIHByb3ZpZGVyT3B0aW9ucyA9IGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICBleHBlcmltZW50YWxfdG9vbENhbGxTdHJlYW1pbmcgPSBmYWxzZSxcbiAgdG9vbENhbGxTdHJlYW1pbmcgPSBleHBlcmltZW50YWxfdG9vbENhbGxTdHJlYW1pbmcsXG4gIGV4cGVyaW1lbnRhbF9hY3RpdmVUb29sczogYWN0aXZlVG9vbHMsXG4gIGV4cGVyaW1lbnRhbF9yZXBhaXJUb29sQ2FsbDogcmVwYWlyVG9vbENhbGwsXG4gIGV4cGVyaW1lbnRhbF90cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgb25DaHVuayxcbiAgb25FcnJvcixcbiAgb25GaW5pc2gsXG4gIG9uU3RlcEZpbmlzaCxcbiAgX2ludGVybmFsOiB7XG4gICAgbm93OiBub3cyID0gbm93LFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkNCxcbiAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gIH0gPSB7fSxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgcmV0dXJuIG5ldyBEZWZhdWx0U3RyZWFtVGV4dFJlc3VsdCh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3MsXG4gICAgbWF4UmV0cmllcyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIHRvb2xzLFxuICAgIHRvb2xDaG9pY2UsXG4gICAgdG9vbENhbGxTdHJlYW1pbmcsXG4gICAgdHJhbnNmb3JtczogYXNBcnJheSh0cmFuc2Zvcm0pLFxuICAgIGFjdGl2ZVRvb2xzLFxuICAgIHJlcGFpclRvb2xDYWxsLFxuICAgIG1heFN0ZXBzLFxuICAgIG91dHB1dCxcbiAgICBjb250aW51ZVN0ZXBzLFxuICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICBvbkNodW5rLFxuICAgIG9uRXJyb3IsXG4gICAgb25GaW5pc2gsXG4gICAgb25TdGVwRmluaXNoLFxuICAgIG5vdzogbm93MixcbiAgICBjdXJyZW50RGF0ZSxcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyxcbiAgICBnZW5lcmF0ZU1lc3NhZ2VJZFxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU91dHB1dFRyYW5zZm9ybVN0cmVhbShvdXRwdXQpIHtcbiAgaWYgKCFvdXRwdXQpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgcGFydDogY2h1bmssIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMCB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsZXQgdGV4dDIgPSBcIlwiO1xuICBsZXQgdGV4dENodW5rID0gXCJcIjtcbiAgbGV0IGxhc3RQdWJsaXNoZWRKc29uID0gXCJcIjtcbiAgZnVuY3Rpb24gcHVibGlzaFRleHRDaHVuayh7XG4gICAgY29udHJvbGxlcixcbiAgICBwYXJ0aWFsT3V0cHV0ID0gdm9pZCAwXG4gIH0pIHtcbiAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgcGFydDogeyB0eXBlOiBcInRleHQtZGVsdGFcIiwgdGV4dERlbHRhOiB0ZXh0Q2h1bmsgfSxcbiAgICAgIHBhcnRpYWxPdXRwdXRcbiAgICB9KTtcbiAgICB0ZXh0Q2h1bmsgPSBcIlwiO1xuICB9XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChjaHVuay50eXBlID09PSBcInN0ZXAtZmluaXNoXCIpIHtcbiAgICAgICAgcHVibGlzaFRleHRDaHVuayh7IGNvbnRyb2xsZXIgfSk7XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgcGFydDogY2h1bmssIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMCB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGV4dDIgKz0gY2h1bmsudGV4dERlbHRhO1xuICAgICAgdGV4dENodW5rICs9IGNodW5rLnRleHREZWx0YTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG91dHB1dC5wYXJzZVBhcnRpYWwoeyB0ZXh0OiB0ZXh0MiB9KTtcbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjdXJyZW50SnNvbiA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdC5wYXJ0aWFsKTtcbiAgICAgICAgaWYgKGN1cnJlbnRKc29uICE9PSBsYXN0UHVibGlzaGVkSnNvbikge1xuICAgICAgICAgIHB1Ymxpc2hUZXh0Q2h1bmsoeyBjb250cm9sbGVyLCBwYXJ0aWFsT3V0cHV0OiByZXN1bHQucGFydGlhbCB9KTtcbiAgICAgICAgICBsYXN0UHVibGlzaGVkSnNvbiA9IGN1cnJlbnRKc29uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICBpZiAodGV4dENodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcHVibGlzaFRleHRDaHVuayh7IGNvbnRyb2xsZXIgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0U3RyZWFtVGV4dFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzLFxuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWwsXG4gICAgc3lzdGVtLFxuICAgIHByb21wdCxcbiAgICBtZXNzYWdlcyxcbiAgICB0b29scyxcbiAgICB0b29sQ2hvaWNlLFxuICAgIHRvb2xDYWxsU3RyZWFtaW5nLFxuICAgIHRyYW5zZm9ybXMsXG4gICAgYWN0aXZlVG9vbHMsXG4gICAgcmVwYWlyVG9vbENhbGwsXG4gICAgbWF4U3RlcHMsXG4gICAgb3V0cHV0LFxuICAgIGNvbnRpbnVlU3RlcHMsXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIG5vdzogbm93MixcbiAgICBjdXJyZW50RGF0ZSxcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyxcbiAgICBnZW5lcmF0ZU1lc3NhZ2VJZCxcbiAgICBvbkNodW5rLFxuICAgIG9uRXJyb3IsXG4gICAgb25GaW5pc2gsXG4gICAgb25TdGVwRmluaXNoXG4gIH0pIHtcbiAgICB0aGlzLndhcm5pbmdzUHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMudXNhZ2VQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5maW5pc2hSZWFzb25Qcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhUHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMudGV4dFByb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLnJlYXNvbmluZ1Byb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLnJlYXNvbmluZ0RldGFpbHNQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5zb3VyY2VzUHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMuZmlsZXNQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy50b29sQ2FsbHNQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy50b29sUmVzdWx0c1Byb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLnJlcXVlc3RQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5yZXNwb25zZVByb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLnN0ZXBzUHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHZhciBfYTE3O1xuICAgIGlmIChtYXhTdGVwcyA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhTdGVwc1wiLFxuICAgICAgICB2YWx1ZTogbWF4U3RlcHMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4U3RlcHMgbXVzdCBiZSBhdCBsZWFzdCAxXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICBsZXQgcmVjb3JkZWRTdGVwVGV4dCA9IFwiXCI7XG4gICAgbGV0IHJlY29yZGVkQ29udGludWF0aW9uVGV4dCA9IFwiXCI7XG4gICAgbGV0IHJlY29yZGVkRnVsbFRleHQgPSBcIlwiO1xuICAgIGxldCBzdGVwUmVhc29uaW5nID0gW107XG4gICAgbGV0IHN0ZXBGaWxlcyA9IFtdO1xuICAgIGxldCBhY3RpdmVSZWFzb25pbmdUZXh0ID0gdm9pZCAwO1xuICAgIGxldCByZWNvcmRlZFN0ZXBTb3VyY2VzID0gW107XG4gICAgY29uc3QgcmVjb3JkZWRTb3VyY2VzID0gW107XG4gICAgY29uc3QgcmVjb3JkZWRSZXNwb25zZSA9IHtcbiAgICAgIGlkOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgdGltZXN0YW1wOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZCxcbiAgICAgIG1lc3NhZ2VzOiBbXVxuICAgIH07XG4gICAgbGV0IHJlY29yZGVkVG9vbENhbGxzID0gW107XG4gICAgbGV0IHJlY29yZGVkVG9vbFJlc3VsdHMgPSBbXTtcbiAgICBsZXQgcmVjb3JkZWRGaW5pc2hSZWFzb24gPSB2b2lkIDA7XG4gICAgbGV0IHJlY29yZGVkVXNhZ2UgPSB2b2lkIDA7XG4gICAgbGV0IHN0ZXBUeXBlID0gXCJpbml0aWFsXCI7XG4gICAgY29uc3QgcmVjb3JkZWRTdGVwcyA9IFtdO1xuICAgIGxldCByb290U3BhbjtcbiAgICBjb25zdCBldmVudFByb2Nlc3NvciA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGNvbnN0IHsgcGFydCB9ID0gY2h1bms7XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dC1kZWx0YVwiIHx8IHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmdcIiB8fCBwYXJ0LnR5cGUgPT09IFwic291cmNlXCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGwtc3RyZWFtaW5nLXN0YXJ0XCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtY2FsbC1kZWx0YVwiKSB7XG4gICAgICAgICAgYXdhaXQgKG9uQ2h1bmsgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2h1bmsoeyBjaHVuazogcGFydCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgYXdhaXQgKG9uRXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRXJyb3IoeyBlcnJvcjogcGFydC5lcnJvciB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICByZWNvcmRlZFN0ZXBUZXh0ICs9IHBhcnQudGV4dERlbHRhO1xuICAgICAgICAgIHJlY29yZGVkQ29udGludWF0aW9uVGV4dCArPSBwYXJ0LnRleHREZWx0YTtcbiAgICAgICAgICByZWNvcmRlZEZ1bGxUZXh0ICs9IHBhcnQudGV4dERlbHRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwicmVhc29uaW5nXCIpIHtcbiAgICAgICAgICBpZiAoYWN0aXZlUmVhc29uaW5nVGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhY3RpdmVSZWFzb25pbmdUZXh0ID0geyB0eXBlOiBcInRleHRcIiwgdGV4dDogcGFydC50ZXh0RGVsdGEgfTtcbiAgICAgICAgICAgIHN0ZXBSZWFzb25pbmcucHVzaChhY3RpdmVSZWFzb25pbmdUZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlUmVhc29uaW5nVGV4dC50ZXh0ICs9IHBhcnQudGV4dERlbHRhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInJlYXNvbmluZy1zaWduYXR1cmVcIikge1xuICAgICAgICAgIGlmIChhY3RpdmVSZWFzb25pbmdUZXh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBSVNES0Vycm9yMTcoe1xuICAgICAgICAgICAgICBuYW1lOiBcIkludmFsaWRTdHJlYW1QYXJ0XCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwicmVhc29uaW5nLXNpZ25hdHVyZSB3aXRob3V0IHJlYXNvbmluZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWN0aXZlUmVhc29uaW5nVGV4dC5zaWduYXR1cmUgPSBwYXJ0LnNpZ25hdHVyZTtcbiAgICAgICAgICBhY3RpdmVSZWFzb25pbmdUZXh0ID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwicmVkYWN0ZWQtcmVhc29uaW5nXCIpIHtcbiAgICAgICAgICBzdGVwUmVhc29uaW5nLnB1c2goeyB0eXBlOiBcInJlZGFjdGVkXCIsIGRhdGE6IHBhcnQuZGF0YSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcImZpbGVcIikge1xuICAgICAgICAgIHN0ZXBGaWxlcy5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwic291cmNlXCIpIHtcbiAgICAgICAgICByZWNvcmRlZFNvdXJjZXMucHVzaChwYXJ0LnNvdXJjZSk7XG4gICAgICAgICAgcmVjb3JkZWRTdGVwU291cmNlcy5wdXNoKHBhcnQuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiKSB7XG4gICAgICAgICAgcmVjb3JkZWRUb29sQ2FsbHMucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIpIHtcbiAgICAgICAgICByZWNvcmRlZFRvb2xSZXN1bHRzLnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJzdGVwLWZpbmlzaFwiKSB7XG4gICAgICAgICAgY29uc3Qgc3RlcE1lc3NhZ2VzID0gdG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgICAgICAgICAgIHRleHQ6IHJlY29yZGVkQ29udGludWF0aW9uVGV4dCxcbiAgICAgICAgICAgIGZpbGVzOiBzdGVwRmlsZXMsXG4gICAgICAgICAgICByZWFzb25pbmc6IHN0ZXBSZWFzb25pbmcsXG4gICAgICAgICAgICB0b29sczogdG9vbHMgIT0gbnVsbCA/IHRvb2xzIDoge30sXG4gICAgICAgICAgICB0b29sQ2FsbHM6IHJlY29yZGVkVG9vbENhbGxzLFxuICAgICAgICAgICAgdG9vbFJlc3VsdHM6IHJlY29yZGVkVG9vbFJlc3VsdHMsXG4gICAgICAgICAgICBtZXNzYWdlSWQ6IHBhcnQubWVzc2FnZUlkLFxuICAgICAgICAgICAgZ2VuZXJhdGVNZXNzYWdlSWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50U3RlcCA9IHJlY29yZGVkU3RlcHMubGVuZ3RoO1xuICAgICAgICAgIGxldCBuZXh0U3RlcFR5cGUgPSBcImRvbmVcIjtcbiAgICAgICAgICBpZiAoY3VycmVudFN0ZXAgKyAxIDwgbWF4U3RlcHMpIHtcbiAgICAgICAgICAgIGlmIChjb250aW51ZVN0ZXBzICYmIHBhcnQuZmluaXNoUmVhc29uID09PSBcImxlbmd0aFwiICYmIC8vIG9ubHkgdXNlIGNvbnRpbnVlIHdoZW4gdGhlcmUgYXJlIG5vIHRvb2wgY2FsbHM6XG4gICAgICAgICAgICByZWNvcmRlZFRvb2xDYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgbmV4dFN0ZXBUeXBlID0gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgLy8gdGhlcmUgYXJlIHRvb2wgY2FsbHM6XG4gICAgICAgICAgICAgIHJlY29yZGVkVG9vbENhbGxzLmxlbmd0aCA+IDAgJiYgLy8gYWxsIGN1cnJlbnQgdG9vbCBjYWxscyBoYXZlIHJlc3VsdHM6XG4gICAgICAgICAgICAgIHJlY29yZGVkVG9vbFJlc3VsdHMubGVuZ3RoID09PSByZWNvcmRlZFRvb2xDYWxscy5sZW5ndGhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBuZXh0U3RlcFR5cGUgPSBcInRvb2wtcmVzdWx0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGVwUmVzdWx0ID0ge1xuICAgICAgICAgICAgc3RlcFR5cGUsXG4gICAgICAgICAgICB0ZXh0OiByZWNvcmRlZFN0ZXBUZXh0LFxuICAgICAgICAgICAgcmVhc29uaW5nOiBhc1JlYXNvbmluZ1RleHQoc3RlcFJlYXNvbmluZyksXG4gICAgICAgICAgICByZWFzb25pbmdEZXRhaWxzOiBzdGVwUmVhc29uaW5nLFxuICAgICAgICAgICAgZmlsZXM6IHN0ZXBGaWxlcyxcbiAgICAgICAgICAgIHNvdXJjZXM6IHJlY29yZGVkU3RlcFNvdXJjZXMsXG4gICAgICAgICAgICB0b29sQ2FsbHM6IHJlY29yZGVkVG9vbENhbGxzLFxuICAgICAgICAgICAgdG9vbFJlc3VsdHM6IHJlY29yZGVkVG9vbFJlc3VsdHMsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IHBhcnQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgdXNhZ2U6IHBhcnQudXNhZ2UsXG4gICAgICAgICAgICB3YXJuaW5nczogcGFydC53YXJuaW5ncyxcbiAgICAgICAgICAgIGxvZ3Byb2JzOiBwYXJ0LmxvZ3Byb2JzLFxuICAgICAgICAgICAgcmVxdWVzdDogcGFydC5yZXF1ZXN0LFxuICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgLi4ucGFydC5yZXNwb25zZSxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IFsuLi5yZWNvcmRlZFJlc3BvbnNlLm1lc3NhZ2VzLCAuLi5zdGVwTWVzc2FnZXNdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgaXNDb250aW51ZWQ6IHBhcnQuaXNDb250aW51ZWRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGF3YWl0IChvblN0ZXBGaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3RlcEZpbmlzaChjdXJyZW50U3RlcFJlc3VsdCkpO1xuICAgICAgICAgIHJlY29yZGVkU3RlcHMucHVzaChjdXJyZW50U3RlcFJlc3VsdCk7XG4gICAgICAgICAgcmVjb3JkZWRUb29sQ2FsbHMgPSBbXTtcbiAgICAgICAgICByZWNvcmRlZFRvb2xSZXN1bHRzID0gW107XG4gICAgICAgICAgcmVjb3JkZWRTdGVwVGV4dCA9IFwiXCI7XG4gICAgICAgICAgcmVjb3JkZWRTdGVwU291cmNlcyA9IFtdO1xuICAgICAgICAgIHN0ZXBSZWFzb25pbmcgPSBbXTtcbiAgICAgICAgICBzdGVwRmlsZXMgPSBbXTtcbiAgICAgICAgICBhY3RpdmVSZWFzb25pbmdUZXh0ID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChuZXh0U3RlcFR5cGUgIT09IFwiZG9uZVwiKSB7XG4gICAgICAgICAgICBzdGVwVHlwZSA9IG5leHRTdGVwVHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5leHRTdGVwVHlwZSAhPT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgICAgICByZWNvcmRlZFJlc3BvbnNlLm1lc3NhZ2VzLnB1c2goLi4uc3RlcE1lc3NhZ2VzKTtcbiAgICAgICAgICAgIHJlY29yZGVkQ29udGludWF0aW9uVGV4dCA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiZmluaXNoXCIpIHtcbiAgICAgICAgICByZWNvcmRlZFJlc3BvbnNlLmlkID0gcGFydC5yZXNwb25zZS5pZDtcbiAgICAgICAgICByZWNvcmRlZFJlc3BvbnNlLnRpbWVzdGFtcCA9IHBhcnQucmVzcG9uc2UudGltZXN0YW1wO1xuICAgICAgICAgIHJlY29yZGVkUmVzcG9uc2UubW9kZWxJZCA9IHBhcnQucmVzcG9uc2UubW9kZWxJZDtcbiAgICAgICAgICByZWNvcmRlZFJlc3BvbnNlLmhlYWRlcnMgPSBwYXJ0LnJlc3BvbnNlLmhlYWRlcnM7XG4gICAgICAgICAgcmVjb3JkZWRVc2FnZSA9IHBhcnQudXNhZ2U7XG4gICAgICAgICAgcmVjb3JkZWRGaW5pc2hSZWFzb24gPSBwYXJ0LmZpbmlzaFJlYXNvbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdmFyIF9hMTg7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHJlY29yZGVkU3RlcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGxhc3RTdGVwID0gcmVjb3JkZWRTdGVwc1tyZWNvcmRlZFN0ZXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHNlbGYud2FybmluZ3NQcm9taXNlLnJlc29sdmUobGFzdFN0ZXAud2FybmluZ3MpO1xuICAgICAgICAgIHNlbGYucmVxdWVzdFByb21pc2UucmVzb2x2ZShsYXN0U3RlcC5yZXF1ZXN0KTtcbiAgICAgICAgICBzZWxmLnJlc3BvbnNlUHJvbWlzZS5yZXNvbHZlKGxhc3RTdGVwLnJlc3BvbnNlKTtcbiAgICAgICAgICBzZWxmLnRvb2xDYWxsc1Byb21pc2UucmVzb2x2ZShsYXN0U3RlcC50b29sQ2FsbHMpO1xuICAgICAgICAgIHNlbGYudG9vbFJlc3VsdHNQcm9taXNlLnJlc29sdmUobGFzdFN0ZXAudG9vbFJlc3VsdHMpO1xuICAgICAgICAgIHNlbGYucHJvdmlkZXJNZXRhZGF0YVByb21pc2UucmVzb2x2ZShcbiAgICAgICAgICAgIGxhc3RTdGVwLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZWxmLnJlYXNvbmluZ1Byb21pc2UucmVzb2x2ZShsYXN0U3RlcC5yZWFzb25pbmcpO1xuICAgICAgICAgIHNlbGYucmVhc29uaW5nRGV0YWlsc1Byb21pc2UucmVzb2x2ZShsYXN0U3RlcC5yZWFzb25pbmdEZXRhaWxzKTtcbiAgICAgICAgICBjb25zdCBmaW5pc2hSZWFzb24gPSByZWNvcmRlZEZpbmlzaFJlYXNvbiAhPSBudWxsID8gcmVjb3JkZWRGaW5pc2hSZWFzb24gOiBcInVua25vd25cIjtcbiAgICAgICAgICBjb25zdCB1c2FnZSA9IHJlY29yZGVkVXNhZ2UgIT0gbnVsbCA/IHJlY29yZGVkVXNhZ2UgOiB7XG4gICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBOYU4sXG4gICAgICAgICAgICBwcm9tcHRUb2tlbnM6IE5hTixcbiAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBOYU5cbiAgICAgICAgICB9O1xuICAgICAgICAgIHNlbGYuZmluaXNoUmVhc29uUHJvbWlzZS5yZXNvbHZlKGZpbmlzaFJlYXNvbik7XG4gICAgICAgICAgc2VsZi51c2FnZVByb21pc2UucmVzb2x2ZSh1c2FnZSk7XG4gICAgICAgICAgc2VsZi50ZXh0UHJvbWlzZS5yZXNvbHZlKHJlY29yZGVkRnVsbFRleHQpO1xuICAgICAgICAgIHNlbGYuc291cmNlc1Byb21pc2UucmVzb2x2ZShyZWNvcmRlZFNvdXJjZXMpO1xuICAgICAgICAgIHNlbGYuZmlsZXNQcm9taXNlLnJlc29sdmUobGFzdFN0ZXAuZmlsZXMpO1xuICAgICAgICAgIHNlbGYuc3RlcHNQcm9taXNlLnJlc29sdmUocmVjb3JkZWRTdGVwcyk7XG4gICAgICAgICAgYXdhaXQgKG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7XG4gICAgICAgICAgICBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICBsb2dwcm9iczogdm9pZCAwLFxuICAgICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgICB0ZXh0OiByZWNvcmRlZEZ1bGxUZXh0LFxuICAgICAgICAgICAgcmVhc29uaW5nOiBsYXN0U3RlcC5yZWFzb25pbmcsXG4gICAgICAgICAgICByZWFzb25pbmdEZXRhaWxzOiBsYXN0U3RlcC5yZWFzb25pbmdEZXRhaWxzLFxuICAgICAgICAgICAgZmlsZXM6IGxhc3RTdGVwLmZpbGVzLFxuICAgICAgICAgICAgc291cmNlczogbGFzdFN0ZXAuc291cmNlcyxcbiAgICAgICAgICAgIHRvb2xDYWxsczogbGFzdFN0ZXAudG9vbENhbGxzLFxuICAgICAgICAgICAgdG9vbFJlc3VsdHM6IGxhc3RTdGVwLnRvb2xSZXN1bHRzLFxuICAgICAgICAgICAgcmVxdWVzdDogKF9hMTggPSBsYXN0U3RlcC5yZXF1ZXN0KSAhPSBudWxsID8gX2ExOCA6IHt9LFxuICAgICAgICAgICAgcmVzcG9uc2U6IGxhc3RTdGVwLnJlc3BvbnNlLFxuICAgICAgICAgICAgd2FybmluZ3M6IGxhc3RTdGVwLndhcm5pbmdzLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbGFzdFN0ZXAucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBsYXN0U3RlcC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgIHN0ZXBzOiByZWNvcmRlZFN0ZXBzXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJvb3RTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7IG91dHB1dDogKCkgPT4gcmVjb3JkZWRGdWxsVGV4dCB9LFxuICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ExOTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoX2ExOSA9IGxhc3RTdGVwLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTkubGVuZ3RoKSA/IEpTT04uc3RyaW5naWZ5KGxhc3RTdGVwLnRvb2xDYWxscykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiB1c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHJvb3RTcGFuLmVuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3RpdGNoYWJsZVN0cmVhbSA9IGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKTtcbiAgICB0aGlzLmFkZFN0cmVhbSA9IHN0aXRjaGFibGVTdHJlYW0uYWRkU3RyZWFtO1xuICAgIHRoaXMuY2xvc2VTdHJlYW0gPSBzdGl0Y2hhYmxlU3RyZWFtLmNsb3NlO1xuICAgIGxldCBzdHJlYW0gPSBzdGl0Y2hhYmxlU3RyZWFtLnN0cmVhbTtcbiAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybSBvZiB0cmFuc2Zvcm1zKSB7XG4gICAgICBzdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgIHRyYW5zZm9ybSh7XG4gICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgc3RvcFN0cmVhbSgpIHtcbiAgICAgICAgICAgIHN0aXRjaGFibGVTdHJlYW0udGVybWluYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5iYXNlU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZU91dHB1dFRyYW5zZm9ybVN0cmVhbShvdXRwdXQpKS5waXBlVGhyb3VnaChldmVudFByb2Nlc3Nvcik7XG4gICAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZ1xuICAgIH0pO1xuICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICAgIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgbW9kZWwsXG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICAgIH0pO1xuICAgIGNvbnN0IGluaXRpYWxQcm9tcHQgPSBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICBwcm9tcHQ6IHtcbiAgICAgICAgc3lzdGVtOiAoX2ExNyA9IG91dHB1dCA9PSBudWxsID8gdm9pZCAwIDogb3V0cHV0LmluamVjdEludG9TeXN0ZW1Qcm9tcHQoeyBzeXN0ZW0sIG1vZGVsIH0pKSAhPSBudWxsID8gX2ExNyA6IHN5c3RlbSxcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlc1xuICAgICAgfSxcbiAgICAgIHRvb2xzXG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmVjb3JkU3Bhbih7XG4gICAgICBuYW1lOiBcImFpLnN0cmVhbVRleHRcIixcbiAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5zdHJlYW1UZXh0XCIsIHRlbGVtZXRyeSB9KSxcbiAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImFpLnNldHRpbmdzLm1heFN0ZXBzXCI6IG1heFN0ZXBzXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgZm46IGFzeW5jIChyb290U3BhbkFyZykgPT4ge1xuICAgICAgICByb290U3BhbiA9IHJvb3RTcGFuQXJnO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBzdHJlYW1TdGVwKHtcbiAgICAgICAgICBjdXJyZW50U3RlcCxcbiAgICAgICAgICByZXNwb25zZU1lc3NhZ2VzLFxuICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgIHN0ZXBUeXBlOiBzdGVwVHlwZTIsXG4gICAgICAgICAgcHJldmlvdXNTdGVwVGV4dCxcbiAgICAgICAgICBoYXNMZWFkaW5nV2hpdGVzcGFjZSxcbiAgICAgICAgICBtZXNzYWdlSWRcbiAgICAgICAgfSkge1xuICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgIGNvbnN0IHByb21wdEZvcm1hdCA9IHJlc3BvbnNlTWVzc2FnZXMubGVuZ3RoID09PSAwID8gaW5pdGlhbFByb21wdC50eXBlIDogXCJtZXNzYWdlc1wiO1xuICAgICAgICAgIGNvbnN0IHN0ZXBJbnB1dE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgLi4uaW5pdGlhbFByb21wdC5tZXNzYWdlcyxcbiAgICAgICAgICAgIC4uLnJlc3BvbnNlTWVzc2FnZXNcbiAgICAgICAgICBdO1xuICAgICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHtcbiAgICAgICAgICAgICAgdHlwZTogcHJvbXB0Rm9ybWF0LFxuICAgICAgICAgICAgICBzeXN0ZW06IGluaXRpYWxQcm9tcHQuc3lzdGVtLFxuICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJscyxcbiAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IChfYTE4ID0gbW9kZWwuc3VwcG9ydHNVcmwpID09IG51bGwgPyB2b2lkIDAgOiBfYTE4LmJpbmQobW9kZWwpXG4gICAgICAgICAgICAvLyBzdXBwb3J0ICd0aGlzJyBjb250ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgbW9kZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVndWxhclwiLFxuICAgICAgICAgICAgLi4ucHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7IHRvb2xzLCB0b29sQ2hvaWNlLCBhY3RpdmVUb29scyB9KVxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgcmVzdWx0OiB7IHN0cmVhbTogc3RyZWFtMiwgd2FybmluZ3MsIHJhd1Jlc3BvbnNlLCByZXF1ZXN0IH0sXG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zXG4gICAgICAgICAgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICAgIG5hbWU6IFwiYWkuc3RyZWFtVGV4dC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtVGV4dC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5mb3JtYXRcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gcHJvbXB0Rm9ybWF0XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gc3RyaW5naWZ5Rm9yVGVsZW1ldHJ5KHByb21wdE1lc3NhZ2VzKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCB0aGUgbGFuZ3VhZ2UgbW9kZWwgbGV2ZWwgdG9vbHM6XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIF9hMTk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfYTE5ID0gbW9kZS50b29scykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTkubWFwKCh0b29sMikgPT4gSlNPTi5zdHJpbmdpZnkodG9vbDIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xDaG9pY2VcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gbW9kZS50b29sQ2hvaWNlICE9IG51bGwgPyBKU09OLnN0cmluZ2lmeShtb2RlLnRvb2xDaG9pY2UpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnN0b3Bfc2VxdWVuY2VzXCI6IHNldHRpbmdzLnN0b3BTZXF1ZW5jZXMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgIGZuOiBhc3luYyAoZG9TdHJlYW1TcGFuMikgPT4gKHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zOiBub3cyKCksXG4gICAgICAgICAgICAgICAgLy8gZ2V0IGJlZm9yZSB0aGUgY2FsbFxuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMixcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGF3YWl0IG1vZGVsLmRvU3RyZWFtKHtcbiAgICAgICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0OiBwcm9tcHRGb3JtYXQsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZUZvcm1hdDogb3V0cHV0ID09IG51bGwgPyB2b2lkIDAgOiBvdXRwdXQucmVzcG9uc2VGb3JtYXQoeyBtb2RlbCB9KSxcbiAgICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkU3RyZWFtID0gcnVuVG9vbHNUcmFuc2Zvcm1hdGlvbih7XG4gICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgIGdlbmVyYXRvclN0cmVhbTogc3RyZWFtMixcbiAgICAgICAgICAgIHRvb2xDYWxsU3RyZWFtaW5nLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgcmVwYWlyVG9vbENhbGwsXG4gICAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHN0ZXBSZXF1ZXN0ID0gcmVxdWVzdCAhPSBudWxsID8gcmVxdWVzdCA6IHt9O1xuICAgICAgICAgIGNvbnN0IHN0ZXBUb29sQ2FsbHMgPSBbXTtcbiAgICAgICAgICBjb25zdCBzdGVwVG9vbFJlc3VsdHMgPSBbXTtcbiAgICAgICAgICBjb25zdCBzdGVwUmVhc29uaW5nMiA9IFtdO1xuICAgICAgICAgIGNvbnN0IHN0ZXBGaWxlczIgPSBbXTtcbiAgICAgICAgICBsZXQgYWN0aXZlUmVhc29uaW5nVGV4dDIgPSB2b2lkIDA7XG4gICAgICAgICAgbGV0IHN0ZXBGaW5pc2hSZWFzb24gPSBcInVua25vd25cIjtcbiAgICAgICAgICBsZXQgc3RlcFVzYWdlID0ge1xuICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiAwLFxuICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogMCxcbiAgICAgICAgICAgIHRvdGFsVG9rZW5zOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBsZXQgc3RlcFByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgbGV0IHN0ZXBGaXJzdENodW5rID0gdHJ1ZTtcbiAgICAgICAgICBsZXQgc3RlcFRleHQgPSBcIlwiO1xuICAgICAgICAgIGxldCBmdWxsU3RlcFRleHQgPSBzdGVwVHlwZTIgPT09IFwiY29udGludWVcIiA/IHByZXZpb3VzU3RlcFRleHQgOiBcIlwiO1xuICAgICAgICAgIGxldCBzdGVwTG9nUHJvYnM7XG4gICAgICAgICAgbGV0IHN0ZXBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICAgICAgICAgIH07XG4gICAgICAgICAgbGV0IGNodW5rQnVmZmVyID0gXCJcIjtcbiAgICAgICAgICBsZXQgY2h1bmtUZXh0UHVibGlzaGVkID0gZmFsc2U7XG4gICAgICAgICAgbGV0IGluV2hpdGVzcGFjZVByZWZpeCA9IHRydWU7XG4gICAgICAgICAgbGV0IGhhc1doaXRlc3BhY2VTdWZmaXggPSBmYWxzZTtcbiAgICAgICAgICBhc3luYyBmdW5jdGlvbiBwdWJsaXNoVGV4dENodW5rKHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgICAgICBjaHVua1xuICAgICAgICAgIH0pIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICBzdGVwVGV4dCArPSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgICAgICBmdWxsU3RlcFRleHQgKz0gY2h1bmsudGV4dERlbHRhO1xuICAgICAgICAgICAgY2h1bmtUZXh0UHVibGlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGhhc1doaXRlc3BhY2VTdWZmaXggPSBjaHVuay50ZXh0RGVsdGEudHJpbUVuZCgpICE9PSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuYWRkU3RyZWFtKFxuICAgICAgICAgICAgdHJhbnNmb3JtZWRTdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgdmFyIF9hMTksIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgIGlmIChzdGVwRmlyc3RDaHVuaykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc1RvRmlyc3RDaHVuayA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wTXM7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maXJzdENodW5rXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVua1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXAtc3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogc3RlcFJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3M6IHdhcm5pbmdzICE9IG51bGwgPyB3YXJuaW5ncyA6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1kZWx0YVwiICYmIGNodW5rLnRleHREZWx0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmsudHlwZTtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2h1bmtUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGludWVTdGVwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZENodW5rVGV4dCA9IGluV2hpdGVzcGFjZVByZWZpeCAmJiBoYXNMZWFkaW5nV2hpdGVzcGFjZSA/IGNodW5rLnRleHREZWx0YS50cmltU3RhcnQoKSA6IGNodW5rLnRleHREZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmltbWVkQ2h1bmtUZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluV2hpdGVzcGFjZVByZWZpeCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtCdWZmZXIgKz0gdHJpbW1lZENodW5rVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwbGl0ID0gc3BsaXRPbkxhc3RXaGl0ZXNwYWNlKGNodW5rQnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rQnVmZmVyID0gc3BsaXQuc3VmZml4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBwdWJsaXNoVGV4dENodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHREZWx0YTogc3BsaXQucHJlZml4ICsgc3BsaXQud2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHB1Ymxpc2hUZXh0Q2h1bmsoeyBjb250cm9sbGVyLCBjaHVuayB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZ1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlUmVhc29uaW5nVGV4dDIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlUmVhc29uaW5nVGV4dDIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaHVuay50ZXh0RGVsdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwUmVhc29uaW5nMi5wdXNoKGFjdGl2ZVJlYXNvbmluZ1RleHQyKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlUmVhc29uaW5nVGV4dDIudGV4dCArPSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmctc2lnbmF0dXJlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVSZWFzb25pbmdUZXh0MiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN0cmVhbVBhcnRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcInJlYXNvbmluZy1zaWduYXR1cmUgd2l0aG91dCByZWFzb25pbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVJlYXNvbmluZ1RleHQyLnNpZ25hdHVyZSA9IGNodW5rLnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVSZWFzb25pbmdUZXh0MiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVkYWN0ZWQtcmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBSZWFzb25pbmcyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWRhY3RlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY2h1bmsuZGF0YVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFRvb2xDYWxscy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFRvb2xSZXN1bHRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IChfYTE5ID0gY2h1bmsuaWQpICE9IG51bGwgPyBfYTE5IDogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2IgPSBjaHVuay50aW1lc3RhbXApICE9IG51bGwgPyBfYiA6IHN0ZXBSZXNwb25zZS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2MgPSBjaHVuay5tb2RlbElkKSAhPSBudWxsID8gX2MgOiBzdGVwUmVzcG9uc2UubW9kZWxJZFxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFVzYWdlID0gY2h1bmsudXNhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcEZpbmlzaFJlYXNvbiA9IGNodW5rLmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwUHJvdmlkZXJNZXRhZGF0YSA9IGNodW5rLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBMb2dQcm9icyA9IGNodW5rLmxvZ3Byb2JzO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zVG9GaW5pc2ggPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maW5pc2hcIik7XG4gICAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tc1RvRmluaXNoXCI6IG1zVG9GaW5pc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmF2Z0NvbXBsZXRpb25Ub2tlbnNQZXJTZWNvbmRcIjogMWUzICogc3RlcFVzYWdlLmNvbXBsZXRpb25Ub2tlbnMgLyBtc1RvRmluaXNoXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBGaWxlczIucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic291cmNlXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtc3RyZWFtaW5nLXN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBGaW5pc2hSZWFzb24gPSBcImVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IGNodW5rVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY2h1bmsgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIGludm9rZSBvbkZpbmlzaCBjYWxsYmFjayBhbmQgcmVzb2x2ZSB0b29sUmVzdWx0cyBwcm9taXNlIHdoZW4gdGhlIHN0cmVhbSBpcyBhYm91dCB0byBjbG9zZTpcbiAgICAgICAgICAgICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBzdGVwVG9vbENhbGxzSnNvbiA9IHN0ZXBUb29sQ2FsbHMubGVuZ3RoID4gMCA/IEpTT04uc3RyaW5naWZ5KHN0ZXBUb29sQ2FsbHMpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgbGV0IG5leHRTdGVwVHlwZSA9IFwiZG9uZVwiO1xuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGVwICsgMSA8IG1heFN0ZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250aW51ZVN0ZXBzICYmIHN0ZXBGaW5pc2hSZWFzb24gPT09IFwibGVuZ3RoXCIgJiYgLy8gb25seSB1c2UgY29udGludWUgd2hlbiB0aGVyZSBhcmUgbm8gdG9vbCBjYWxsczpcbiAgICAgICAgICAgICAgICAgICAgc3RlcFRvb2xDYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RlcFR5cGUgPSBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmUgYXJlIHRvb2wgY2FsbHM6XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFRvb2xDYWxscy5sZW5ndGggPiAwICYmIC8vIGFsbCBjdXJyZW50IHRvb2wgY2FsbHMgaGF2ZSByZXN1bHRzOlxuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBUb29sUmVzdWx0cy5sZW5ndGggPT09IHN0ZXBUb29sQ2FsbHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGVwVHlwZSA9IFwidG9vbC1yZXN1bHRcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGNvbnRpbnVlU3RlcHMgJiYgY2h1bmtCdWZmZXIubGVuZ3RoID4gMCAmJiAobmV4dFN0ZXBUeXBlICE9PSBcImNvbnRpbnVlXCIgfHwgLy8gd2hlbiB0aGUgbmV4dCBzdGVwIGlzIGEgcmVndWxhciBzdGVwLCBwdWJsaXNoIHRoZSBidWZmZXJcbiAgICAgICAgICAgICAgICAgIHN0ZXBUeXBlMiA9PT0gXCJjb250aW51ZVwiICYmICFjaHVua1RleHRQdWJsaXNoZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHB1Ymxpc2hUZXh0Q2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgY2h1bms6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhOiBjaHVua0J1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rQnVmZmVyID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjogeyBvdXRwdXQ6ICgpID0+IHN0ZXBUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHN0ZXBUb29sQ2FsbHNKc29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1vZGVsXCI6IHN0ZXBSZXNwb25zZS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiBzdGVwUmVzcG9uc2UudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHN0ZXBVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiBzdGVwVXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbc3RlcEZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHN0ZXBSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogc3RlcFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiBzdGVwVXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI6IHN0ZXBVc2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uZW5kKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXAtZmluaXNoXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgdXNhZ2U6IHN0ZXBVc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogc3RlcFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBzdGVwUHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgbG9ncHJvYnM6IHN0ZXBMb2dQcm9icyxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogc3RlcFJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uc3RlcFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLFxuICAgICAgICAgICAgICAgICAgICBpc0NvbnRpbnVlZDogbmV4dFN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjb21iaW5lZFVzYWdlID0gYWRkTGFuZ3VhZ2VNb2RlbFVzYWdlKHVzYWdlLCBzdGVwVXNhZ2UpO1xuICAgICAgICAgICAgICAgICAgaWYgKG5leHRTdGVwVHlwZSA9PT0gXCJkb25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICB1c2FnZTogY29tYmluZWRVc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBzdGVwUHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogc3RlcFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgbG9ncHJvYnM6IHN0ZXBMb2dQcm9icyxcbiAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RlcFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmF3UmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJhd1Jlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlU3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcFR5cGUyID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IHJlc3BvbnNlTWVzc2FnZXNbcmVzcG9uc2VNZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RNZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlLmNvbnRlbnQgKz0gc3RlcFRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlLmNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHN0ZXBUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHN0ZXBUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlczogc3RlcEZpbGVzMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uaW5nOiBzdGVwUmVhc29uaW5nMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHM6IHRvb2xzICE9IG51bGwgPyB0b29scyA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbHM6IHN0ZXBUb29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzOiBzdGVwVG9vbFJlc3VsdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVNZXNzYWdlSWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzdHJlYW1TdGVwKHtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RlcDogY3VycmVudFN0ZXAgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgdXNhZ2U6IGNvbWJpbmVkVXNhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFR5cGU6IG5leHRTdGVwVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1N0ZXBUZXh0OiBmdWxsU3RlcFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgaGFzTGVhZGluZ1doaXRlc3BhY2U6IGhhc1doaXRlc3BhY2VTdWZmaXgsXG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUlkOiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIHRoZSBzYW1lIGlkIHdoZW4gY29udGludWluZyBhIHN0ZXA6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RlcFR5cGUgPT09IFwiY29udGludWVcIiA/IG1lc3NhZ2VJZCA6IGdlbmVyYXRlTWVzc2FnZUlkKClcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHN0cmVhbVN0ZXAoe1xuICAgICAgICAgIGN1cnJlbnRTdGVwOiAwLFxuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXM6IFtdLFxuICAgICAgICAgIHVzYWdlOiB7XG4gICAgICAgICAgICBwcm9tcHRUb2tlbnM6IDAsXG4gICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiAwLFxuICAgICAgICAgICAgdG90YWxUb2tlbnM6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByZXZpb3VzU3RlcFRleHQ6IFwiXCIsXG4gICAgICAgICAgc3RlcFR5cGU6IFwiaW5pdGlhbFwiLFxuICAgICAgICAgIGhhc0xlYWRpbmdXaGl0ZXNwYWNlOiBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlSWQ6IGdlbmVyYXRlTWVzc2FnZUlkKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBzZWxmLmFkZFN0cmVhbShcbiAgICAgICAgbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBzZWxmLmNsb3NlU3RyZWFtKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLndhcm5pbmdzUHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgdXNhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudXNhZ2VQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCBmaW5pc2hSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoUmVhc29uUHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJNZXRhZGF0YVByb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHByb3ZpZGVyTWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJNZXRhZGF0YVByb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dFByb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHJlYXNvbmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFzb25pbmdQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCByZWFzb25pbmdEZXRhaWxzKCkge1xuICAgIHJldHVybiB0aGlzLnJlYXNvbmluZ0RldGFpbHNQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCBzb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZXNQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCBmaWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5maWxlc1Byb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHRvb2xDYWxscygpIHtcbiAgICByZXR1cm4gdGhpcy50b29sQ2FsbHNQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCB0b29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy50b29sUmVzdWx0c1Byb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdFByb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHJlc3BvbnNlKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlUHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgc3RlcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcHNQcm9taXNlLnZhbHVlO1xuICB9XG4gIC8qKlxuICBTcGxpdCBvdXQgYSBuZXcgc3RyZWFtIGZyb20gdGhlIG9yaWdpbmFsIHN0cmVhbS5cbiAgVGhlIG9yaWdpbmFsIHN0cmVhbSBpcyByZXBsYWNlZCB0byBhbGxvdyBmb3IgZnVydGhlciBzcGxpdHRpbmcsXG4gIHNpbmNlIHdlIGRvIG5vdCBrbm93IGhvdyBtYW55IHRpbWVzIHRoZSBzdHJlYW0gd2lsbCBiZSBzcGxpdC5cbiAgXG4gIE5vdGU6IHRoaXMgbGVhZHMgdG8gYnVmZmVyaW5nIHRoZSBzdHJlYW0gY29udGVudCBvbiB0aGUgc2VydmVyLlxuICBIb3dldmVyLCB0aGUgTExNIHJlc3VsdHMgYXJlIGV4cGVjdGVkIHRvIGJlIHNtYWxsIGVub3VnaCB0byBub3QgY2F1c2UgaXNzdWVzLlxuICAgICAqL1xuICB0ZWVTdHJlYW0oKSB7XG4gICAgY29uc3QgW3N0cmVhbTEsIHN0cmVhbTJdID0gdGhpcy5iYXNlU3RyZWFtLnRlZSgpO1xuICAgIHRoaXMuYmFzZVN0cmVhbSA9IHN0cmVhbTI7XG4gICAgcmV0dXJuIHN0cmVhbTE7XG4gIH1cbiAgZ2V0IHRleHRTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICB0aGlzLnRlZVN0cmVhbSgpLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oeyBwYXJ0IH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dC1kZWx0YVwiKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0LnRleHREZWx0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgZ2V0IGZ1bGxTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICB0aGlzLnRlZVN0cmVhbSgpLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oeyBwYXJ0IH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBhc3luYyBjb25zdW1lU3RyZWFtKG9wdGlvbnMpIHtcbiAgICB2YXIgX2ExNztcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY29uc3VtZVN0cmVhbSh7XG4gICAgICAgIHN0cmVhbTogdGhpcy5mdWxsU3RyZWFtLFxuICAgICAgICBvbkVycm9yOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uRXJyb3JcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAoX2ExNyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25FcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbChvcHRpb25zLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIGdldCBleHBlcmltZW50YWxfcGFydGlhbE91dHB1dFN0cmVhbSgpIHtcbiAgICBpZiAodGhpcy5vdXRwdXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vT3V0cHV0U3BlY2lmaWVkRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICB0aGlzLnRlZVN0cmVhbSgpLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oeyBwYXJ0aWFsT3V0cHV0IH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0aWFsT3V0cHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnRpYWxPdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHRvRGF0YVN0cmVhbUludGVybmFsKHtcbiAgICBnZXRFcnJvck1lc3NhZ2U6IGdldEVycm9yTWVzc2FnZTUgPSAoKSA9PiBcIkFuIGVycm9yIG9jY3VycmVkLlwiLFxuICAgIC8vIG1hc2sgZXJyb3IgbWVzc2FnZXMgZm9yIHNhZmV0eSBieSBkZWZhdWx0XG4gICAgc2VuZFVzYWdlID0gdHJ1ZSxcbiAgICBzZW5kUmVhc29uaW5nID0gZmFsc2UsXG4gICAgc2VuZFNvdXJjZXMgPSBmYWxzZSxcbiAgICBleHBlcmltZW50YWxfc2VuZEZpbmlzaCA9IHRydWVcbiAgfSkge1xuICAgIHJldHVybiB0aGlzLmZ1bGxTdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgICAgIHN3aXRjaCAoY2h1bmtUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShmb3JtYXREYXRhU3RyZWFtUGFydDIoXCJ0ZXh0XCIsIGNodW5rLnRleHREZWx0YSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjoge1xuICAgICAgICAgICAgICBpZiAoc2VuZFJlYXNvbmluZykge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgIGZvcm1hdERhdGFTdHJlYW1QYXJ0MihcInJlYXNvbmluZ1wiLCBjaHVuay50ZXh0RGVsdGEpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWRhY3RlZC1yZWFzb25pbmdcIjoge1xuICAgICAgICAgICAgICBpZiAoc2VuZFJlYXNvbmluZykge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgIGZvcm1hdERhdGFTdHJlYW1QYXJ0MihcInJlZGFjdGVkX3JlYXNvbmluZ1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNodW5rLmRhdGFcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmctc2lnbmF0dXJlXCI6IHtcbiAgICAgICAgICAgICAgaWYgKHNlbmRSZWFzb25pbmcpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICBmb3JtYXREYXRhU3RyZWFtUGFydDIoXCJyZWFzb25pbmdfc2lnbmF0dXJlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBjaHVuay5zaWduYXR1cmVcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgIGZvcm1hdERhdGFTdHJlYW1QYXJ0MihcImZpbGVcIiwge1xuICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IGNodW5rLm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgZGF0YTogY2h1bmsuYmFzZTY0XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic291cmNlXCI6IHtcbiAgICAgICAgICAgICAgaWYgKHNlbmRTb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgICAgZm9ybWF0RGF0YVN0cmVhbVBhcnQyKFwic291cmNlXCIsIGNodW5rLnNvdXJjZSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgZm9ybWF0RGF0YVN0cmVhbVBhcnQyKFwidG9vbF9jYWxsX3N0cmVhbWluZ19zdGFydFwiLCB7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgIGZvcm1hdERhdGFTdHJlYW1QYXJ0MihcInRvb2xfY2FsbF9kZWx0YVwiLCB7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgYXJnc1RleHREZWx0YTogY2h1bmsuYXJnc1RleHREZWx0YVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICBmb3JtYXREYXRhU3RyZWFtUGFydDIoXCJ0b29sX2NhbGxcIiwge1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IGNodW5rLmFyZ3NcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICBmb3JtYXREYXRhU3RyZWFtUGFydDIoXCJ0b29sX3Jlc3VsdFwiLCB7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgcmVzdWx0OiBjaHVuay5yZXN1bHRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICBmb3JtYXREYXRhU3RyZWFtUGFydDIoXCJlcnJvclwiLCBnZXRFcnJvck1lc3NhZ2U1KGNodW5rLmVycm9yKSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic3RlcC1zdGFydFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICBmb3JtYXREYXRhU3RyZWFtUGFydDIoXCJzdGFydF9zdGVwXCIsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogY2h1bmsubWVzc2FnZUlkXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic3RlcC1maW5pc2hcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgZm9ybWF0RGF0YVN0cmVhbVBhcnQyKFwiZmluaXNoX3N0ZXBcIiwge1xuICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjaHVuay5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICB1c2FnZTogc2VuZFVzYWdlID8ge1xuICAgICAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IGNodW5rLnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogY2h1bmsudXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgICAgfSA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgIGlzQ29udGludWVkOiBjaHVuay5pc0NvbnRpbnVlZFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgIGlmIChleHBlcmltZW50YWxfc2VuZEZpbmlzaCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgIGZvcm1hdERhdGFTdHJlYW1QYXJ0MihcImZpbmlzaF9tZXNzYWdlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjaHVuay5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgIHVzYWdlOiBzZW5kVXNhZ2UgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBjaHVuay51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogY2h1bmsudXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgICAgICB9IDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IGNodW5rVHlwZTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNodW5rIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIHBpcGVEYXRhU3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwge1xuICAgIHN0YXR1cyxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGhlYWRlcnMsXG4gICAgZGF0YSxcbiAgICBnZXRFcnJvck1lc3NhZ2U6IGdldEVycm9yTWVzc2FnZTUsXG4gICAgc2VuZFVzYWdlLFxuICAgIHNlbmRSZWFzb25pbmcsXG4gICAgc2VuZFNvdXJjZXMsXG4gICAgZXhwZXJpbWVudGFsX3NlbmRGaW5pc2hcbiAgfSA9IHt9KSB7XG4gICAgd3JpdGVUb1NlcnZlclJlc3BvbnNlKHtcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVPdXRnb2luZ0h0dHBIZWFkZXJzKGhlYWRlcnMsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICBkYXRhU3RyZWFtVmVyc2lvbjogXCJ2MVwiXG4gICAgICB9KSxcbiAgICAgIHN0cmVhbTogdGhpcy50b0RhdGFTdHJlYW0oe1xuICAgICAgICBkYXRhLFxuICAgICAgICBnZXRFcnJvck1lc3NhZ2U6IGdldEVycm9yTWVzc2FnZTUsXG4gICAgICAgIHNlbmRVc2FnZSxcbiAgICAgICAgc2VuZFJlYXNvbmluZyxcbiAgICAgICAgc2VuZFNvdXJjZXMsXG4gICAgICAgIGV4cGVyaW1lbnRhbF9zZW5kRmluaXNoXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gICAgICByZXNwb25zZSxcbiAgICAgIHN0YXR1czogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlT3V0Z29pbmdIdHRwSGVhZGVycyhpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnMsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KSxcbiAgICAgIHN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKVxuICAgIH0pO1xuICB9XG4gIC8vIFRPRE8gYnJlYWtpbmcgY2hhbmdlIDUuMDogcmVtb3ZlIHBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKVxuICB0b0RhdGFTdHJlYW0ob3B0aW9ucykge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMudG9EYXRhU3RyZWFtSW50ZXJuYWwoe1xuICAgICAgZ2V0RXJyb3JNZXNzYWdlOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdldEVycm9yTWVzc2FnZSxcbiAgICAgIHNlbmRVc2FnZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zZW5kVXNhZ2UsXG4gICAgICBzZW5kUmVhc29uaW5nOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnNlbmRSZWFzb25pbmcsXG4gICAgICBzZW5kU291cmNlczogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zZW5kU291cmNlcyxcbiAgICAgIGV4cGVyaW1lbnRhbF9zZW5kRmluaXNoOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmV4cGVyaW1lbnRhbF9zZW5kRmluaXNoXG4gICAgfSkucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpO1xuICAgIHJldHVybiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSA/IG1lcmdlU3RyZWFtcyhvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEuc3RyZWFtLCBzdHJlYW0pIDogc3RyZWFtO1xuICB9XG4gIG1lcmdlSW50b0RhdGFTdHJlYW0od3JpdGVyLCBvcHRpb25zKSB7XG4gICAgd3JpdGVyLm1lcmdlKFxuICAgICAgdGhpcy50b0RhdGFTdHJlYW1JbnRlcm5hbCh7XG4gICAgICAgIGdldEVycm9yTWVzc2FnZTogd3JpdGVyLm9uRXJyb3IsXG4gICAgICAgIHNlbmRVc2FnZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zZW5kVXNhZ2UsXG4gICAgICAgIHNlbmRSZWFzb25pbmc6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2VuZFJlYXNvbmluZyxcbiAgICAgICAgc2VuZFNvdXJjZXM6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2VuZFNvdXJjZXMsXG4gICAgICAgIGV4cGVyaW1lbnRhbF9zZW5kRmluaXNoOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmV4cGVyaW1lbnRhbF9zZW5kRmluaXNoXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgdG9EYXRhU3RyZWFtUmVzcG9uc2Uoe1xuICAgIGhlYWRlcnMsXG4gICAgc3RhdHVzLFxuICAgIHN0YXR1c1RleHQsXG4gICAgZGF0YSxcbiAgICBnZXRFcnJvck1lc3NhZ2U6IGdldEVycm9yTWVzc2FnZTUsXG4gICAgc2VuZFVzYWdlLFxuICAgIHNlbmRSZWFzb25pbmcsXG4gICAgc2VuZFNvdXJjZXMsXG4gICAgZXhwZXJpbWVudGFsX3NlbmRGaW5pc2hcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICAgIHRoaXMudG9EYXRhU3RyZWFtKHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZ2V0RXJyb3JNZXNzYWdlOiBnZXRFcnJvck1lc3NhZ2U1LFxuICAgICAgICBzZW5kVXNhZ2UsXG4gICAgICAgIHNlbmRSZWFzb25pbmcsXG4gICAgICAgIHNlbmRTb3VyY2VzLFxuICAgICAgICBleHBlcmltZW50YWxfc2VuZEZpbmlzaFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhoZWFkZXJzLCB7XG4gICAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICAgIGRhdGFTdHJlYW1WZXJzaW9uOiBcInYxXCJcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHRvVGV4dFN0cmVhbVJlc3BvbnNlKGluaXQpIHtcbiAgICB2YXIgX2ExNztcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSksIHtcbiAgICAgIHN0YXR1czogKF9hMTcgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTcgOiAyMDAsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycywge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIGVycm9ycy9uby1zcGVlY2gtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxOCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgTm9TcGVlY2hHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjE4IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiQUlfTm9TcGVlY2hHZW5lcmF0ZWRFcnJvclwiLFxuICAgICAgbWVzc2FnZTogXCJObyBzcGVlY2ggYXVkaW8gZ2VuZXJhdGVkLlwiXG4gICAgfSk7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgfVxufTtcblxuLy8gY29yZS9nZW5lcmF0ZS1zcGVlY2gvZ2VuZXJhdGVkLWF1ZGlvLWZpbGUudHNcbnZhciBEZWZhdWx0R2VuZXJhdGVkQXVkaW9GaWxlID0gY2xhc3MgZXh0ZW5kcyBEZWZhdWx0R2VuZXJhdGVkRmlsZSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXRhLFxuICAgIG1pbWVUeXBlXG4gIH0pIHtcbiAgICBzdXBlcih7IGRhdGEsIG1pbWVUeXBlIH0pO1xuICAgIGxldCBmb3JtYXQgPSBcIm1wM1wiO1xuICAgIGlmIChtaW1lVHlwZSkge1xuICAgICAgY29uc3QgbWltZVR5cGVQYXJ0cyA9IG1pbWVUeXBlLnNwbGl0KFwiL1wiKTtcbiAgICAgIGlmIChtaW1lVHlwZVBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBpZiAobWltZVR5cGUgIT09IFwiYXVkaW8vbXBlZ1wiKSB7XG4gICAgICAgICAgZm9ybWF0ID0gbWltZVR5cGVQYXJ0c1sxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkF1ZGlvIGZvcm1hdCBtdXN0IGJlIHByb3ZpZGVkIG9yIGRldGVybWluYWJsZSBmcm9tIG1pbWVUeXBlXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICB9XG59O1xuXG4vLyBjb3JlL2dlbmVyYXRlLXNwZWVjaC9nZW5lcmF0ZS1zcGVlY2gudHNcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlU3BlZWNoKHtcbiAgbW9kZWwsXG4gIHRleHQ6IHRleHQyLFxuICB2b2ljZSxcbiAgb3V0cHV0Rm9ybWF0LFxuICBpbnN0cnVjdGlvbnMsXG4gIHNwZWVkLFxuICBwcm92aWRlck9wdGlvbnMgPSB7fSxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnNcbn0pIHtcbiAgdmFyIF9hMTc7XG4gIGNvbnN0IHsgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHsgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyB9KTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgKCkgPT4gbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgIHZvaWNlLFxuICAgICAgb3V0cHV0Rm9ybWF0LFxuICAgICAgaW5zdHJ1Y3Rpb25zLFxuICAgICAgc3BlZWQsXG4gICAgICBhYm9ydFNpZ25hbCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwcm92aWRlck9wdGlvbnNcbiAgICB9KVxuICApO1xuICBpZiAoIXJlc3VsdC5hdWRpbyB8fCByZXN1bHQuYXVkaW8ubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IE5vU3BlZWNoR2VuZXJhdGVkRXJyb3IoeyByZXNwb25zZXM6IFtyZXN1bHQucmVzcG9uc2VdIH0pO1xuICB9XG4gIHJldHVybiBuZXcgRGVmYXVsdFNwZWVjaFJlc3VsdCh7XG4gICAgYXVkaW86IG5ldyBEZWZhdWx0R2VuZXJhdGVkQXVkaW9GaWxlKHtcbiAgICAgIGRhdGE6IHJlc3VsdC5hdWRpbyxcbiAgICAgIG1pbWVUeXBlOiAoX2ExNyA9IGRldGVjdE1pbWVUeXBlKHtcbiAgICAgICAgZGF0YTogcmVzdWx0LmF1ZGlvLFxuICAgICAgICBzaWduYXR1cmVzOiBhdWRpb01pbWVUeXBlU2lnbmF0dXJlc1xuICAgICAgfSkpICE9IG51bGwgPyBfYTE3IDogXCJhdWRpby9tcDNcIlxuICAgIH0pLFxuICAgIHdhcm5pbmdzOiByZXN1bHQud2FybmluZ3MsXG4gICAgcmVzcG9uc2VzOiBbcmVzdWx0LnJlc3BvbnNlXSxcbiAgICBwcm92aWRlck1ldGFkYXRhOiByZXN1bHQucHJvdmlkZXJNZXRhZGF0YVxuICB9KTtcbn1cbnZhciBEZWZhdWx0U3BlZWNoUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgdGhpcy5hdWRpbyA9IG9wdGlvbnMuYXVkaW87XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSAoX2ExNyA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9hMTcgOiB7fTtcbiAgfVxufTtcblxuLy8gZXJyb3JzL25vLXRyYW5zY3JpcHQtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxOSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgTm9UcmFuc2NyaXB0R2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxOSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkFJX05vVHJhbnNjcmlwdEdlbmVyYXRlZEVycm9yXCIsXG4gICAgICBtZXNzYWdlOiBcIk5vIHRyYW5zY3JpcHQgZ2VuZXJhdGVkLlwiXG4gICAgfSk7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgfVxufTtcblxuLy8gY29yZS90cmFuc2NyaWJlL3RyYW5zY3JpYmUudHNcbmFzeW5jIGZ1bmN0aW9uIHRyYW5zY3JpYmUoe1xuICBtb2RlbCxcbiAgYXVkaW8sXG4gIHByb3ZpZGVyT3B0aW9ucyA9IHt9LFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVyc1xufSkge1xuICBjb25zdCB7IHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7IG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcgfSk7XG4gIGNvbnN0IGF1ZGlvRGF0YSA9IGF1ZGlvIGluc3RhbmNlb2YgVVJMID8gKGF3YWl0IGRvd25sb2FkKHsgdXJsOiBhdWRpbyB9KSkuZGF0YSA6IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShhdWRpbyk7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJldHJ5KFxuICAgICgpID0+IHtcbiAgICAgIHZhciBfYTE3O1xuICAgICAgcmV0dXJuIG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICBhdWRpbzogYXVkaW9EYXRhLFxuICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICBtZWRpYVR5cGU6IChfYTE3ID0gZGV0ZWN0TWltZVR5cGUoe1xuICAgICAgICAgIGRhdGE6IGF1ZGlvRGF0YSxcbiAgICAgICAgICBzaWduYXR1cmVzOiBhdWRpb01pbWVUeXBlU2lnbmF0dXJlc1xuICAgICAgICB9KSkgIT0gbnVsbCA/IF9hMTcgOiBcImF1ZGlvL3dhdlwiXG4gICAgICB9KTtcbiAgICB9XG4gICk7XG4gIGlmICghcmVzdWx0LnRleHQpIHtcbiAgICB0aHJvdyBuZXcgTm9UcmFuc2NyaXB0R2VuZXJhdGVkRXJyb3IoeyByZXNwb25zZXM6IFtyZXN1bHQucmVzcG9uc2VdIH0pO1xuICB9XG4gIHJldHVybiBuZXcgRGVmYXVsdFRyYW5zY3JpcHRpb25SZXN1bHQoe1xuICAgIHRleHQ6IHJlc3VsdC50ZXh0LFxuICAgIHNlZ21lbnRzOiByZXN1bHQuc2VnbWVudHMsXG4gICAgbGFuZ3VhZ2U6IHJlc3VsdC5sYW5ndWFnZSxcbiAgICBkdXJhdGlvbkluU2Vjb25kczogcmVzdWx0LmR1cmF0aW9uSW5TZWNvbmRzLFxuICAgIHdhcm5pbmdzOiByZXN1bHQud2FybmluZ3MsXG4gICAgcmVzcG9uc2VzOiBbcmVzdWx0LnJlc3BvbnNlXSxcbiAgICBwcm92aWRlck1ldGFkYXRhOiByZXN1bHQucHJvdmlkZXJNZXRhZGF0YVxuICB9KTtcbn1cbnZhciBEZWZhdWx0VHJhbnNjcmlwdGlvblJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfYTE3O1xuICAgIHRoaXMudGV4dCA9IG9wdGlvbnMudGV4dDtcbiAgICB0aGlzLnNlZ21lbnRzID0gb3B0aW9ucy5zZWdtZW50cztcbiAgICB0aGlzLmxhbmd1YWdlID0gb3B0aW9ucy5sYW5ndWFnZTtcbiAgICB0aGlzLmR1cmF0aW9uSW5TZWNvbmRzID0gb3B0aW9ucy5kdXJhdGlvbkluU2Vjb25kcztcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnJlc3BvbnNlcyA9IG9wdGlvbnMucmVzcG9uc2VzO1xuICAgIHRoaXMucHJvdmlkZXJNZXRhZGF0YSA9IChfYTE3ID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2ExNyA6IHt9O1xuICB9XG59O1xuXG4vLyBjb3JlL3V0aWwvbWVyZ2Utb2JqZWN0cy50c1xuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKHRhcmdldCwgc291cmNlKSB7XG4gIGlmICh0YXJnZXQgPT09IHZvaWQgMCAmJiBzb3VyY2UgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuICBpZiAoc291cmNlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHsgLi4udGFyZ2V0IH07XG4gIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICBjb25zdCBzb3VyY2VWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgaWYgKHNvdXJjZVZhbHVlID09PSB2b2lkIDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSBrZXkgaW4gdGFyZ2V0ID8gdGFyZ2V0W2tleV0gOiB2b2lkIDA7XG4gICAgICBjb25zdCBpc1NvdXJjZU9iamVjdCA9IHNvdXJjZVZhbHVlICE9PSBudWxsICYmIHR5cGVvZiBzb3VyY2VWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShzb3VyY2VWYWx1ZSkgJiYgIShzb3VyY2VWYWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmICEoc291cmNlVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApO1xuICAgICAgY29uc3QgaXNUYXJnZXRPYmplY3QgPSB0YXJnZXRWYWx1ZSAhPT0gbnVsbCAmJiB0YXJnZXRWYWx1ZSAhPT0gdm9pZCAwICYmIHR5cGVvZiB0YXJnZXRWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh0YXJnZXRWYWx1ZSkgJiYgISh0YXJnZXRWYWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmICEodGFyZ2V0VmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApO1xuICAgICAgaWYgKGlzU291cmNlT2JqZWN0ICYmIGlzVGFyZ2V0T2JqZWN0KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2VPYmplY3RzKFxuICAgICAgICAgIHRhcmdldFZhbHVlLFxuICAgICAgICAgIHNvdXJjZVZhbHVlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZVZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBjb3JlL21pZGRsZXdhcmUvZGVmYXVsdC1zZXR0aW5ncy1taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBkZWZhdWx0U2V0dGluZ3NNaWRkbGV3YXJlKHtcbiAgc2V0dGluZ3Ncbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBtaWRkbGV3YXJlVmVyc2lvbjogXCJ2MVwiLFxuICAgIHRyYW5zZm9ybVBhcmFtczogYXN5bmMgKHsgcGFyYW1zIH0pID0+IHtcbiAgICAgIHZhciBfYTE3O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc2V0dGluZ3MsXG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVyZ2VPYmplY3RzKFxuICAgICAgICAgIHNldHRpbmdzLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgcGFyYW1zLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgKSxcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciB0ZW1wZXJhdHVyZSAwXG4gICAgICAgIC8vIFRPRE8gcmVtb3ZlIHdoZW4gdGVtcGVyYXR1cmUgZGVmYXVsdHMgdG8gdW5kZWZpbmVkXG4gICAgICAgIHRlbXBlcmF0dXJlOiBwYXJhbXMudGVtcGVyYXR1cmUgPT09IDAgfHwgcGFyYW1zLnRlbXBlcmF0dXJlID09IG51bGwgPyAoX2ExNyA9IHNldHRpbmdzLnRlbXBlcmF0dXJlKSAhPSBudWxsID8gX2ExNyA6IDAgOiBwYXJhbXMudGVtcGVyYXR1cmVcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBjb3JlL3V0aWwvZ2V0LXBvdGVudGlhbC1zdGFydC1pbmRleC50c1xuZnVuY3Rpb24gZ2V0UG90ZW50aWFsU3RhcnRJbmRleCh0ZXh0Miwgc2VhcmNoZWRUZXh0KSB7XG4gIGlmIChzZWFyY2hlZFRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZGlyZWN0SW5kZXggPSB0ZXh0Mi5pbmRleE9mKHNlYXJjaGVkVGV4dCk7XG4gIGlmIChkaXJlY3RJbmRleCAhPT0gLTEpIHtcbiAgICByZXR1cm4gZGlyZWN0SW5kZXg7XG4gIH1cbiAgZm9yIChsZXQgaSA9IHRleHQyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qgc3VmZml4ID0gdGV4dDIuc3Vic3RyaW5nKGkpO1xuICAgIGlmIChzZWFyY2hlZFRleHQuc3RhcnRzV2l0aChzdWZmaXgpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIGNvcmUvbWlkZGxld2FyZS9leHRyYWN0LXJlYXNvbmluZy1taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBleHRyYWN0UmVhc29uaW5nTWlkZGxld2FyZSh7XG4gIHRhZ05hbWUsXG4gIHNlcGFyYXRvciA9IFwiXFxuXCIsXG4gIHN0YXJ0V2l0aFJlYXNvbmluZyA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IG9wZW5pbmdUYWcgPSBgPCR7dGFnTmFtZX0+YDtcbiAgY29uc3QgY2xvc2luZ1RhZyA9IGA8LyR7dGFnTmFtZX0+YDtcbiAgcmV0dXJuIHtcbiAgICBtaWRkbGV3YXJlVmVyc2lvbjogXCJ2MVwiLFxuICAgIHdyYXBHZW5lcmF0ZTogYXN5bmMgKHsgZG9HZW5lcmF0ZSB9KSA9PiB7XG4gICAgICBjb25zdCB7IHRleHQ6IHJhd1RleHQsIC4uLnJlc3QgfSA9IGF3YWl0IGRvR2VuZXJhdGUoKTtcbiAgICAgIGlmIChyYXdUZXh0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHsgdGV4dDogcmF3VGV4dCwgLi4ucmVzdCB9O1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dDIgPSBzdGFydFdpdGhSZWFzb25pbmcgPyBvcGVuaW5nVGFnICsgcmF3VGV4dCA6IHJhd1RleHQ7XG4gICAgICBjb25zdCByZWdleHAgPSBuZXcgUmVnRXhwKGAke29wZW5pbmdUYWd9KC4qPykke2Nsb3NpbmdUYWd9YCwgXCJnc1wiKTtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSBBcnJheS5mcm9tKHRleHQyLm1hdGNoQWxsKHJlZ2V4cCkpO1xuICAgICAgaWYgKCFtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4geyB0ZXh0OiB0ZXh0MiwgLi4ucmVzdCB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcmVhc29uaW5nID0gbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiBtYXRjaFsxXSkuam9pbihzZXBhcmF0b3IpO1xuICAgICAgbGV0IHRleHRXaXRob3V0UmVhc29uaW5nID0gdGV4dDI7XG4gICAgICBmb3IgKGxldCBpID0gbWF0Y2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXNbaV07XG4gICAgICAgIGNvbnN0IGJlZm9yZU1hdGNoID0gdGV4dFdpdGhvdXRSZWFzb25pbmcuc2xpY2UoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICBjb25zdCBhZnRlck1hdGNoID0gdGV4dFdpdGhvdXRSZWFzb25pbmcuc2xpY2UoXG4gICAgICAgICAgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgKTtcbiAgICAgICAgdGV4dFdpdGhvdXRSZWFzb25pbmcgPSBiZWZvcmVNYXRjaCArIChiZWZvcmVNYXRjaC5sZW5ndGggPiAwICYmIGFmdGVyTWF0Y2gubGVuZ3RoID4gMCA/IHNlcGFyYXRvciA6IFwiXCIpICsgYWZ0ZXJNYXRjaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IC4uLnJlc3QsIHRleHQ6IHRleHRXaXRob3V0UmVhc29uaW5nLCByZWFzb25pbmcgfTtcbiAgICB9LFxuICAgIHdyYXBTdHJlYW06IGFzeW5jICh7IGRvU3RyZWFtIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgc3RyZWFtLCAuLi5yZXN0IH0gPSBhd2FpdCBkb1N0cmVhbSgpO1xuICAgICAgbGV0IGlzRmlyc3RSZWFzb25pbmcgPSB0cnVlO1xuICAgICAgbGV0IGlzRmlyc3RUZXh0ID0gdHJ1ZTtcbiAgICAgIGxldCBhZnRlclN3aXRjaCA9IGZhbHNlO1xuICAgICAgbGV0IGlzUmVhc29uaW5nID0gc3RhcnRXaXRoUmVhc29uaW5nO1xuICAgICAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHJlYW06IHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjaHVuay50eXBlICE9PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJ1ZmZlciArPSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHB1Ymxpc2godGV4dDIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dDIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYWZ0ZXJTd2l0Y2ggJiYgKGlzUmVhc29uaW5nID8gIWlzRmlyc3RSZWFzb25pbmcgOiAhaXNGaXJzdFRleHQpID8gc2VwYXJhdG9yIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGlzUmVhc29uaW5nID8gXCJyZWFzb25pbmdcIiA6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IHByZWZpeCArIHRleHQyXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGFmdGVyU3dpdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNSZWFzb25pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdFJlYXNvbmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdFRleHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUYWcgPSBpc1JlYXNvbmluZyA/IGNsb3NpbmdUYWcgOiBvcGVuaW5nVGFnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBnZXRQb3RlbnRpYWxTdGFydEluZGV4KGJ1ZmZlciwgbmV4dFRhZyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcHVibGlzaChidWZmZXIpO1xuICAgICAgICAgICAgICAgICAgYnVmZmVyID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwdWJsaXNoKGJ1ZmZlci5zbGljZSgwLCBzdGFydEluZGV4KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmRGdWxsTWF0Y2ggPSBzdGFydEluZGV4ICsgbmV4dFRhZy5sZW5ndGggPD0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRGdWxsTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShzdGFydEluZGV4ICsgbmV4dFRhZy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgaXNSZWFzb25pbmcgPSAhaXNSZWFzb25pbmc7XG4gICAgICAgICAgICAgICAgICBhZnRlclN3aXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShzdGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKSxcbiAgICAgICAgLi4ucmVzdFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIGNvcmUvbWlkZGxld2FyZS9zaW11bGF0ZS1zdHJlYW1pbmctbWlkZGxld2FyZS50c1xuZnVuY3Rpb24gc2ltdWxhdGVTdHJlYW1pbmdNaWRkbGV3YXJlKCkge1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmVWZXJzaW9uOiBcInYxXCIsXG4gICAgd3JhcFN0cmVhbTogYXN5bmMgKHsgZG9HZW5lcmF0ZSB9KSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkb0dlbmVyYXRlKCk7XG4gICAgICBjb25zdCBzaW11bGF0ZWRTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJyZXNwb25zZS1tZXRhZGF0YVwiLCAuLi5yZXN1bHQucmVzcG9uc2UgfSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5yZWFzb25pbmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0LnJlYXNvbmluZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgICAgdGV4dERlbHRhOiByZXN1bHQucmVhc29uaW5nXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCByZWFzb25pbmcgb2YgcmVzdWx0LnJlYXNvbmluZykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocmVhc29uaW5nLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgIHRleHREZWx0YTogcmVhc29uaW5nLnRleHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWFzb25pbmcuc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctc2lnbmF0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHJlYXNvbmluZy5zaWduYXR1cmVcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWRhY3RlZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWRhY3RlZC1yZWFzb25pbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiByZWFzb25pbmcuZGF0YVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQudGV4dCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgIHRleHREZWx0YTogcmVzdWx0LnRleHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0LnRvb2xDYWxscykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiByZXN1bHQudG9vbENhbGxzKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGwtZGVsdGFcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbFR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhcmdzVGV4dERlbHRhOiB0b29sQ2FsbC5hcmdzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgICAgICAgLi4udG9vbENhbGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgZmluaXNoUmVhc29uOiByZXN1bHQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgdXNhZ2U6IHJlc3VsdC51c2FnZSxcbiAgICAgICAgICAgIGxvZ3Byb2JzOiByZXN1bHQubG9ncHJvYnMsXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiByZXN1bHQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHJlYW06IHNpbXVsYXRlZFN0cmVhbSxcbiAgICAgICAgcmF3Q2FsbDogcmVzdWx0LnJhd0NhbGwsXG4gICAgICAgIHJhd1Jlc3BvbnNlOiByZXN1bHQucmF3UmVzcG9uc2UsXG4gICAgICAgIHdhcm5pbmdzOiByZXN1bHQud2FybmluZ3NcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBjb3JlL21pZGRsZXdhcmUvd3JhcC1sYW5ndWFnZS1tb2RlbC50c1xudmFyIHdyYXBMYW5ndWFnZU1vZGVsID0gKHtcbiAgbW9kZWwsXG4gIG1pZGRsZXdhcmU6IG1pZGRsZXdhcmVBcmcsXG4gIG1vZGVsSWQsXG4gIHByb3ZpZGVySWRcbn0pID0+IHtcbiAgcmV0dXJuIGFzQXJyYXkobWlkZGxld2FyZUFyZykucmV2ZXJzZSgpLnJlZHVjZSgod3JhcHBlZE1vZGVsLCBtaWRkbGV3YXJlKSA9PiB7XG4gICAgcmV0dXJuIGRvV3JhcCh7IG1vZGVsOiB3cmFwcGVkTW9kZWwsIG1pZGRsZXdhcmUsIG1vZGVsSWQsIHByb3ZpZGVySWQgfSk7XG4gIH0sIG1vZGVsKTtcbn07XG52YXIgZG9XcmFwID0gKHtcbiAgbW9kZWwsXG4gIG1pZGRsZXdhcmU6IHsgdHJhbnNmb3JtUGFyYW1zLCB3cmFwR2VuZXJhdGUsIHdyYXBTdHJlYW0gfSxcbiAgbW9kZWxJZCxcbiAgcHJvdmlkZXJJZFxufSkgPT4ge1xuICB2YXIgX2ExNztcbiAgYXN5bmMgZnVuY3Rpb24gZG9UcmFuc2Zvcm0oe1xuICAgIHBhcmFtcyxcbiAgICB0eXBlXG4gIH0pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtUGFyYW1zID8gYXdhaXQgdHJhbnNmb3JtUGFyYW1zKHsgcGFyYW1zLCB0eXBlIH0pIDogcGFyYW1zO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3BlY2lmaWNhdGlvblZlcnNpb246IFwidjFcIixcbiAgICBwcm92aWRlcjogcHJvdmlkZXJJZCAhPSBudWxsID8gcHJvdmlkZXJJZCA6IG1vZGVsLnByb3ZpZGVyLFxuICAgIG1vZGVsSWQ6IG1vZGVsSWQgIT0gbnVsbCA/IG1vZGVsSWQgOiBtb2RlbC5tb2RlbElkLFxuICAgIGRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZTogbW9kZWwuZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlLFxuICAgIHN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJscyxcbiAgICBzdXBwb3J0c1VybDogKF9hMTcgPSBtb2RlbC5zdXBwb3J0c1VybCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuYmluZChtb2RlbCksXG4gICAgc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0czogbW9kZWwuc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyxcbiAgICBhc3luYyBkb0dlbmVyYXRlKHBhcmFtcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCBkb1RyYW5zZm9ybSh7IHBhcmFtcywgdHlwZTogXCJnZW5lcmF0ZVwiIH0pO1xuICAgICAgY29uc3QgZG9HZW5lcmF0ZSA9IGFzeW5jICgpID0+IG1vZGVsLmRvR2VuZXJhdGUodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgY29uc3QgZG9TdHJlYW0gPSBhc3luYyAoKSA9PiBtb2RlbC5kb1N0cmVhbSh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICByZXR1cm4gd3JhcEdlbmVyYXRlID8gd3JhcEdlbmVyYXRlKHtcbiAgICAgICAgZG9HZW5lcmF0ZSxcbiAgICAgICAgZG9TdHJlYW0sXG4gICAgICAgIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsXG4gICAgICAgIG1vZGVsXG4gICAgICB9KSA6IGRvR2VuZXJhdGUoKTtcbiAgICB9LFxuICAgIGFzeW5jIGRvU3RyZWFtKHBhcmFtcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCBkb1RyYW5zZm9ybSh7IHBhcmFtcywgdHlwZTogXCJzdHJlYW1cIiB9KTtcbiAgICAgIGNvbnN0IGRvR2VuZXJhdGUgPSBhc3luYyAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgIGNvbnN0IGRvU3RyZWFtID0gYXN5bmMgKCkgPT4gbW9kZWwuZG9TdHJlYW0odHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBTdHJlYW0gPyB3cmFwU3RyZWFtKHsgZG9HZW5lcmF0ZSwgZG9TdHJlYW0sIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsIG1vZGVsIH0pIDogZG9TdHJlYW0oKTtcbiAgICB9XG4gIH07XG59O1xudmFyIGV4cGVyaW1lbnRhbF93cmFwTGFuZ3VhZ2VNb2RlbCA9IHdyYXBMYW5ndWFnZU1vZGVsO1xuXG4vLyBjb3JlL3Byb21wdC9hcHBlbmQtY2xpZW50LW1lc3NhZ2UudHNcbmZ1bmN0aW9uIGFwcGVuZENsaWVudE1lc3NhZ2Uoe1xuICBtZXNzYWdlcyxcbiAgbWVzc2FnZVxufSkge1xuICByZXR1cm4gW1xuICAgIC4uLm1lc3NhZ2VzLmxlbmd0aCA+IDAgJiYgbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0uaWQgPT09IG1lc3NhZ2UuaWQgPyBtZXNzYWdlcy5zbGljZSgwLCAtMSkgOiBtZXNzYWdlcyxcbiAgICBtZXNzYWdlXG4gIF07XG59XG5cbi8vIGNvcmUvcHJvbXB0L2FwcGVuZC1yZXNwb25zZS1tZXNzYWdlcy50c1xuaW1wb3J0IHtcbiAgZXh0cmFjdE1heFRvb2xJbnZvY2F0aW9uU3RlcFxufSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMjAgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gYXBwZW5kUmVzcG9uc2VNZXNzYWdlcyh7XG4gIG1lc3NhZ2VzLFxuICByZXNwb25zZU1lc3NhZ2VzLFxuICBfaW50ZXJuYWw6IHsgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSB9ID0ge31cbn0pIHtcbiAgdmFyIF9hMTcsIF9iLCBfYywgX2Q7XG4gIGNvbnN0IGNsb25lZE1lc3NhZ2VzID0gc3RydWN0dXJlZENsb25lKG1lc3NhZ2VzKTtcbiAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHJlc3BvbnNlTWVzc2FnZXMpIHtcbiAgICBjb25zdCByb2xlID0gbWVzc2FnZS5yb2xlO1xuICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gY2xvbmVkTWVzc2FnZXNbY2xvbmVkTWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgaXNMYXN0TWVzc2FnZUFzc2lzdGFudCA9IGxhc3RNZXNzYWdlLnJvbGUgPT09IFwiYXNzaXN0YW50XCI7XG4gICAgc3dpdGNoIChyb2xlKSB7XG4gICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgbGV0IGdldFRvb2xJbnZvY2F0aW9uczIgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgICAgICAgcmV0dXJuICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiID8gW10gOiBtZXNzYWdlLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCIpKS5tYXAoKGNhbGwpID0+ICh7XG4gICAgICAgICAgICBzdGF0ZTogXCJjYWxsXCIsXG4gICAgICAgICAgICBzdGVwLFxuICAgICAgICAgICAgYXJnczogY2FsbC5hcmdzLFxuICAgICAgICAgICAgdG9vbENhbGxJZDogY2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgdG9vbE5hbWU6IGNhbGwudG9vbE5hbWVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRUb29sSW52b2NhdGlvbnMgPSBnZXRUb29sSW52b2NhdGlvbnMyO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IFt7IHR5cGU6IFwic3RlcC1zdGFydFwiIH1dO1xuICAgICAgICBsZXQgdGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICBsZXQgcmVhc29uaW5nVGV4dENvbnRlbnQgPSB2b2lkIDA7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGV4dENvbnRlbnQgPSBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHRleHQ6IG1lc3NhZ2UuY29udGVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCByZWFzb25pbmdQYXJ0ID0gdm9pZCAwO1xuICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBtZXNzYWdlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICByZWFzb25pbmdQYXJ0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRleHRDb250ZW50ICs9IHBhcnQudGV4dDtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZ1wiOiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlYXNvbmluZ1BhcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmVhc29uaW5nUGFydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uaW5nOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBbXVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocmVhc29uaW5nUGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlYXNvbmluZ1RleHRDb250ZW50ID0gKHJlYXNvbmluZ1RleHRDb250ZW50ICE9IG51bGwgPyByZWFzb25pbmdUZXh0Q29udGVudCA6IFwiXCIpICsgcGFydC50ZXh0O1xuICAgICAgICAgICAgICAgIHJlYXNvbmluZ1BhcnQucmVhc29uaW5nICs9IHBhcnQudGV4dDtcbiAgICAgICAgICAgICAgICByZWFzb25pbmdQYXJ0LmRldGFpbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogcGFydC5zaWduYXR1cmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwicmVkYWN0ZWQtcmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBpZiAocmVhc29uaW5nUGFydCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZWFzb25pbmdQYXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb25pbmc6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IFtdXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgcGFydHMucHVzaChyZWFzb25pbmdQYXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVhc29uaW5nUGFydC5kZXRhaWxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWRhY3RlZFwiLFxuICAgICAgICAgICAgICAgICAgZGF0YTogcGFydC5kYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgICAgICAgICAgIGlmIChwYXJ0LmRhdGEgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBSVNES0Vycm9yMjAoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkludmFsaWRBc3Npc3RhbnRGaWxlRGF0YVwiLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkZpbGUgZGF0YSBjYW5ub3QgYmUgYSBVUkxcIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgICBtaW1lVHlwZTogcGFydC5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nKHBhcnQuZGF0YSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGFzdE1lc3NhZ2VBc3Npc3RhbnQpIHtcbiAgICAgICAgICBjb25zdCBtYXhTdGVwID0gZXh0cmFjdE1heFRvb2xJbnZvY2F0aW9uU3RlcChcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlLnRvb2xJbnZvY2F0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgKF9hMTcgPSBsYXN0TWVzc2FnZS5wYXJ0cykgIT0gbnVsbCA/IF9hMTcgOiBsYXN0TWVzc2FnZS5wYXJ0cyA9IFtdO1xuICAgICAgICAgIGxhc3RNZXNzYWdlLmNvbnRlbnQgPSB0ZXh0Q29udGVudDtcbiAgICAgICAgICBsYXN0TWVzc2FnZS5yZWFzb25pbmcgPSByZWFzb25pbmdUZXh0Q29udGVudDtcbiAgICAgICAgICBsYXN0TWVzc2FnZS5wYXJ0cy5wdXNoKC4uLnBhcnRzKTtcbiAgICAgICAgICBsYXN0TWVzc2FnZS50b29sSW52b2NhdGlvbnMgPSBbXG4gICAgICAgICAgICAuLi4oX2IgPSBsYXN0TWVzc2FnZS50b29sSW52b2NhdGlvbnMpICE9IG51bGwgPyBfYiA6IFtdLFxuICAgICAgICAgICAgLi4uZ2V0VG9vbEludm9jYXRpb25zMihtYXhTdGVwID09PSB2b2lkIDAgPyAwIDogbWF4U3RlcCArIDEpXG4gICAgICAgICAgXTtcbiAgICAgICAgICBnZXRUb29sSW52b2NhdGlvbnMyKG1heFN0ZXAgPT09IHZvaWQgMCA/IDAgOiBtYXhTdGVwICsgMSkubWFwKChjYWxsKSA9PiAoe1xuICAgICAgICAgICAgdHlwZTogXCJ0b29sLWludm9jYXRpb25cIixcbiAgICAgICAgICAgIHRvb2xJbnZvY2F0aW9uOiBjYWxsXG4gICAgICAgICAgfSkpLmZvckVhY2goKHBhcnQpID0+IHtcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlLnBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvbmVkTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgaWQ6IG1lc3NhZ2UuaWQsXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IGN1cnJlbnREYXRlKCksXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBhIGNyZWF0ZWRBdCBkYXRlIGZvciB0aGUgbWVzc2FnZSwgd2lsbCBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjbGllbnRcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRleHRDb250ZW50LFxuICAgICAgICAgICAgcmVhc29uaW5nOiByZWFzb25pbmdUZXh0Q29udGVudCxcbiAgICAgICAgICAgIHRvb2xJbnZvY2F0aW9uczogZ2V0VG9vbEludm9jYXRpb25zMigwKSxcbiAgICAgICAgICAgIHBhcnRzOiBbXG4gICAgICAgICAgICAgIC4uLnBhcnRzLFxuICAgICAgICAgICAgICAuLi5nZXRUb29sSW52b2NhdGlvbnMyKDApLm1hcCgoY2FsbCkgPT4gKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtaW52b2NhdGlvblwiLFxuICAgICAgICAgICAgICAgIHRvb2xJbnZvY2F0aW9uOiBjYWxsXG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICAoX2MgPSBsYXN0TWVzc2FnZS50b29sSW52b2NhdGlvbnMpICE9IG51bGwgPyBfYyA6IGxhc3RNZXNzYWdlLnRvb2xJbnZvY2F0aW9ucyA9IFtdO1xuICAgICAgICBpZiAobGFzdE1lc3NhZ2Uucm9sZSAhPT0gXCJhc3Npc3RhbnRcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBUb29sIHJlc3VsdCBtdXN0IGZvbGxvdyBhbiBhc3Npc3RhbnQgbWVzc2FnZTogJHtsYXN0TWVzc2FnZS5yb2xlfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIChfZCA9IGxhc3RNZXNzYWdlLnBhcnRzKSAhPSBudWxsID8gX2QgOiBsYXN0TWVzc2FnZS5wYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnRlbnRQYXJ0IG9mIG1lc3NhZ2UuY29udGVudCkge1xuICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gbGFzdE1lc3NhZ2UudG9vbEludm9jYXRpb25zLmZpbmQoXG4gICAgICAgICAgICAoY2FsbCkgPT4gY2FsbC50b29sQ2FsbElkID09PSBjb250ZW50UGFydC50b29sQ2FsbElkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCB0b29sQ2FsbFBhcnQgPSBsYXN0TWVzc2FnZS5wYXJ0cy5maW5kKFxuICAgICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0b29sLWludm9jYXRpb25cIiAmJiBwYXJ0LnRvb2xJbnZvY2F0aW9uLnRvb2xDYWxsSWQgPT09IGNvbnRlbnRQYXJ0LnRvb2xDYWxsSWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghdG9vbENhbGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvb2wgY2FsbCBub3QgZm91bmQgaW4gcHJldmlvdXMgbWVzc2FnZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9vbENhbGwuc3RhdGUgPSBcInJlc3VsdFwiO1xuICAgICAgICAgIGNvbnN0IHRvb2xSZXN1bHQgPSB0b29sQ2FsbDtcbiAgICAgICAgICB0b29sUmVzdWx0LnJlc3VsdCA9IGNvbnRlbnRQYXJ0LnJlc3VsdDtcbiAgICAgICAgICBpZiAodG9vbENhbGxQYXJ0KSB7XG4gICAgICAgICAgICB0b29sQ2FsbFBhcnQudG9vbEludm9jYXRpb24gPSB0b29sUmVzdWx0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0TWVzc2FnZS5wYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWludm9jYXRpb25cIixcbiAgICAgICAgICAgICAgdG9vbEludm9jYXRpb246IHRvb2xSZXN1bHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHJvbGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbWVzc2FnZSByb2xlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjbG9uZWRNZXNzYWdlcztcbn1cblxuLy8gY29yZS9yZWdpc3RyeS9jdXN0b20tcHJvdmlkZXIudHNcbmltcG9ydCB7IE5vU3VjaE1vZGVsRXJyb3IgYXMgTm9TdWNoTW9kZWxFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gY3VzdG9tUHJvdmlkZXIoe1xuICBsYW5ndWFnZU1vZGVscyxcbiAgdGV4dEVtYmVkZGluZ01vZGVscyxcbiAgaW1hZ2VNb2RlbHMsXG4gIGZhbGxiYWNrUHJvdmlkZXJcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBsYW5ndWFnZU1vZGVsKG1vZGVsSWQpIHtcbiAgICAgIGlmIChsYW5ndWFnZU1vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gbGFuZ3VhZ2VNb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlTW9kZWxzW21vZGVsSWRdO1xuICAgICAgfVxuICAgICAgaWYgKGZhbGxiYWNrUHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUHJvdmlkZXIubGFuZ3VhZ2VNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJsYW5ndWFnZU1vZGVsXCIgfSk7XG4gICAgfSxcbiAgICB0ZXh0RW1iZWRkaW5nTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKHRleHRFbWJlZGRpbmdNb2RlbHMgIT0gbnVsbCAmJiBtb2RlbElkIGluIHRleHRFbWJlZGRpbmdNb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIHRleHRFbWJlZGRpbmdNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci50ZXh0RW1iZWRkaW5nTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwidGV4dEVtYmVkZGluZ01vZGVsXCIgfSk7XG4gICAgfSxcbiAgICBpbWFnZU1vZGVsKG1vZGVsSWQpIHtcbiAgICAgIGlmIChpbWFnZU1vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gaW1hZ2VNb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIGltYWdlTW9kZWxzW21vZGVsSWRdO1xuICAgICAgfVxuICAgICAgaWYgKGZhbGxiYWNrUHJvdmlkZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGZhbGxiYWNrUHJvdmlkZXIuaW1hZ2VNb2RlbCkge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci5pbWFnZU1vZGVsKG1vZGVsSWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3IyKHsgbW9kZWxJZCwgbW9kZWxUeXBlOiBcImltYWdlTW9kZWxcIiB9KTtcbiAgICB9XG4gIH07XG59XG52YXIgZXhwZXJpbWVudGFsX2N1c3RvbVByb3ZpZGVyID0gY3VzdG9tUHJvdmlkZXI7XG5cbi8vIGNvcmUvcmVnaXN0cnkvbm8tc3VjaC1wcm92aWRlci1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMjEsIE5vU3VjaE1vZGVsRXJyb3IgYXMgTm9TdWNoTW9kZWxFcnJvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxNiA9IFwiQUlfTm9TdWNoUHJvdmlkZXJFcnJvclwiO1xudmFyIG1hcmtlcjE2ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxNn1gO1xudmFyIHN5bWJvbDE2ID0gU3ltYm9sLmZvcihtYXJrZXIxNik7XG52YXIgX2ExNjtcbnZhciBOb1N1Y2hQcm92aWRlckVycm9yID0gY2xhc3MgZXh0ZW5kcyBOb1N1Y2hNb2RlbEVycm9yMyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtb2RlbElkLFxuICAgIG1vZGVsVHlwZSxcbiAgICBwcm92aWRlcklkLFxuICAgIGF2YWlsYWJsZVByb3ZpZGVycyxcbiAgICBtZXNzYWdlID0gYE5vIHN1Y2ggcHJvdmlkZXI6ICR7cHJvdmlkZXJJZH0gKGF2YWlsYWJsZSBwcm92aWRlcnM6ICR7YXZhaWxhYmxlUHJvdmlkZXJzLmpvaW4oKX0pYFxuICB9KSB7XG4gICAgc3VwZXIoeyBlcnJvck5hbWU6IG5hbWUxNiwgbW9kZWxJZCwgbW9kZWxUeXBlLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExNl0gPSB0cnVlO1xuICAgIHRoaXMucHJvdmlkZXJJZCA9IHByb3ZpZGVySWQ7XG4gICAgdGhpcy5hdmFpbGFibGVQcm92aWRlcnMgPSBhdmFpbGFibGVQcm92aWRlcnM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjIxLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTYpO1xuICB9XG59O1xuX2ExNiA9IHN5bWJvbDE2O1xuXG4vLyBjb3JlL3JlZ2lzdHJ5L3Byb3ZpZGVyLXJlZ2lzdHJ5LnRzXG5pbXBvcnQgeyBOb1N1Y2hNb2RlbEVycm9yIGFzIE5vU3VjaE1vZGVsRXJyb3I0IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGNyZWF0ZVByb3ZpZGVyUmVnaXN0cnkocHJvdmlkZXJzLCB7XG4gIHNlcGFyYXRvciA9IFwiOlwiXG59ID0ge30pIHtcbiAgY29uc3QgcmVnaXN0cnkgPSBuZXcgRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkoe1xuICAgIHNlcGFyYXRvclxuICB9KTtcbiAgZm9yIChjb25zdCBbaWQsIHByb3ZpZGVyXSBvZiBPYmplY3QuZW50cmllcyhwcm92aWRlcnMpKSB7XG4gICAgcmVnaXN0cnkucmVnaXN0ZXJQcm92aWRlcih7IGlkLCBwcm92aWRlciB9KTtcbiAgfVxuICByZXR1cm4gcmVnaXN0cnk7XG59XG52YXIgZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnkgPSBjcmVhdGVQcm92aWRlclJlZ2lzdHJ5O1xudmFyIERlZmF1bHRQcm92aWRlclJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7IHNlcGFyYXRvciB9KSB7XG4gICAgdGhpcy5wcm92aWRlcnMgPSB7fTtcbiAgICB0aGlzLnNlcGFyYXRvciA9IHNlcGFyYXRvcjtcbiAgfVxuICByZWdpc3RlclByb3ZpZGVyKHtcbiAgICBpZCxcbiAgICBwcm92aWRlclxuICB9KSB7XG4gICAgdGhpcy5wcm92aWRlcnNbaWRdID0gcHJvdmlkZXI7XG4gIH1cbiAgZ2V0UHJvdmlkZXIoaWQpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucHJvdmlkZXJzW2lkXTtcbiAgICBpZiAocHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaFByb3ZpZGVyRXJyb3Ioe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlOiBcImxhbmd1YWdlTW9kZWxcIixcbiAgICAgICAgcHJvdmlkZXJJZDogaWQsXG4gICAgICAgIGF2YWlsYWJsZVByb3ZpZGVyczogT2JqZWN0LmtleXModGhpcy5wcm92aWRlcnMpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3ZpZGVyO1xuICB9XG4gIHNwbGl0SWQoaWQsIG1vZGVsVHlwZSkge1xuICAgIGNvbnN0IGluZGV4ID0gaWQuaW5kZXhPZih0aGlzLnNlcGFyYXRvcik7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3I0KHtcbiAgICAgICAgbW9kZWxJZDogaWQsXG4gICAgICAgIG1vZGVsVHlwZSxcbiAgICAgICAgbWVzc2FnZTogYEludmFsaWQgJHttb2RlbFR5cGV9IGlkIGZvciByZWdpc3RyeTogJHtpZH0gKG11c3QgYmUgaW4gdGhlIGZvcm1hdCBcInByb3ZpZGVySWQke3RoaXMuc2VwYXJhdG9yfW1vZGVsSWRcIilgXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFtpZC5zbGljZSgwLCBpbmRleCksIGlkLnNsaWNlKGluZGV4ICsgdGhpcy5zZXBhcmF0b3IubGVuZ3RoKV07XG4gIH1cbiAgbGFuZ3VhZ2VNb2RlbChpZCkge1xuICAgIHZhciBfYTE3LCBfYjtcbiAgICBjb25zdCBbcHJvdmlkZXJJZCwgbW9kZWxJZF0gPSB0aGlzLnNwbGl0SWQoaWQsIFwibGFuZ3VhZ2VNb2RlbFwiKTtcbiAgICBjb25zdCBtb2RlbCA9IChfYiA9IChfYTE3ID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkKSkubGFuZ3VhZ2VNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2ExNywgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7IG1vZGVsSWQ6IGlkLCBtb2RlbFR5cGU6IFwibGFuZ3VhZ2VNb2RlbFwiIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgdGV4dEVtYmVkZGluZ01vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcInRleHRFbWJlZGRpbmdNb2RlbFwiKTtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJvdmlkZXJJZCk7XG4gICAgY29uc3QgbW9kZWwgPSAoX2ExNyA9IHByb3ZpZGVyLnRleHRFbWJlZGRpbmdNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGU6IFwidGV4dEVtYmVkZGluZ01vZGVsXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgaW1hZ2VNb2RlbChpZCkge1xuICAgIHZhciBfYTE3O1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCwgXCJpbWFnZU1vZGVsXCIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkKTtcbiAgICBjb25zdCBtb2RlbCA9IChfYTE3ID0gcHJvdmlkZXIuaW1hZ2VNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7IG1vZGVsSWQ6IGlkLCBtb2RlbFR5cGU6IFwiaW1hZ2VNb2RlbFwiIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbn07XG5cbi8vIGNvcmUvdG9vbC9tY3AvbWNwLWNsaWVudC50c1xuaW1wb3J0IHsganNvblNjaGVtYSB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIGNvcmUvdG9vbC90b29sLnRzXG5mdW5jdGlvbiB0b29sKHRvb2wyKSB7XG4gIHJldHVybiB0b29sMjtcbn1cblxuLy8gY29yZS90b29sL21jcC9tY3Atc3NlLXRyYW5zcG9ydC50c1xuaW1wb3J0IHsgY3JlYXRlRXZlbnRTb3VyY2VQYXJzZXJTdHJlYW0gfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBjb3JlL3Rvb2wvbWNwL2pzb24tcnBjLW1lc3NhZ2UudHNcbmltcG9ydCB7IHogYXMgejkgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvdG9vbC9tY3AvdHlwZXMudHNcbmltcG9ydCB7IHogYXMgejggfSBmcm9tIFwiem9kXCI7XG52YXIgTEFURVNUX1BST1RPQ09MX1ZFUlNJT04gPSBcIjIwMjQtMTEtMDVcIjtcbnZhciBTVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTlMgPSBbXG4gIExBVEVTVF9QUk9UT0NPTF9WRVJTSU9OLFxuICBcIjIwMjQtMTAtMDdcIlxuXTtcbnZhciBDbGllbnRPclNlcnZlckltcGxlbWVudGF0aW9uU2NoZW1hID0gejgub2JqZWN0KHtcbiAgbmFtZTogejguc3RyaW5nKCksXG4gIHZlcnNpb246IHo4LnN0cmluZygpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIEJhc2VQYXJhbXNTY2hlbWEgPSB6OC5vYmplY3Qoe1xuICBfbWV0YTogejgub3B0aW9uYWwoejgub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKVxufSkucGFzc3Rocm91Z2goKTtcbnZhciBSZXN1bHRTY2hlbWEgPSBCYXNlUGFyYW1zU2NoZW1hO1xudmFyIFJlcXVlc3RTY2hlbWEgPSB6OC5vYmplY3Qoe1xuICBtZXRob2Q6IHo4LnN0cmluZygpLFxuICBwYXJhbXM6IHo4Lm9wdGlvbmFsKEJhc2VQYXJhbXNTY2hlbWEpXG59KTtcbnZhciBTZXJ2ZXJDYXBhYmlsaXRpZXNTY2hlbWEgPSB6OC5vYmplY3Qoe1xuICBleHBlcmltZW50YWw6IHo4Lm9wdGlvbmFsKHo4Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSksXG4gIGxvZ2dpbmc6IHo4Lm9wdGlvbmFsKHo4Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSksXG4gIHByb21wdHM6IHo4Lm9wdGlvbmFsKFxuICAgIHo4Lm9iamVjdCh7XG4gICAgICBsaXN0Q2hhbmdlZDogejgub3B0aW9uYWwoejguYm9vbGVhbigpKVxuICAgIH0pLnBhc3N0aHJvdWdoKClcbiAgKSxcbiAgcmVzb3VyY2VzOiB6OC5vcHRpb25hbChcbiAgICB6OC5vYmplY3Qoe1xuICAgICAgc3Vic2NyaWJlOiB6OC5vcHRpb25hbCh6OC5ib29sZWFuKCkpLFxuICAgICAgbGlzdENoYW5nZWQ6IHo4Lm9wdGlvbmFsKHo4LmJvb2xlYW4oKSlcbiAgICB9KS5wYXNzdGhyb3VnaCgpXG4gICksXG4gIHRvb2xzOiB6OC5vcHRpb25hbChcbiAgICB6OC5vYmplY3Qoe1xuICAgICAgbGlzdENoYW5nZWQ6IHo4Lm9wdGlvbmFsKHo4LmJvb2xlYW4oKSlcbiAgICB9KS5wYXNzdGhyb3VnaCgpXG4gIClcbn0pLnBhc3N0aHJvdWdoKCk7XG52YXIgSW5pdGlhbGl6ZVJlc3VsdFNjaGVtYSA9IFJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICBwcm90b2NvbFZlcnNpb246IHo4LnN0cmluZygpLFxuICBjYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllc1NjaGVtYSxcbiAgc2VydmVySW5mbzogQ2xpZW50T3JTZXJ2ZXJJbXBsZW1lbnRhdGlvblNjaGVtYSxcbiAgaW5zdHJ1Y3Rpb25zOiB6OC5vcHRpb25hbCh6OC5zdHJpbmcoKSlcbn0pO1xudmFyIFBhZ2luYXRlZFJlc3VsdFNjaGVtYSA9IFJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICBuZXh0Q3Vyc29yOiB6OC5vcHRpb25hbCh6OC5zdHJpbmcoKSlcbn0pO1xudmFyIFRvb2xTY2hlbWEgPSB6OC5vYmplY3Qoe1xuICBuYW1lOiB6OC5zdHJpbmcoKSxcbiAgZGVzY3JpcHRpb246IHo4Lm9wdGlvbmFsKHo4LnN0cmluZygpKSxcbiAgaW5wdXRTY2hlbWE6IHo4Lm9iamVjdCh7XG4gICAgdHlwZTogejgubGl0ZXJhbChcIm9iamVjdFwiKSxcbiAgICBwcm9wZXJ0aWVzOiB6OC5vcHRpb25hbCh6OC5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpXG4gIH0pLnBhc3N0aHJvdWdoKClcbn0pLnBhc3N0aHJvdWdoKCk7XG52YXIgTGlzdFRvb2xzUmVzdWx0U2NoZW1hID0gUGFnaW5hdGVkUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gIHRvb2xzOiB6OC5hcnJheShUb29sU2NoZW1hKVxufSk7XG52YXIgVGV4dENvbnRlbnRTY2hlbWEgPSB6OC5vYmplY3Qoe1xuICB0eXBlOiB6OC5saXRlcmFsKFwidGV4dFwiKSxcbiAgdGV4dDogejguc3RyaW5nKClcbn0pLnBhc3N0aHJvdWdoKCk7XG52YXIgSW1hZ2VDb250ZW50U2NoZW1hID0gejgub2JqZWN0KHtcbiAgdHlwZTogejgubGl0ZXJhbChcImltYWdlXCIpLFxuICBkYXRhOiB6OC5zdHJpbmcoKS5iYXNlNjQoKSxcbiAgbWltZVR5cGU6IHo4LnN0cmluZygpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIFJlc291cmNlQ29udGVudHNTY2hlbWEgPSB6OC5vYmplY3Qoe1xuICAvKipcbiAgICogVGhlIFVSSSBvZiB0aGlzIHJlc291cmNlLlxuICAgKi9cbiAgdXJpOiB6OC5zdHJpbmcoKSxcbiAgLyoqXG4gICAqIFRoZSBNSU1FIHR5cGUgb2YgdGhpcyByZXNvdXJjZSwgaWYga25vd24uXG4gICAqL1xuICBtaW1lVHlwZTogejgub3B0aW9uYWwoejguc3RyaW5nKCkpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIFRleHRSZXNvdXJjZUNvbnRlbnRzU2NoZW1hID0gUmVzb3VyY2VDb250ZW50c1NjaGVtYS5leHRlbmQoe1xuICB0ZXh0OiB6OC5zdHJpbmcoKVxufSk7XG52YXIgQmxvYlJlc291cmNlQ29udGVudHNTY2hlbWEgPSBSZXNvdXJjZUNvbnRlbnRzU2NoZW1hLmV4dGVuZCh7XG4gIGJsb2I6IHo4LnN0cmluZygpLmJhc2U2NCgpXG59KTtcbnZhciBFbWJlZGRlZFJlc291cmNlU2NoZW1hID0gejgub2JqZWN0KHtcbiAgdHlwZTogejgubGl0ZXJhbChcInJlc291cmNlXCIpLFxuICByZXNvdXJjZTogejgudW5pb24oW1RleHRSZXNvdXJjZUNvbnRlbnRzU2NoZW1hLCBCbG9iUmVzb3VyY2VDb250ZW50c1NjaGVtYV0pXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIENhbGxUb29sUmVzdWx0U2NoZW1hID0gUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gIGNvbnRlbnQ6IHo4LmFycmF5KFxuICAgIHo4LnVuaW9uKFtUZXh0Q29udGVudFNjaGVtYSwgSW1hZ2VDb250ZW50U2NoZW1hLCBFbWJlZGRlZFJlc291cmNlU2NoZW1hXSlcbiAgKSxcbiAgaXNFcnJvcjogejguYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpLm9wdGlvbmFsKClcbn0pLm9yKFxuICBSZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgICB0b29sUmVzdWx0OiB6OC51bmtub3duKClcbiAgfSlcbik7XG5cbi8vIGNvcmUvdG9vbC9tY3AvanNvbi1ycGMtbWVzc2FnZS50c1xudmFyIEpTT05SUENfVkVSU0lPTiA9IFwiMi4wXCI7XG52YXIgSlNPTlJQQ1JlcXVlc3RTY2hlbWEgPSB6OS5vYmplY3Qoe1xuICBqc29ucnBjOiB6OS5saXRlcmFsKEpTT05SUENfVkVSU0lPTiksXG4gIGlkOiB6OS51bmlvbihbejkuc3RyaW5nKCksIHo5Lm51bWJlcigpLmludCgpXSlcbn0pLm1lcmdlKFJlcXVlc3RTY2hlbWEpLnN0cmljdCgpO1xudmFyIEpTT05SUENSZXNwb25zZVNjaGVtYSA9IHo5Lm9iamVjdCh7XG4gIGpzb25ycGM6IHo5LmxpdGVyYWwoSlNPTlJQQ19WRVJTSU9OKSxcbiAgaWQ6IHo5LnVuaW9uKFt6OS5zdHJpbmcoKSwgejkubnVtYmVyKCkuaW50KCldKSxcbiAgcmVzdWx0OiBSZXN1bHRTY2hlbWFcbn0pLnN0cmljdCgpO1xudmFyIEpTT05SUENFcnJvclNjaGVtYSA9IHo5Lm9iamVjdCh7XG4gIGpzb25ycGM6IHo5LmxpdGVyYWwoSlNPTlJQQ19WRVJTSU9OKSxcbiAgaWQ6IHo5LnVuaW9uKFt6OS5zdHJpbmcoKSwgejkubnVtYmVyKCkuaW50KCldKSxcbiAgZXJyb3I6IHo5Lm9iamVjdCh7XG4gICAgY29kZTogejkubnVtYmVyKCkuaW50KCksXG4gICAgbWVzc2FnZTogejkuc3RyaW5nKCksXG4gICAgZGF0YTogejkub3B0aW9uYWwoejkudW5rbm93bigpKVxuICB9KVxufSkuc3RyaWN0KCk7XG52YXIgSlNPTlJQQ05vdGlmaWNhdGlvblNjaGVtYSA9IHo5Lm9iamVjdCh7XG4gIGpzb25ycGM6IHo5LmxpdGVyYWwoSlNPTlJQQ19WRVJTSU9OKVxufSkubWVyZ2UoXG4gIHo5Lm9iamVjdCh7XG4gICAgbWV0aG9kOiB6OS5zdHJpbmcoKSxcbiAgICBwYXJhbXM6IHo5Lm9wdGlvbmFsKEJhc2VQYXJhbXNTY2hlbWEpXG4gIH0pXG4pLnN0cmljdCgpO1xudmFyIEpTT05SUENNZXNzYWdlU2NoZW1hID0gejkudW5pb24oW1xuICBKU09OUlBDUmVxdWVzdFNjaGVtYSxcbiAgSlNPTlJQQ05vdGlmaWNhdGlvblNjaGVtYSxcbiAgSlNPTlJQQ1Jlc3BvbnNlU2NoZW1hLFxuICBKU09OUlBDRXJyb3JTY2hlbWFcbl0pO1xuXG4vLyBjb3JlL3Rvb2wvbWNwL21jcC1zc2UtdHJhbnNwb3J0LnRzXG52YXIgU3NlTUNQVHJhbnNwb3J0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdXJsLFxuICAgIGhlYWRlcnNcbiAgfSkge1xuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy51cmwgPSBuZXcgVVJMKHVybCk7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgfVxuICBhc3luYyBzdGFydCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IGVzdGFibGlzaENvbm5lY3Rpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHZhciBfYTE3LCBfYiwgX2M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyk7XG4gICAgICAgICAgaGVhZGVycy5zZXQoXCJBY2NlcHRcIiwgXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiKTtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMudXJsLmhyZWYsIHtcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IChfYTE3ID0gdGhpcy5hYm9ydENvbnRyb2xsZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LnNpZ25hbFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghcmVzcG9uc2Uub2sgfHwgIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogYE1DUCBTU0UgVHJhbnNwb3J0IEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKF9iID0gdGhpcy5vbmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3RyZWFtID0gcmVzcG9uc2UuYm9keS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkucGlwZVRocm91Z2goY3JlYXRlRXZlbnRTb3VyY2VQYXJzZXJTdHJlYW0oKSk7XG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICAgIGNvbnN0IHByb2Nlc3NFdmVudHMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2ExOCwgX2IyLCBfYzI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTUNQIFNTRSBUcmFuc3BvcnQgRXJyb3I6IENvbm5lY3Rpb24gY2xvc2VkIHVuZXhwZWN0ZWRseVwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGV2ZW50LCBkYXRhIH0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQgPT09IFwiZW5kcG9pbnRcIikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5lbmRwb2ludCA9IG5ldyBVUkwoZGF0YSwgdGhpcy51cmwpO1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5kcG9pbnQub3JpZ2luICE9PSB0aGlzLnVybC5vcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgTUNQIFNTRSBUcmFuc3BvcnQgRXJyb3I6IEVuZHBvaW50IG9yaWdpbiBkb2VzIG5vdCBtYXRjaCBjb25uZWN0aW9uIG9yaWdpbjogJHt0aGlzLmVuZHBvaW50Lm9yaWdpbn1gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09IFwibWVzc2FnZVwiKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTlJQQ01lc3NhZ2VTY2hlbWEucGFyc2UoXG4gICAgICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShkYXRhKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAoX2ExOCA9IHRoaXMub25tZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOC5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJNQ1AgU1NFIFRyYW5zcG9ydCBFcnJvcjogRmFpbGVkIHRvIHBhcnNlIG1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIChfYjIgPSB0aGlzLm9uZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYjIuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIChfYzIgPSB0aGlzLm9uZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYzIuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLnNzZUNvbm5lY3Rpb24gPSB7XG4gICAgICAgICAgICBjbG9zZTogKCkgPT4gcmVhZGVyLmNhbmNlbCgpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBwcm9jZXNzRXZlbnRzKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgKF9jID0gdGhpcy5vbmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVzdGFibGlzaENvbm5lY3Rpb24oKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICB2YXIgX2ExNywgX2IsIF9jO1xuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgKF9hMTcgPSB0aGlzLnNzZUNvbm5lY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNsb3NlKCk7XG4gICAgKF9iID0gdGhpcy5hYm9ydENvbnRyb2xsZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5hYm9ydCgpO1xuICAgIChfYyA9IHRoaXMub25jbG9zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwodGhpcyk7XG4gIH1cbiAgYXN5bmMgc2VuZChtZXNzYWdlKSB7XG4gICAgdmFyIF9hMTcsIF9iLCBfYztcbiAgICBpZiAoIXRoaXMuZW5kcG9pbnQgfHwgIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIk1DUCBTU0UgVHJhbnNwb3J0IEVycm9yOiBOb3QgY29ubmVjdGVkXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyk7XG4gICAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICBjb25zdCBpbml0ID0ge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSxcbiAgICAgICAgc2lnbmFsOiAoX2ExNyA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5zaWduYWxcbiAgICAgIH07XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuZW5kcG9pbnQsIGluaXQpO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCB0ZXh0MiA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGBNQ1AgU1NFIFRyYW5zcG9ydCBFcnJvcjogUE9TVGluZyB0byBlbmRwb2ludCAoSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30pOiAke3RleHQyfWBcbiAgICAgICAgfSk7XG4gICAgICAgIChfYiA9IHRoaXMub25lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIChfYyA9IHRoaXMub25lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufTtcblxuLy8gY29yZS90b29sL21jcC9tY3AtdHJhbnNwb3J0LnRzXG5mdW5jdGlvbiBjcmVhdGVNY3BUcmFuc3BvcnQoY29uZmlnKSB7XG4gIGlmIChjb25maWcudHlwZSAhPT0gXCJzc2VcIikge1xuICAgIHRocm93IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICBtZXNzYWdlOiBcIlVuc3VwcG9ydGVkIG9yIGludmFsaWQgdHJhbnNwb3J0IGNvbmZpZ3VyYXRpb24uIElmIHlvdSBhcmUgdXNpbmcgYSBjdXN0b20gdHJhbnNwb3J0LCBtYWtlIHN1cmUgaXQgaW1wbGVtZW50cyB0aGUgTUNQVHJhbnNwb3J0IGludGVyZmFjZS5cIlxuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgU3NlTUNQVHJhbnNwb3J0KGNvbmZpZyk7XG59XG5mdW5jdGlvbiBpc0N1c3RvbU1jcFRyYW5zcG9ydCh0cmFuc3BvcnQpIHtcbiAgcmV0dXJuIFwic3RhcnRcIiBpbiB0cmFuc3BvcnQgJiYgdHlwZW9mIHRyYW5zcG9ydC5zdGFydCA9PT0gXCJmdW5jdGlvblwiICYmIFwic2VuZFwiIGluIHRyYW5zcG9ydCAmJiB0eXBlb2YgdHJhbnNwb3J0LnNlbmQgPT09IFwiZnVuY3Rpb25cIiAmJiBcImNsb3NlXCIgaW4gdHJhbnNwb3J0ICYmIHR5cGVvZiB0cmFuc3BvcnQuY2xvc2UgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gY29yZS90b29sL21jcC9tY3AtY2xpZW50LnRzXG52YXIgQ0xJRU5UX1ZFUlNJT04gPSBcIjEuMC4wXCI7XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVNQ1BDbGllbnQoY29uZmlnKSB7XG4gIGNvbnN0IGNsaWVudCA9IG5ldyBNQ1BDbGllbnQoY29uZmlnKTtcbiAgYXdhaXQgY2xpZW50LmluaXQoKTtcbiAgcmV0dXJuIGNsaWVudDtcbn1cbnZhciBNQ1BDbGllbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0cmFuc3BvcnQ6IHRyYW5zcG9ydENvbmZpZyxcbiAgICBuYW1lOiBuYW1lMTcgPSBcImFpLXNkay1tY3AtY2xpZW50XCIsXG4gICAgb25VbmNhdWdodEVycm9yXG4gIH0pIHtcbiAgICB0aGlzLnJlcXVlc3RNZXNzYWdlSWQgPSAwO1xuICAgIHRoaXMucmVzcG9uc2VIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5zZXJ2ZXJDYXBhYmlsaXRpZXMgPSB7fTtcbiAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLm9uVW5jYXVnaHRFcnJvciA9IG9uVW5jYXVnaHRFcnJvcjtcbiAgICBpZiAoaXNDdXN0b21NY3BUcmFuc3BvcnQodHJhbnNwb3J0Q29uZmlnKSkge1xuICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnRDb25maWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNwb3J0ID0gY3JlYXRlTWNwVHJhbnNwb3J0KHRyYW5zcG9ydENvbmZpZyk7XG4gICAgfVxuICAgIHRoaXMudHJhbnNwb3J0Lm9uY2xvc2UgPSAoKSA9PiB0aGlzLm9uQ2xvc2UoKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5vbmVycm9yID0gKGVycm9yKSA9PiB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgIHRoaXMudHJhbnNwb3J0Lm9ubWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICBpZiAoXCJtZXRob2RcIiBpbiBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMub25FcnJvcihcbiAgICAgICAgICBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJVbnN1cHBvcnRlZCBtZXNzYWdlIHR5cGVcIlxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMub25SZXNwb25zZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50SW5mbyA9IHtcbiAgICAgIG5hbWU6IG5hbWUxNyxcbiAgICAgIHZlcnNpb246IENMSUVOVF9WRVJTSU9OXG4gICAgfTtcbiAgfVxuICBhc3luYyBpbml0KCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnRyYW5zcG9ydC5zdGFydCgpO1xuICAgICAgdGhpcy5pc0Nsb3NlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgIG1ldGhvZDogXCJpbml0aWFsaXplXCIsXG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBwcm90b2NvbFZlcnNpb246IExBVEVTVF9QUk9UT0NPTF9WRVJTSU9OLFxuICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiB7fSxcbiAgICAgICAgICAgIGNsaWVudEluZm86IHRoaXMuY2xpZW50SW5mb1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0U2NoZW1hOiBJbml0aWFsaXplUmVzdWx0U2NoZW1hXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiU2VydmVyIHNlbnQgaW52YWxpZCBpbml0aWFsaXplIHJlc3VsdFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFTVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTlMuaW5jbHVkZXMocmVzdWx0LnByb3RvY29sVmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBgU2VydmVyJ3MgcHJvdG9jb2wgdmVyc2lvbiBpcyBub3Qgc3VwcG9ydGVkOiAke3Jlc3VsdC5wcm90b2NvbFZlcnNpb259YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VydmVyQ2FwYWJpbGl0aWVzID0gcmVzdWx0LmNhcGFiaWxpdGllcztcbiAgICAgIGF3YWl0IHRoaXMubm90aWZpY2F0aW9uKHtcbiAgICAgICAgbWV0aG9kOiBcIm5vdGlmaWNhdGlvbnMvaW5pdGlhbGl6ZWRcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgYXdhaXQgdGhpcy5jbG9zZSgpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHZhciBfYTE3O1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKVxuICAgICAgcmV0dXJuO1xuICAgIGF3YWl0ICgoX2ExNyA9IHRoaXMudHJhbnNwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jbG9zZSgpKTtcbiAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgfVxuICBhc3NlcnRDYXBhYmlsaXR5KG1ldGhvZCkge1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlIFwiaW5pdGlhbGl6ZVwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b29scy9saXN0XCI6XG4gICAgICBjYXNlIFwidG9vbHMvY2FsbFwiOlxuICAgICAgICBpZiAoIXRoaXMuc2VydmVyQ2FwYWJpbGl0aWVzLnRvb2xzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCB0b29sc2BcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogYFVuc3VwcG9ydGVkIG1ldGhvZDogJHttZXRob2R9YFxuICAgICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVxdWVzdCh7XG4gICAgcmVxdWVzdCxcbiAgICByZXN1bHRTY2hlbWEsXG4gICAgb3B0aW9uc1xuICB9KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoXG4gICAgICAgICAgbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiQXR0ZW1wdGVkIHRvIHNlbmQgYSByZXF1ZXN0IGZyb20gYSBjbG9zZWQgY2xpZW50XCJcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3NlcnRDYXBhYmlsaXR5KHJlcXVlc3QubWV0aG9kKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgc2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBzaWduYWwudGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VJZCA9IHRoaXMucmVxdWVzdE1lc3NhZ2VJZCsrO1xuICAgICAgY29uc3QganNvbnJwY1JlcXVlc3QgPSB7XG4gICAgICAgIC4uLnJlcXVlc3QsXG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGlkOiBtZXNzYWdlSWRcbiAgICAgIH07XG4gICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnJlc3BvbnNlSGFuZGxlcnMuZGVsZXRlKG1lc3NhZ2VJZCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5yZXNwb25zZUhhbmRsZXJzLnNldChtZXNzYWdlSWQsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAoc2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoXG4gICAgICAgICAgICBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgICAgICBtZXNzYWdlOiBcIlJlcXVlc3Qgd2FzIGFib3J0ZWRcIixcbiAgICAgICAgICAgICAgY2F1c2U6IHNpZ25hbC5yZWFzb25cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiByZWplY3QocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0U2NoZW1hLnBhcnNlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnN0IHBhcnNlRXJyb3IgPSBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcGFyc2Ugc2VydmVyIHJlc3BvbnNlXCIsXG4gICAgICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZWplY3QocGFyc2VFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZChqc29ucnBjUmVxdWVzdCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGxpc3RUb29scyh7XG4gICAgcGFyYW1zLFxuICAgIG9wdGlvbnNcbiAgfSA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICByZXF1ZXN0OiB7IG1ldGhvZDogXCJ0b29scy9saXN0XCIsIHBhcmFtcyB9LFxuICAgICAgICByZXN1bHRTY2hlbWE6IExpc3RUb29sc1Jlc3VsdFNjaGVtYSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBjYWxsVG9vbCh7XG4gICAgbmFtZTogbmFtZTE3LFxuICAgIGFyZ3MsXG4gICAgb3B0aW9uc1xuICB9KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICByZXF1ZXN0OiB7IG1ldGhvZDogXCJ0b29scy9jYWxsXCIsIHBhcmFtczogeyBuYW1lOiBuYW1lMTcsIGFyZ3VtZW50czogYXJncyB9IH0sXG4gICAgICAgIHJlc3VsdFNjaGVtYTogQ2FsbFRvb2xSZXN1bHRTY2hlbWEsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBzaWduYWw6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBub3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3QganNvbnJwY05vdGlmaWNhdGlvbiA9IHtcbiAgICAgIC4uLm5vdGlmaWNhdGlvbixcbiAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICB9O1xuICAgIGF3YWl0IHRoaXMudHJhbnNwb3J0LnNlbmQoanNvbnJwY05vdGlmaWNhdGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzZXQgb2YgQUkgU0RLIHRvb2xzIGZyb20gdGhlIE1DUCBzZXJ2ZXJcbiAgICogQHJldHVybnMgQSByZWNvcmQgb2YgdG9vbCBuYW1lcyB0byB0aGVpciBpbXBsZW1lbnRhdGlvbnNcbiAgICovXG4gIGFzeW5jIHRvb2xzKHtcbiAgICBzY2hlbWFzID0gXCJhdXRvbWF0aWNcIlxuICB9ID0ge30pIHtcbiAgICB2YXIgX2ExNztcbiAgICBjb25zdCB0b29scyA9IHt9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBsaXN0VG9vbHNSZXN1bHQgPSBhd2FpdCB0aGlzLmxpc3RUb29scygpO1xuICAgICAgZm9yIChjb25zdCB7IG5hbWU6IG5hbWUxNywgZGVzY3JpcHRpb24sIGlucHV0U2NoZW1hIH0gb2YgbGlzdFRvb2xzUmVzdWx0LnRvb2xzKSB7XG4gICAgICAgIGlmIChzY2hlbWFzICE9PSBcImF1dG9tYXRpY1wiICYmICEobmFtZTE3IGluIHNjaGVtYXMpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHNjaGVtYXMgPT09IFwiYXV0b21hdGljXCIgPyBqc29uU2NoZW1hKHtcbiAgICAgICAgICAuLi5pbnB1dFNjaGVtYSxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiAoX2ExNyA9IGlucHV0U2NoZW1hLnByb3BlcnRpZXMpICE9IG51bGwgPyBfYTE3IDoge30sXG4gICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlXG4gICAgICAgIH0pIDogc2NoZW1hc1tuYW1lMTddLnBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCB0b29sV2l0aEV4ZWN1dGUgPSB0b29sKHtcbiAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgIGV4ZWN1dGU6IGFzeW5jIChhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICAgIChfYTE4ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5hYm9ydFNpZ25hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTgudGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxUb29sKHtcbiAgICAgICAgICAgICAgbmFtZTogbmFtZTE3LFxuICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0b29sc1tuYW1lMTddID0gdG9vbFdpdGhFeGVjdXRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRvb2xzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgb25DbG9zZSgpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICBtZXNzYWdlOiBcIkNvbm5lY3Rpb24gY2xvc2VkXCJcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgdGhpcy5yZXNwb25zZUhhbmRsZXJzLnZhbHVlcygpKSB7XG4gICAgICBoYW5kbGVyKGVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5yZXNwb25zZUhhbmRsZXJzLmNsZWFyKCk7XG4gIH1cbiAgb25FcnJvcihlcnJvcikge1xuICAgIGlmICh0aGlzLm9uVW5jYXVnaHRFcnJvcikge1xuICAgICAgdGhpcy5vblVuY2F1Z2h0RXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBvblJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgbWVzc2FnZUlkID0gTnVtYmVyKHJlc3BvbnNlLmlkKTtcbiAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5yZXNwb25zZUhhbmRsZXJzLmdldChtZXNzYWdlSWQpO1xuICAgIGlmIChoYW5kbGVyID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBQcm90b2NvbCBlcnJvcjogUmVjZWl2ZWQgYSByZXNwb25zZSBmb3IgYW4gdW5rbm93biBtZXNzYWdlIElEOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHJlc3BvbnNlXG4gICAgICAgICl9YFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMucmVzcG9uc2VIYW5kbGVycy5kZWxldGUobWVzc2FnZUlkKTtcbiAgICBoYW5kbGVyKFxuICAgICAgXCJyZXN1bHRcIiBpbiByZXNwb25zZSA/IHJlc3BvbnNlIDogbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogcmVzcG9uc2UuZXJyb3IubWVzc2FnZSxcbiAgICAgICAgY2F1c2U6IHJlc3BvbnNlLmVycm9yXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn07XG5cbi8vIGNvcmUvdXRpbC9jb3NpbmUtc2ltaWxhcml0eS50c1xuZnVuY3Rpb24gY29zaW5lU2ltaWxhcml0eSh2ZWN0b3IxLCB2ZWN0b3IyLCBvcHRpb25zKSB7XG4gIGlmICh2ZWN0b3IxLmxlbmd0aCAhPT0gdmVjdG9yMi5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgcGFyYW1ldGVyOiBcInZlY3RvcjEsdmVjdG9yMlwiLFxuICAgICAgdmFsdWU6IHsgdmVjdG9yMUxlbmd0aDogdmVjdG9yMS5sZW5ndGgsIHZlY3RvcjJMZW5ndGg6IHZlY3RvcjIubGVuZ3RoIH0sXG4gICAgICBtZXNzYWdlOiBgVmVjdG9ycyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoYFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IG4gPSB2ZWN0b3IxLmxlbmd0aDtcbiAgaWYgKG4gPT09IDApIHtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50aHJvd0Vycm9yRm9yRW1wdHlWZWN0b3JzKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidmVjdG9yMVwiLFxuICAgICAgICB2YWx1ZTogdmVjdG9yMSxcbiAgICAgICAgbWVzc2FnZTogXCJWZWN0b3JzIGNhbm5vdCBiZSBlbXB0eVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbGV0IG1hZ25pdHVkZVNxdWFyZWQxID0gMDtcbiAgbGV0IG1hZ25pdHVkZVNxdWFyZWQyID0gMDtcbiAgbGV0IGRvdFByb2R1Y3QgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGNvbnN0IHZhbHVlMSA9IHZlY3RvcjFbaV07XG4gICAgY29uc3QgdmFsdWUyID0gdmVjdG9yMltpXTtcbiAgICBtYWduaXR1ZGVTcXVhcmVkMSArPSB2YWx1ZTEgKiB2YWx1ZTE7XG4gICAgbWFnbml0dWRlU3F1YXJlZDIgKz0gdmFsdWUyICogdmFsdWUyO1xuICAgIGRvdFByb2R1Y3QgKz0gdmFsdWUxICogdmFsdWUyO1xuICB9XG4gIHJldHVybiBtYWduaXR1ZGVTcXVhcmVkMSA9PT0gMCB8fCBtYWduaXR1ZGVTcXVhcmVkMiA9PT0gMCA/IDAgOiBkb3RQcm9kdWN0IC8gKE1hdGguc3FydChtYWduaXR1ZGVTcXVhcmVkMSkgKiBNYXRoLnNxcnQobWFnbml0dWRlU3F1YXJlZDIpKTtcbn1cblxuLy8gY29yZS91dGlsL3NpbXVsYXRlLXJlYWRhYmxlLXN0cmVhbS50c1xuaW1wb3J0IHsgZGVsYXkgYXMgZGVsYXlGdW5jdGlvbiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5mdW5jdGlvbiBzaW11bGF0ZVJlYWRhYmxlU3RyZWFtKHtcbiAgY2h1bmtzLFxuICBpbml0aWFsRGVsYXlJbk1zID0gMCxcbiAgY2h1bmtEZWxheUluTXMgPSAwLFxuICBfaW50ZXJuYWxcbn0pIHtcbiAgdmFyIF9hMTc7XG4gIGNvbnN0IGRlbGF5MiA9IChfYTE3ID0gX2ludGVybmFsID09IG51bGwgPyB2b2lkIDAgOiBfaW50ZXJuYWwuZGVsYXkpICE9IG51bGwgPyBfYTE3IDogZGVsYXlGdW5jdGlvbjtcbiAgbGV0IGluZGV4ID0gMDtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoaW5kZXggPCBjaHVua3MubGVuZ3RoKSB7XG4gICAgICAgIGF3YWl0IGRlbGF5MihpbmRleCA9PT0gMCA/IGluaXRpYWxEZWxheUluTXMgOiBjaHVua0RlbGF5SW5Ncyk7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVua3NbaW5kZXgrK10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHN0cmVhbXMvYXNzaXN0YW50LXJlc3BvbnNlLnRzXG5pbXBvcnQge1xuICBmb3JtYXRBc3Npc3RhbnRTdHJlYW1QYXJ0IGFzIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQyXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiBBc3Npc3RhbnRSZXNwb25zZSh7IHRocmVhZElkLCBtZXNzYWdlSWQgfSwgcHJvY2VzczIpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2ExNztcbiAgICAgIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICBjb25zdCBzZW5kTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICBmb3JtYXRBc3Npc3RhbnRTdHJlYW1QYXJ0MihcImFzc2lzdGFudF9tZXNzYWdlXCIsIG1lc3NhZ2UpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlbmREYXRhTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICBmb3JtYXRBc3Npc3RhbnRTdHJlYW1QYXJ0MihcImRhdGFfbWVzc2FnZVwiLCBtZXNzYWdlKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZW5kRXJyb3IgPSAoZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0QXNzaXN0YW50U3RyZWFtUGFydDIoXCJlcnJvclwiLCBlcnJvck1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZvcndhcmRTdHJlYW0gPSBhc3luYyAoc3RyZWFtMikgPT4ge1xuICAgICAgICB2YXIgX2ExOCwgX2I7XG4gICAgICAgIGxldCByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2Ygc3RyZWFtMikge1xuICAgICAgICAgIHN3aXRjaCAodmFsdWUuZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQubWVzc2FnZS5jcmVhdGVkXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQyKFwiYXNzaXN0YW50X21lc3NhZ2VcIiwge1xuICAgICAgICAgICAgICAgICAgICBpZDogdmFsdWUuZGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHsgdmFsdWU6IFwiXCIgfSB9XVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5tZXNzYWdlLmRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IChfYTE4ID0gdmFsdWUuZGF0YS5kZWx0YS5jb250ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2ExOFswXTtcbiAgICAgICAgICAgICAgaWYgKChjb250ZW50ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZW50LnR5cGUpID09PSBcInRleHRcIiAmJiAoKF9iID0gY29udGVudC50ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2IudmFsdWUpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQyKFwidGV4dFwiLCBjb250ZW50LnRleHQudmFsdWUpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQucnVuLmNvbXBsZXRlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5ydW4ucmVxdWlyZXNfYWN0aW9uXCI6IHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUuZGF0YTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgZm9ybWF0QXNzaXN0YW50U3RyZWFtUGFydDIoXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsIHtcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgbWVzc2FnZUlkXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHByb2Nlc3MyKHtcbiAgICAgICAgICBzZW5kTWVzc2FnZSxcbiAgICAgICAgICBzZW5kRGF0YU1lc3NhZ2UsXG4gICAgICAgICAgZm9yd2FyZFN0cmVhbVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHNlbmRFcnJvcigoX2ExNyA9IGVycm9yLm1lc3NhZ2UpICE9IG51bGwgPyBfYTE3IDogYCR7ZXJyb3J9YCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICB9LFxuICAgIGNhbmNlbCgpIHtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHN0cmVhbSwge1xuICAgIHN0YXR1czogMjAwLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3RyZWFtcy9sYW5nY2hhaW4tYWRhcHRlci50c1xudmFyIGxhbmdjaGFpbl9hZGFwdGVyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGxhbmdjaGFpbl9hZGFwdGVyX2V4cG9ydHMsIHtcbiAgbWVyZ2VJbnRvRGF0YVN0cmVhbTogKCkgPT4gbWVyZ2VJbnRvRGF0YVN0cmVhbSxcbiAgdG9EYXRhU3RyZWFtOiAoKSA9PiB0b0RhdGFTdHJlYW0sXG4gIHRvRGF0YVN0cmVhbVJlc3BvbnNlOiAoKSA9PiB0b0RhdGFTdHJlYW1SZXNwb25zZVxufSk7XG5pbXBvcnQgeyBmb3JtYXREYXRhU3RyZWFtUGFydCBhcyBmb3JtYXREYXRhU3RyZWFtUGFydDQgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyBzdHJlYW1zL3N0cmVhbS1jYWxsYmFja3MudHNcbmZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcyA9IHt9KSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSBcIlwiO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uU3RhcnQpXG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblN0YXJ0KCk7XG4gICAgfSxcbiAgICBhc3luYyB0cmFuc2Zvcm0obWVzc2FnZSwgY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShtZXNzYWdlKSk7XG4gICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Ub2tlbilcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVG9rZW4obWVzc2FnZSk7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVGV4dCAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25UZXh0KG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uQ29tcGxldGlvbikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Db21wbGV0aW9uKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzdHJlYW1zL2xhbmdjaGFpbi1hZGFwdGVyLnRzXG5mdW5jdGlvbiB0b0RhdGFTdHJlYW1JbnRlcm5hbChzdHJlYW0sIGNhbGxiYWNrcykge1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtOiBhc3luYyAodmFsdWUsIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgdmFyIF9hMTc7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJldmVudFwiIGluIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmV2ZW50ID09PSBcIm9uX2NoYXRfbW9kZWxfc3RyZWFtXCIpIHtcbiAgICAgICAgICAgIGZvcndhcmRBSU1lc3NhZ2VDaHVuayhcbiAgICAgICAgICAgICAgKF9hMTcgPSB2YWx1ZS5kYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jaHVuayxcbiAgICAgICAgICAgICAgY29udHJvbGxlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmRBSU1lc3NhZ2VDaHVuayh2YWx1ZSwgY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSlcbiAgKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZm9ybWF0RGF0YVN0cmVhbVBhcnQ0KFwidGV4dFwiLCBjaHVuaykpO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW0oc3RyZWFtLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIHRvRGF0YVN0cmVhbUludGVybmFsKHN0cmVhbSwgY2FsbGJhY2tzKS5waXBlVGhyb3VnaChcbiAgICBuZXcgVGV4dEVuY29kZXJTdHJlYW0oKVxuICApO1xufVxuZnVuY3Rpb24gdG9EYXRhU3RyZWFtUmVzcG9uc2Uoc3RyZWFtLCBvcHRpb25zKSB7XG4gIHZhciBfYTE3O1xuICBjb25zdCBkYXRhU3RyZWFtID0gdG9EYXRhU3RyZWFtSW50ZXJuYWwoXG4gICAgc3RyZWFtLFxuICAgIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FsbGJhY2tzXG4gICkucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpO1xuICBjb25zdCBkYXRhID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhO1xuICBjb25zdCBpbml0ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5pbml0O1xuICBjb25zdCByZXNwb25zZVN0cmVhbSA9IGRhdGEgPyBtZXJnZVN0cmVhbXMoZGF0YS5zdHJlYW0sIGRhdGFTdHJlYW0pIDogZGF0YVN0cmVhbTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShyZXNwb25zZVN0cmVhbSwge1xuICAgIHN0YXR1czogKF9hMTcgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTcgOiAyMDAsXG4gICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzLCB7XG4gICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICBkYXRhU3RyZWFtVmVyc2lvbjogXCJ2MVwiXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBtZXJnZUludG9EYXRhU3RyZWFtKHN0cmVhbSwgb3B0aW9ucykge1xuICBvcHRpb25zLmRhdGFTdHJlYW0ubWVyZ2UodG9EYXRhU3RyZWFtSW50ZXJuYWwoc3RyZWFtLCBvcHRpb25zLmNhbGxiYWNrcykpO1xufVxuZnVuY3Rpb24gZm9yd2FyZEFJTWVzc2FnZUNodW5rKGNodW5rLCBjb250cm9sbGVyKSB7XG4gIGlmICh0eXBlb2YgY2h1bmsuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5jb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb250ZW50ID0gY2h1bmsuY29udGVudDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29udGVudCkge1xuICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGl0ZW0udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHN0cmVhbXMvbGxhbWFpbmRleC1hZGFwdGVyLnRzXG52YXIgbGxhbWFpbmRleF9hZGFwdGVyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGxsYW1haW5kZXhfYWRhcHRlcl9leHBvcnRzLCB7XG4gIG1lcmdlSW50b0RhdGFTdHJlYW06ICgpID0+IG1lcmdlSW50b0RhdGFTdHJlYW0yLFxuICB0b0RhdGFTdHJlYW06ICgpID0+IHRvRGF0YVN0cmVhbTIsXG4gIHRvRGF0YVN0cmVhbVJlc3BvbnNlOiAoKSA9PiB0b0RhdGFTdHJlYW1SZXNwb25zZTJcbn0pO1xuaW1wb3J0IHsgY29udmVydEFzeW5jSXRlcmF0b3JUb1JlYWRhYmxlU3RyZWFtIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IGZvcm1hdERhdGFTdHJlYW1QYXJ0IGFzIGZvcm1hdERhdGFTdHJlYW1QYXJ0NSB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW1JbnRlcm5hbDIoc3RyZWFtLCBjYWxsYmFja3MpIHtcbiAgY29uc3QgdHJpbVN0YXJ0ID0gdHJpbVN0YXJ0T2ZTdHJlYW0oKTtcbiAgcmV0dXJuIGNvbnZlcnRBc3luY0l0ZXJhdG9yVG9SZWFkYWJsZVN0cmVhbShzdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkpLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgYXN5bmMgdHJhbnNmb3JtKG1lc3NhZ2UsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRyaW1TdGFydChtZXNzYWdlLmRlbHRhKSk7XG4gICAgICB9XG4gICAgfSlcbiAgKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZm9ybWF0RGF0YVN0cmVhbVBhcnQ1KFwidGV4dFwiLCBjaHVuaykpO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW0yKHN0cmVhbSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiB0b0RhdGFTdHJlYW1JbnRlcm5hbDIoc3RyZWFtLCBjYWxsYmFja3MpLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpXG4gICk7XG59XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW1SZXNwb25zZTIoc3RyZWFtLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hMTc7XG4gIGNvbnN0IHsgaW5pdCwgZGF0YSwgY2FsbGJhY2tzIH0gPSBvcHRpb25zO1xuICBjb25zdCBkYXRhU3RyZWFtID0gdG9EYXRhU3RyZWFtSW50ZXJuYWwyKHN0cmVhbSwgY2FsbGJhY2tzKS5waXBlVGhyb3VnaChcbiAgICBuZXcgVGV4dEVuY29kZXJTdHJlYW0oKVxuICApO1xuICBjb25zdCByZXNwb25zZVN0cmVhbSA9IGRhdGEgPyBtZXJnZVN0cmVhbXMoZGF0YS5zdHJlYW0sIGRhdGFTdHJlYW0pIDogZGF0YVN0cmVhbTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShyZXNwb25zZVN0cmVhbSwge1xuICAgIHN0YXR1czogKF9hMTcgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTcgOiAyMDAsXG4gICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzLCB7XG4gICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICBkYXRhU3RyZWFtVmVyc2lvbjogXCJ2MVwiXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBtZXJnZUludG9EYXRhU3RyZWFtMihzdHJlYW0sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5kYXRhU3RyZWFtLm1lcmdlKHRvRGF0YVN0cmVhbUludGVybmFsMihzdHJlYW0sIG9wdGlvbnMuY2FsbGJhY2tzKSk7XG59XG5mdW5jdGlvbiB0cmltU3RhcnRPZlN0cmVhbSgpIHtcbiAgbGV0IGlzU3RyZWFtU3RhcnQgPSB0cnVlO1xuICByZXR1cm4gKHRleHQyKSA9PiB7XG4gICAgaWYgKGlzU3RyZWFtU3RhcnQpIHtcbiAgICAgIHRleHQyID0gdGV4dDIudHJpbVN0YXJ0KCk7XG4gICAgICBpZiAodGV4dDIpXG4gICAgICAgIGlzU3RyZWFtU3RhcnQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQyO1xuICB9O1xufVxuXG4vLyBzdHJlYW1zL3N0cmVhbS1kYXRhLnRzXG5pbXBvcnQgeyBmb3JtYXREYXRhU3RyZWFtUGFydCBhcyBmb3JtYXREYXRhU3RyZWFtUGFydDYgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyB1dGlsL2NvbnN0YW50cy50c1xudmFyIEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyA9IDE1ICogMWUzO1xuXG4vLyBzdHJlYW1zL3N0cmVhbS1kYXRhLnRzXG52YXIgU3RyZWFtRGF0YSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbnVsbDtcbiAgICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy53YXJuaW5nVGltZW91dCA9IG51bGw7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IGFzeW5jIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIHNlbGYuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgICAgc2VsZi53YXJuaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBcIlRoZSBkYXRhIHN0cmVhbSBpcyBoYW5naW5nLiBEaWQgeW91IGZvcmdldCB0byBjbG9zZSBpdCB3aXRoIGBkYXRhLmNsb3NlKClgP1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sIEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwdWxsOiAoY29udHJvbGxlcikgPT4ge1xuICAgICAgfSxcbiAgICAgIGNhbmNlbDogKHJlYXNvbikgPT4ge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMud2FybmluZ1RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLndhcm5pbmdUaW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgYXBwZW5kKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC5cIik7XG4gICAgfVxuICAgIHRoaXMuY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgdGhpcy5lbmNvZGVyLmVuY29kZShmb3JtYXREYXRhU3RyZWFtUGFydDYoXCJkYXRhXCIsIFt2YWx1ZV0pKVxuICAgICk7XG4gIH1cbiAgYXBwZW5kTWVzc2FnZUFubm90YXRpb24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250cm9sbGVyLmVucXVldWUoXG4gICAgICB0aGlzLmVuY29kZXIuZW5jb2RlKGZvcm1hdERhdGFTdHJlYW1QYXJ0NihcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgW3ZhbHVlXSkpXG4gICAgKTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIEFJU0RLRXJyb3IxNiBhcyBBSVNES0Vycm9yLFxuICBBUElDYWxsRXJyb3IyIGFzIEFQSUNhbGxFcnJvcixcbiAgQXNzaXN0YW50UmVzcG9uc2UsXG4gIERvd25sb2FkRXJyb3IsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcixcbiAgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IsXG4gIEludmFsaWRQcm9tcHRFcnJvcjIgYXMgSW52YWxpZFByb21wdEVycm9yLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEludmFsaWRTdHJlYW1QYXJ0RXJyb3IsXG4gIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yMiBhcyBKU09OUGFyc2VFcnJvcixcbiAgbGFuZ2NoYWluX2FkYXB0ZXJfZXhwb3J0cyBhcyBMYW5nQ2hhaW5BZGFwdGVyLFxuICBsbGFtYWluZGV4X2FkYXB0ZXJfZXhwb3J0cyBhcyBMbGFtYUluZGV4QWRhcHRlcixcbiAgTG9hZEFQSUtleUVycm9yLFxuICBNQ1BDbGllbnRFcnJvcixcbiAgTWVzc2FnZUNvbnZlcnNpb25FcnJvcixcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vSW1hZ2VHZW5lcmF0ZWRFcnJvcixcbiAgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcixcbiAgTm9PdXRwdXRTcGVjaWZpZWRFcnJvcixcbiAgTm9TdWNoTW9kZWxFcnJvcixcbiAgTm9TdWNoUHJvdmlkZXJFcnJvcixcbiAgTm9TdWNoVG9vbEVycm9yLFxuICBvdXRwdXRfZXhwb3J0cyBhcyBPdXRwdXQsXG4gIFJldHJ5RXJyb3IsXG4gIFN0cmVhbURhdGEsXG4gIFRvb2xDYWxsUmVwYWlyRXJyb3IsXG4gIFRvb2xFeGVjdXRpb25FcnJvcixcbiAgVHlwZVZhbGlkYXRpb25FcnJvcjMgYXMgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyIGFzIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yLFxuICBhcHBlbmRDbGllbnRNZXNzYWdlLFxuICBhcHBlbmRSZXNwb25zZU1lc3NhZ2VzLFxuICBjb252ZXJ0VG9Db3JlTWVzc2FnZXMsXG4gIGNvcmVBc3Npc3RhbnRNZXNzYWdlU2NoZW1hLFxuICBjb3JlTWVzc2FnZVNjaGVtYSxcbiAgY29yZVN5c3RlbU1lc3NhZ2VTY2hlbWEsXG4gIGNvcmVUb29sTWVzc2FnZVNjaGVtYSxcbiAgY29yZVVzZXJNZXNzYWdlU2NoZW1hLFxuICBjb3NpbmVTaW1pbGFyaXR5LFxuICBjcmVhdGVEYXRhU3RyZWFtLFxuICBjcmVhdGVEYXRhU3RyZWFtUmVzcG9uc2UsXG4gIGNyZWF0ZUlkR2VuZXJhdG9yNSBhcyBjcmVhdGVJZEdlbmVyYXRvcixcbiAgY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSxcbiAgY3VzdG9tUHJvdmlkZXIsXG4gIGRlZmF1bHRTZXR0aW5nc01pZGRsZXdhcmUsXG4gIGVtYmVkLFxuICBlbWJlZE1hbnksXG4gIGNyZWF0ZU1DUENsaWVudCBhcyBleHBlcmltZW50YWxfY3JlYXRlTUNQQ2xpZW50LFxuICBleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSxcbiAgZXhwZXJpbWVudGFsX2N1c3RvbVByb3ZpZGVyLFxuICBnZW5lcmF0ZUltYWdlIGFzIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZUltYWdlLFxuICBnZW5lcmF0ZVNwZWVjaCBhcyBleHBlcmltZW50YWxfZ2VuZXJhdGVTcGVlY2gsXG4gIHRyYW5zY3JpYmUgYXMgZXhwZXJpbWVudGFsX3RyYW5zY3JpYmUsXG4gIGV4cGVyaW1lbnRhbF93cmFwTGFuZ3VhZ2VNb2RlbCxcbiAgZXh0cmFjdFJlYXNvbmluZ01pZGRsZXdhcmUsXG4gIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQsXG4gIGZvcm1hdERhdGFTdHJlYW1QYXJ0MyBhcyBmb3JtYXREYXRhU3RyZWFtUGFydCxcbiAgZ2VuZXJhdGVJZDIgYXMgZ2VuZXJhdGVJZCxcbiAgZ2VuZXJhdGVPYmplY3QsXG4gIGdlbmVyYXRlVGV4dCxcbiAganNvblNjaGVtYTIgYXMganNvblNjaGVtYSxcbiAgcGFyc2VBc3Npc3RhbnRTdHJlYW1QYXJ0LFxuICBwYXJzZURhdGFTdHJlYW1QYXJ0LFxuICBwaXBlRGF0YVN0cmVhbVRvUmVzcG9uc2UsXG4gIHByb2Nlc3NEYXRhU3RyZWFtLFxuICBwcm9jZXNzVGV4dFN0cmVhbSxcbiAgc2ltdWxhdGVSZWFkYWJsZVN0cmVhbSxcbiAgc2ltdWxhdGVTdHJlYW1pbmdNaWRkbGV3YXJlLFxuICBzbW9vdGhTdHJlYW0sXG4gIHN0cmVhbU9iamVjdCxcbiAgc3RyZWFtVGV4dCxcbiAgdG9vbCxcbiAgd3JhcExhbmd1YWdlTW9kZWwsXG4gIHpvZFNjaGVtYVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/ai@4.3.16_react@18.3.1_zod@3.25.51/node_modules/ai/dist/index.mjs\n");

/***/ })

};
;